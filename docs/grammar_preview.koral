// Grammar Overview

// Import Module
using std
using std.text
using std.threading
using self.sub_mod.function_a
using super.super_mod.other_mod.function_b
using "inline_file"

// Foreign Function Interface (FFI)
foreign using "m"
foreign using "pthread"

foreign type FILE
foreign let fopen(path UInt8 ptr, mode UInt8 ptr) FILE ptr
foreign let fclose(file FILE ptr) Int32

let main() = {
    // Define
    let string String = "10"
    let single_quote_string String = 'hello, world!'
    let number Float64 = 1.2
    let integer Int = 123
    let binary Int = 0b1010           // 二进制字面量 (binary literal), value: 10
    let octal Int = 0o755             // 八进制字面量 (octal literal), value: 493
    let hex Int = 0xFF                // 十六进制字面量 (hexadecimal literal), value: 255
    let hex_sep Int = 0xFF_FF         // 带下划线分隔符 (with digit separator), value: 65535
    let bin_sep Int = 0b1010_0101     // 带下划线分隔符 (with digit separator), value: 165
    let boolean Bool = true
    let double Float64 = 1.23
    let single Float32 = (Float32)double // basic value convert

    // Constant
    let const pi Float64 = 3.141592653 

    // Mark String
    let format = "the value is \(integer), \(number), \(boolean)"
    let format = 'the value is \(integer), \(number), \(boolean)'

    // Array
    let array [3, Int]Array = [1,2,3]
    let matrix [3, [4, Int]Array]Array = [
        [1, 2, 3, 4],
        [5, 6, 7, 8],
        [9,10,11,12],
    ]

    // List
    let list [Int]List = [1, 2, 3, 4, 5]
    print( list[0] ) // 使用下标获取

    // Map, 前面为 key，后面为 value
    let map [String, Bool]Map = [("1", false), ("2", true)]
    print( map["1"] ) // 使用key获取

    // Set
    let mut s = [Int]Set.new()
    s.insert(1)
    // Set operations
    let u = a_set.union(ref b_set)
    let inter = a_set.intersection(ref b_set)
    let diff = a_set.difference(ref b_set)

    // Function
    let f(a Int) Int = a

    // Function with no params no return
    let do_something_void() Void = {
        do_something_a()
        do_something_b()
    }

    // Full Function with params and return
    let do_something_with_params(x Int, y String) [Int, String]Pair = Pair(x, y)

    // Function inferrence return type
    let let f(x Int, y Int) = x + y

    // Function type
    let f [Int, Int, Int]Func = (x Int, y Int) Int -> x + y
    let f [Int, Int, Int]Func = (x, y) -> x + y
    let g [Void]Func = () -> {}

    // Currying
    let add = (x Int) -> (y Int) -> x + y
    let add [Int, [Int, Int]Func]Func = (x) -> (y) -> x + y
    let v = add(1)(2)

    // Lambda Function
    List.of(1, 2, 3, 4).filter((x) -> x % 2 == 0).map((x) -> x * x).sum()

    // Func params
    let f(i [Int, Int]Func) = i(1)
    f((x Int) Int -> x)
    f((x) -> x)

    do_something_void();
    // use _ discard return value
    _ = do_something_with_params(3, "test")

    // logic operator
    x and y;
    x or y;
    not x;
    // compare operator
    x == y; // eq
    x <> y; // ne
    x > y;  // gt
    x < y;  // lt
    x >= y; // ge
    x <= y; // le
    // calculate operator
    x + y;  // add
    x - y;  // sub
    x * y;  // muv
    x / y;  // div
    x % y;  // mod
    // bitwise operator
    x & y;
    x | y;
    x ^ y;
    ~x;
    x << y;
    x >> y;
    // compound assignment operators
    x += y;
    x -= y;
    x *= y;
    x /= y;
    x %= y;
    x &= y;
    x |= y;
    x ^= y;
    x <<= y;
    x >>= y;
    // range operator
    x = 1..5;    // 1 <= x <= 5
    x = 1..<5;   // 1 <= x < 5
    x = 1<..5;   // 1 < x <= 5
    x = 1<..<5;  // 1 < x < 5
    x = 1...;    // 1 <= x <= max
    x = 1<...;   // 1 < x <= max
    x = ...5;    // min <= x <= 5
    x = ...<5;   // min <= x < 5
    x = ....;    // min <= x <= max

    // if-then, single branch structure
    if a < b then {
        todo()
    }

    // with-init
    let a = 1 then if a < 0 then {
        todo()
    }

    // if-then-else, double branch structure
    let v = if true then 0 else 0;
    if true then {
        todo()
    } else {
        todo()
    }

    if a then {
        todo()
    } else if b then {
        todo()
    } else {
        todo()
    }

    let op [Int]Option = .Some(1);
    // if with pattern matching
    if op is .Some(v) then {
        println(v)
    }

    // while-then, single branch structure
    while a < b then {
        todo()
    }

    // with-init
    let mut i = 0 then while i < 10 then {
        println(i)
        i += 1
    }

    // while-then-else, double branch structure, break can with value
    let v = while true then break 1 else 2;
    while true then {
        todo()
    } else {
        todo()
    }

    let iter [Int]Iterator = List.of(1,2,3).iterator()
    // while with pattern matching
    while iter.next() is .Some(v) then {
        println(v)
    }

    // for
    for item in list then {
        todo()
    }

    // with-init
    for item in [1,2,3,4] then {
        todo()
    }

    // Loop, use identify to take out single item
    for item in list then println(item)
    
    // take index and value, both worked at Dictionary
    for (index, value) in list.enumerate() then {
        println((index, value))
    }
    
    for i in 0..10 then {
        println(i)
    }

    for i in 0..10 then if i % 2 == 0 then print(i)

    // return, break, continue
    let early(x Int) Int = {
        if x > 0 then { return 1 }
        2
    }

    while i < 10 then {
        i += 1
        if i == 5 then { continue; }  // skip to next iteration
        if i == 8 then { break; }     // exit loop
    }

    // switch
    when x in {
        1 then "a",
        2 then "b",
        3 then "c",
        _ then "d",
    }

    let num = 42;
    when num in {
        0 or 1 or 2 or 3 or 4 or 5 or 6 or 7 or 8 or 9 then
            print("single digit"),
        10 then
            print("double digits"),
        n and >= 11 and <= 99 then 
            print("double digits"),
        n and >= 100 and <= 999 then 
            print("triple digits"),
        _ then
            print("four or more digits"),
    }

    if a is 1 or 2 then todo()
    if a is n and < 2 then todo()
    if a is not 2 then todo()

    // pattern matching
    when val in {
        1 then todo(), // int literal
        -5 then todo(), // negative int literal
        1.0 then todo(), // float literal
        'a' then todo(), // string literal
        "abc" then todo(), // string literal
        true then todo(), // bool literal
        _ then todo(), // wildcard
        const y then todo(), // y must be a constant
        x then todo(), // binding
        mut x then todo(), // mutable binding
        x Int then todo(), // type casting
        Int then todo(), // type casting
        Foo(x, y) then todo(), // type deconstruct
        .Some(x) then todo(), // enum deconstruct
        > 5 then todo(), // comparison pattern (greater than)
        < 10 then todo(), // comparison pattern (less than)
        >= 0 then todo(), // comparison pattern (greater or equal)
        <= 100 then todo(), // comparison pattern (less or equal)
        > -5 then todo(), // comparison pattern with negative literal
        1 or 2 then todo(), // or pattern combinator
        x and > 0 then todo(), // and pattern combinator with binding
        not 0 then todo(), // not pattern combinator
    }

    if foo() is A(x) then
    if bar(x) is B(y) then {
        do_stuff_with(x, y)
    }

    // or else / and then operators (for Option and Result)
    let opt = [Int]Option.Some(42)
    let val = opt or else 0                       // unwrap with default: 42
    let none_opt = [Int]Option.None()
    let val2 = none_opt or else 0                 // default: 0

    let doubled = opt and then _ * 2              // Some(84)
    let chained = opt and then _ + 1 and then _ * 3  // Some(129)

    // or else with early return (error propagation)
    let try_option(opt [Int]Option) Int = {
        let val = opt or else { return -1 }       // early return on None
        val
    }

    // and then with flatten (monadic bind)
    let safe_div(x Int, y Int) [Int]Option = {
        if y == 0 then .None() else .Some(x / y)
    }
    let result = opt and then safe_div(_, 10)     // auto-flatten Option[Option[T]] -> Option[T]

    // or else with Result error propagation
    let try_result(res [Int]Result) [Int]Result = {
        let val = res or else { return .Error(_) }
        .Ok(val * 2)
    }

    let param_env(tcx TyCtxt, def_id DefId) ParamEnv = {
        if tcx.describe_def(def_id) is .Some(Def.Existential(_)) then
        if tcx.hir.as_local_node_id(def_id) is .Some(node_id) then
        if and tcx.hir.get(node_id) is hir.map.NodeItem(item) then
        if item.node is hir.ItemExistential(exist_ty) then
        if exist_ty.impl_trait_fn is .Some(parent) then
        return param_env(tcx, parent);

        todo()
    }

    // data type define
    type Button(width Int, height Int, background String, title String);
    given Button {
        click(self ref) Void = {
            println(title)
            doSomeThingA()
            doSomeThingB()
        }
    }

    // private members
    type Image(
        private width Int,
        private height Int,
        private source String,
    );

    // abstract type define
    trait Animation {
        move(self ref, s Int) Void
        stop(self ref) Void
    }

    // Combine Template
    type ImageButton(image Image, button Button)
    given ImageButton Animation {
        move(self ref, s Int) Void = {
            let t = 5000/s
            play( s + t )
        }
        stop(self ref) Void = {}
    }

    // Create an Template object
    let btn = Button(1, 2, "Cancel")
    let img = Image(1, 2, "?.jpg")
    let ib ImageButton = ImageButton(img, btn)
    ib = (img, btn)
    // Calling property
    ib.title = "OK"
    // Calling method
    ib.show()
    // Calling protocol
    ib.move(6)

    // Use Interface
    let play_animation(a Animation ref) = {
        a.move(1000)
        a.stop()
    }
    play_animation(ref ib)

    // Annotation
    @Table("user") 
    @Property(false, name = "d", hide = true)
    type User(
        @Column("id")
        @Required
        @Key
        id String,
        @Column("nick_name")
        @Required
        nick_name String,
        @Column("time_update")
        @Required
        time_update Int,
    );
    
    // Generic Type
    type [T Any]Table(mut data T)
    given[T Any] [T]Table {
        set_data(self ref, d T) Void = {
            self.data = d
        }
    }
    [Int]Table(1)
    Table(1)

    // Generic function
    let [T Addable]add(x1 T, x2 T) T = x1 + x2
    [Int]add(1, 2)
    add(1, 2)

    let opt() = {
        let mut a [Int]Option = .Some(1)
        a = .None()
        when a in {
            .Some(v) then println(v),
            .None then println("none"),
        }

        let mut b [[Int]Option]Option = .Some(.Some(2))
        b = [[Int]Option]Option.Some([Int]Option.Some(2))
        when b in {
            .Some(.Some(v)) then println(v),
            .Some(.None) then println("some(none)"),
            .None then println("none"),
        }
    }
}

// product types
type Foo(value Int)
// sum types
type TreeNode {
    Empty(),
    Node(val Int, left TreeNode ref, right TreeNode ref),
}
// adt
type [T Any]Option {
    Some(value T),
    None(),
}
// gadt
type [T Any]Expr {
    IntExpr(value Int) [Int]Expr,
    BoolExpr(value Bool) [Bool]Expr,
    EqualExpr(left [T]Expr ref, right [T]Expr ref) [Bool]Expr,
    AddExpr(left [Int]Expr ref, right [Int]Expr ref) [Int]Expr,
}
// type alias
type Byte = UInt8
// opaque type
type C_Opaque
// type trait
trait Equatable {
    equals(self, r Self) Bool
}

trait Comparable Equatable {
    compare(self, r Self) Int
}

given Foo Equatable {
    equals(self, r Foo) Bool = self.value == r.value
}

given Foo Comparable {
    compare(self, r Foo) Int = self.value.compare(r.value)
}