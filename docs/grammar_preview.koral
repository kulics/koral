// Grammar Overview

// Import Module
using std
using std.text
using std.threading
using self.sub_mod.function_a
using super.super_mod.other_mod.function_b
using "inline_file"

// Foreign Function Interface (FFI)
foreign using "stdio.h"
foreign using "mylib.h"

foreign type FILE
foreign let fopen(path [UInt8]Pointer, mode [UInt8]Pointer) FILE
foreign let fclose(file FILE) Int32

let main() = {
    // Define
    let string String = "10"
    let single_quote_string String = 'hello, world!'
    let number Float64 = 1.2
    let integer Int = 123
    let boolean Bool = true
    let double Float64 = 1.23
    let single Float32 = (Float32)double // basic value convert

    // Mark String
    let format = "the value is \{integer}, \{number}, \{boolean}"
    let format = 'the value is \{integer}, \{number}, \{boolean}'

    // Array
    let array [3, Int]Array = [1,2,3]
    let matrix [3, [4, Int]Array]Array = [
        [1, 2, 3, 4],
        [5, 6, 7, 8],
        [9,10,11,12],
    ]

    // List
    let list [Int]List = [1, 2, 3, 4, 5]
    print( list[0] ) // 使用下标获取

    // Map, 前面为 key，后面为 value
    let map [String, Bool]Map = [("1", false), ("2", true)]
    print( map["1"] ) // 使用key获取

    // Function
    let f(a Int) Int = a

    // Function with no params no return
    let do_something_void() Void = {
        do_something_a()
        do_something_b()
    }

    // Full Function with params and return
    let do_something_with_params(x Int, y String) [Int, String]Tuple = (x, y)

    // Function inferrence return type
    let let f(x Int, y Int) = x + y

    // Function type
    let f [Int, Int, Int]Func = (x Int, y Int) Int -> x + y
    let f [Int, Int, Int]Func = (x, y) -> x + y
    let g [Void]Func = () -> {}

    // Currying
    let add = (x Int) -> (y Int) -> x + y
    let add [Int, [Int, Int]Func]Func = (x) -> (y) -> x + y
    let v = add(1)(2)

    // Lambda Function
    List.of(1, 2, 3, 4).filter((x) -> x % 2 == 0).map((x) -> x * x).sum()

    // Func params
    let f(i [Int, Int]Func) = i(1)
    f((x Int) Int -> x)
    f((x) -> x)

    do_something_void();
    // use _ discard return value
    _ = do_something_with_params(3, "test")

    // logic operator
    x and y;
    x or y;
    not x;
    // compare operator
    x == y; // eq
    x <> y; // ne
    x > y;  // gt
    x < y;  // lt
    x >= y; // ge
    x <= y; // le
    // calculate operator
    x + y;  // add
    x - y;  // sub
    x * y;  // muv
    x / y;  // div
    x % y;  // mod
    // bitwise operator
    x & y;
    x | y;
    x ^ y;
    ~x;
    x << y;
    x >> y;
    // compound assignment operators
    x += y;
    x -= y;
    x *= y;
    x /= y;
    x %= y;
    x &= y;
    x |= y;
    x ^= y;
    x <<= y;
    x >>= y;
    // range operator
    x = 1..5;    // 1 <= x <= 5
    x = 1..<5;   // 1 <= x < 5
    x = 1<..5;   // 1 < x <= 5
    x = 1<..<5;  // 1 < x < 5
    x = 1...;    // 1 <= x <= max
    x = 1<...;   // 1 < x <= max
    x = ...5;    // min <= x <= 5
    x = ...<5;   // min <= x < 5
    x = ....;    // min <= x <= max

    // if-then, single branch structure
    if a < b then {
        todo()
    }

    // with-init
    let a = 1 then if a < 0 then {
        todo()
    }

    // if-then-else, double branch structure
    let v = if true then 0 else 0;
    if true then {
        todo()
    } else {
        todo()
    }

    if a then {
        todo()
    } else if b then {
        todo()
    } else {
        todo()
    }

    let op [Int]Option = .Some(1);
    // if with pattern matching
    if op is .Some(v) then {
        print_line(v)
    }

    // while-then, single branch structure
    while a < b then {
        todo()
    }

    // with-init
    let mut i = 0 then while i < 10 then {
        print_line(i)
        i += 1
    }

    // while-then-else, double branch structure, break can with value
    let v = while true then break 1 else 2;
    while true then {
        todo()
    } else {
        todo()
    }

    let iter [Int]Iterator = List.of(1,2,3).iterator()
    // while with pattern matching
    while iter.next() is .Some(v) then {
        print_line(v)
    }

    // for
    for item = list then {
        todo()
    }

    // with-init
    for item = [1,2,3,4] then {
        todo()
    }

    // Loop, use identify to take out single item
    for item = list then print_line(item)
    
    // take index and value, both worked at Dictionary
    for (index, value) = list.enumerate() then {
        print_line((index, value))
    }
    
    for i = 0..10 then {
        print_line(i)
    }

    for i = 0..10 then if i % 2 == 0 then print(i)

    // switch
    when x is {
        1 then "a",
        2 then "b",
        3 then "c",
        _ then "d",
    }

    let num = 42;
    when num is {
        0 or 1 or 2 or 3 or 4 or 5 or 6 or 7 or 8 or 9 then
            print("single digit"),
        10 then
            print("double digits"),
        n and >= 11 and <= 99 then 
            print("double digits"),
        n and >= 100 and <= 999 then 
            print("triple digits"),
        _ then
            print("four or more digits"),
    }

    if a is 1 or 2 then todo()
    if a is n and < 2 then todo()
    if a is not 2 then todo()

    // pattern matching
    when val is {
        1 then todo(), // int literal
        -5 then todo(), // negative int literal
        1.0 then todo(), // float literal
        'a' then todo(), // string literal
        "abc" then todo(), // string literal
        true then todo(), // bool literal
        _ then todo(), // wildcard
        {y} then todo(), // expression, y must be a constant
        x then todo(), // binding
        mut x then todo(), // mutable binding
        x Int then todo(), // type casting
        Int then todo(), // type casting
        Foo(x, y) then todo(), // type deconstruct
        (x, y) then todo(), // type deconstruct
        .Some(x) then todo(), // enum deconstruct
        > 5 then todo(), // comparison pattern (greater than)
        < 10 then todo(), // comparison pattern (less than)
        >= 0 then todo(), // comparison pattern (greater or equal)
        <= 100 then todo(), // comparison pattern (less or equal)
        > -5 then todo(), // comparison pattern with negative literal
        1 or 2 then todo(), // or pattern combinator
        x and > 0 then todo(), // and pattern combinator with binding
        not 0 then todo(), // not pattern combinator
    }

    if foo() is A(x) then
    if bar(x) is B(y) then {
        do_stuff_with(x, y)
    }

    let param_env(tcx TyCtxt, def_id DefId) ParamEnv = {
        if tcx.describe_def(def_id) is .Some(Def.Existential(_)) then
        if tcx.hir.as_local_node_id(def_id) is .Some(node_id) then
        if and tcx.hir.get(node_id) is hir.map.NodeItem(item) then
        if item.node is hir.ItemExistential(exist_ty) then
        if exist_ty.impl_trait_fn is .Some(parent) then
        return param_env(tcx, parent);

        todo()
    }

    // data type define
    type Button(width Int, height Int, background String, title String);
    given Button {
        click(self ref) Void = {
            print_line(title)
            doSomeThingA()
            doSomeThingB()
        }
    }

    // private members
    type Image(
        private width Int,
        private height Int,
        private source String,
    );

    // abstract type define
    trait Animation {
        move(self ref, s Int) Void
        stop(self ref) Void
    }

    // Combine Template
    type ImageButton(image Image, button Button)
    given ImageButton {
        move(self ref, s Int) Void = {
            let t = 5000/s
            play( s + t )
        }
        stop(self ref) Void = {}
    }

    // Create an Template object
    let btn = Button(1, 2, "Cancel")
    let img = Image(1, 2, "?.jpg")
    let ib ImageButton = Image(img, btn)
    ib = (img, btn)
    // Calling property
    ib.title = "OK"
    // Calling method
    ib.show()
    // Calling protocol
    ib.move(6)

    // Use Interface
    let play_animation(a Animation ref) = {
        a.move(1000)
        a.stop()
    }
    play_animation(ib)

    // Annotation
    @Table("user") 
    @Property(false, name = "d", hide = true)
    type User(
        @Column("id")
        @Required
        @Key
        id String,
        @Column("nick_name")
        @Required
        nick_name String,
        @Column("time_update")
        @Required
        time_update Int,
    );
    
    // Generic Type
    type [T Any]Table(mut data T)
    given[T Any] [T]Table {
        set_data(self ref, d T) Void = {
            self.data = d
        }
    }
    [Int]Table(1)
    Table(1)

    // Generic function
    let [T Addable]add(x1 T, x2 T) T = x1 + x2
    [Int]add(1, 2)
    add(1, 2)

    let opt() = {
        let mut a [Int]Option = .Some(1)
        a = .None()
        when a is {
            .Some(v) then print_line(v),
            .None then print_line("none"),
        }

        let mut b [[Int]Option]Option = .Some(.Some(2))
        b = [[Int]Option]Option.Some([Int]Option.Some(2))
        when b is {
            .Some(.Some(v)) then print_line(v),
            .Some(.None) then print_line("some(none)"),
            .None then print_line("none"),
        }
    }
    
    type [T Any]MyList(mut arr [T]List)
    // operator override
    given[T Any] [T]MyList {
        // self[i]
        __at(self, index Int) T = self.arr[index]

        // self[i] = e
        __update_at(self ref, index Int, value T) = self.arr[index] = value
    }
}

// product types
type Foo(value Int)
// sum types
type TreeNode {
    Empty(),
    Node(val Int, left TreeNode ref, right TreeNode ref),
}
// adt
type [T Any]Option {
    Some(value T),
    None(),
}
// gadt
type [T Any]Expr {
    IntExpr(value Int) [Int]Expr,
    BoolExpr(value Bool) [Bool]Expr,
    EqualExpr(left [T]Expr ref, right [T]Expr ref) [Bool]Expr,
    AddExpr(left [Int]Expr ref, right [Int]Expr ref) [Int]Expr,
}
// type alias
type Byte = UInt8
// opaque type
type C_Opaque
// type trait
trait Equatable {
    equals(self, r Self) Bool
}

trait Comparable Equatable {
    compare(self, r Self) Int
}

given Int {
    default() Self = 0
}

given String {
    default() Self = ""
}

given[T Any] [T]List {
    default() Self = []
}

trait ToString {
    to_string(self) String
}

given Foo { // 隐式实现
    to_string(self) String = todo()
}

given[T ToString] [T]List {
    to_string(self) String = todo()
}

given[T ToString] [T]Option {
    to_string(self) String = 
        if self is .Some(v) 
        then "Some(\{v})" 
        else "None()"
}

given Foo {
    to_string(self) String = "foo"
}

trait InputStream {
    read(self, to Buffer) Int
}

trait OutputStream {
    write(self, from Buffer) Int
    flush(self) Void
}

type [T Any]Node(mut value T, mut next [[T]Node ref]Option, mut prev [[T]Node weakref]Option)

type [T Any]LinkedList(mut head [[T]Node]Option, mut tail [[T]Node]Option, mut size Int)

type FileStorage(fd UInt)

given FileStorage {
    __drop(self ref) Void = {
        fclose(self.fd)
    }
}

type File(data FileStorage ref)

given File {
    open(path String) File = File(ref FileStorage(fopen(path, todo())))

    read(self, buf Buffer) Int = fread(self.data.fd, buf, 0, buf.size())
    write(self, buf Buffer) Int = fwrite(self.data.fd, buf, 0, buf.size())
}

/*
1. 默认声明的类型都是值类型，等价于 c struct，所有类型都实现了 copy，但不是所有类型都会深度拷贝 copy。例如 ref 类型和 Pointer 类型就不会深度拷贝。
2-1. 任意类型只要显式实现了 __drop 函数，其实例生命周期结束时就由编译器插入调用 __drop 来销毁。
2-2. 任意类型如果没有显式实现 __drop 函数，那么编译器会给这个类型自动实现 __drop（递归成员实现）。
2-3. __drop 函数不能手动调用。编译器会对手动调用 __drop 的代码进行报错。
3-1. ref 是内置的智能指针类型，ref 可以从变量获取或者通过 new 函数主动分配。
3-2. 只读和读写变量都能获取引用（ref）。当获取的 ref 会发生逃逸时，编译器会自动将变量分配在堆上。
3-3. ref 内部使用了自动引用计数，当 ref 发生 copy 时，引用计数会加1；当 ref 发生 drop 时，引用计数会减1，当计数为 0 时，会调用 ref 源的 drop 释放。
3-4. ref 是共享所有权，所有 ref 都会指向原来产生的变量或者分配的对象。
3-5. T ref 的成员/方法访问自动解引用；若需要获得值的副本，需使用 `deref` 语法来 copy T 的一个新副本。
3-6. 当 ref 存在环引用时，需要通过 weakref 解开环引用。weakref 只操作弱计数，不影响对象存活，弱计数归零释放控制块。
4. 如果编译器判断某个变量的所有权被转移而不需要 copy 或 drop，则不会调用 copy 和 drop，只会 move 值。

lifetime 规则：
作用域包含函数体，if 的 then、else 分支，while 的 then 分支。
1. 变量（本地变量/函数参数/由函数调用和类型构造产生的隐藏变量）在作用域结束前必须被消费。
2. 消费包含 own 语义的绑定、解构、赋值、传参、返回、捕获。
3. 对于实现了任意变量，如果作用域内存在多于 1 次的消费，那么最后一次之前的消费会由编译器插入 copy 调用来产生新实例。
4. 从变量中获取 ref 并且没有逃逸的话，该变量不会被消耗。如果发生了逃逸，那变量的所有权会转移到 ref 上。 
5. and 和 or 短路后只处理左侧表达式的临时对象生命周期，右侧未求值则无临时对象，已求值则按正常规则处理。
*/
