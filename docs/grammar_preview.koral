// Grammar Overview

// Export Name Space
export demo;

// Import Name Space
import {
    System;
    System.Text;
    System.Threading.Tasks;
    IO.File.*; // import all
}

let main() = {
    // Define
    let string String = "10";
    let single_quote_string String = 'hello, world!';
    let number Float64 = 1.2;
    let integer Int = 123;
    let boolean Bool = true;
    let double Float64 = 1.23;
    let single Float32 = (Float32)double; // basic value convert

    // Const
    let PI = 3.141592653;

    // Mark String
    let format = "the value is \{integer}, \{number}, \{boolean}";
    let format = 'the value is \{integer}, \{number}, \{boolean}';

    // Array
    let array [Int]Array = [1, 2, 3];

    // List
    let list [Int]List = [1, 2, 3, 4, 5];
    print( list[0] ); // 使用下标获取

    // Map, 前面为 key，后面为 value
    let map [String, Bool]Map = ["1": false, "2": true];
    print( map["1"] ); // 使用key获取

    // Function
    let f(a Int) Int = a;

    // Function with no params no return
    let do_something_void() Void = {
        do_something_a();
        do_something_b();
    }

    // Full Function with params and return
    let do_something_with_params(x Int, y String) [Int, String]Tuple = (x, y);

    // Function type
    let f [Int, Int, Int]Func = (x Int, y Int) Int -> x + y;
    let f [Int, Int, Int]Func = (x, y) -> x + y;
    let f(x Int, y Int) Int = x + y;
    let f(x Int, y Int) = x + y;
    let g() Void = {}
    let g [Void]Func = () -> {}

    // Currying
    let add = (x Int) -> (y Int) -> x + y;
    let add [Int, [Int, Int]Func]Func = (x) -> (y) -> x + y;
    let add(x Int)(y Int) = x + y;
    let v = add(1)(2);

    // Lambda Function
    List.of(1, 2, 3, 4).filter((x) -> x % 2 == 0).map((x) -> x * x).sum();

    // Func params
    let f(i [Int, Int]Func) = i(1);
    f((x Int) Int -> x);
    f((x) -> x);

    do_something_void();
    // use _ discard return value
    _ = do_something_with_params(3, "test");

    // logic operator
    x and y;
    x or y;
    not x;
    // compare operator
    x == y;
    x <> y;
    x > y;
    x < y;
    x >= y;
    x <= y;
    // calculate operator
    x + y;
    x - y;
    x * y;
    x / y;
    x % y;
    x ** y;
    // bit operator
    x & y;
    x | y;
    x ^ y;
    ~x;
    x << y;
    x >> y;
    // range operator
    1..5;    // 1 <= x <= 5
    1..<5;   // 1 <= x < 5
    1<..5;   // 1 < x <= 5
    1<..<5;  // 1 < x < 5

    // if-then, single branch structure
    if a < b then {
        ...
    }

    // with-init
    if let a = 1; a < 0 then {
        ...
    }

    // if-then-else, double branch structure
    let v = if true then 0 else 0;
    if true then {
        ...
    } else {
        ...
    }

    if a then {
        ...
    } else if b then {
        ...
    } else {
        ...
    }

    let op [Int]Option = Some(1);
    // if with pattern matching
    if op is Some(v) then {
        printLine(v)
    }

    // while-then, single branch structure
    while a < b then {
        ...
    }

    // with-init
    while let mut i = 0; i < 10 then {
        printLine(i);
        i += 1;
    }

    // while-then-else, double branch structure, break can with value
    let v = while true then break 1 else 2;
    while true then {
        ...
    } else {
        ...
    }

    let iter [Int]Iterator = List.of(1,2,3).iterator();
    // while with pattern matching
    while iter.next() is Some(v) then {
        printLine(v)
    }

    // when
    when x is {
        1 -> "a";
        2 -> "b";
        3 -> "c";
        _ -> "d";
    }

    // with-init
    when let x = f(); x is {
        1 -> "a";
        2 -> "b";
        3 -> "c";
        _ -> "d";
    }

    // single
    when x as item then item;

    // with-init
    when let x = f(); x as item then item;

    // for
    for array is {
        1 -> "a";
        2 -> "b";
        3 -> "c";
        _ -> "d";
    }

    // with-init
    for let array = f(); array is {
        1 -> "a";
        2 -> "b";
        3 -> "c";
        _ -> "d";
    }

    // single
    for array as item then {
        ...
    }

    // with-init
    for let list = [1,2,3,4]; list as item then {
        ...
    }

    // Loop, use identify to take out single item
    for array as item then printLine(item);
    
    // take index and value, both worked at Dictionary
    for array.enumerate() as (index, value) then {
        printLine((index, value))
    }
    
    for 0..10 as i then {
        printLine(i)
    }

    for 0..10 as i then if i % 2 == 0 then print(i);

    let nb = 42;
    when nb is {
        0..7 or 8 or 9 ->
            print("single digit");
        10 ->
            print("double digits");
        11..99 -> 
            print("double digits");
        100..999 -> 
            print("triple digits");
        _ ->
            print("four or more digits");
    }

    // pattern matching
    when val is {
        1 -> ...; // int literal
        1.0 -> ...; // float literal
        'a' -> ...; // string literal
        "abc" -> ...; // string literal
        true -> ...; // bool literal
        _ -> ...; // wildcard
        {y} -> ...; // expression, y must be a constant
        x -> ...; // binding
        mut x -> ...; // mutable binding
        x Int -> ...; // type casting
        Int -> ...; // type casting
        Int as x -> ...; // type casting
        Foo(x, y) -> ...; // type deconstruct
        (x, y) -> ...; // tuple
        .Some(x) -> ...; // enum
    }

    if foo() is A(x) and bar(x) is B(y) then {
        do_stuff_with(x, y)
    } else {
        some_long_expression
    }

    let param_env(tcx TyCtxt, def_id DefId) ParamEnv = {
        if tcx.describe_def(def_id) is Some(Def.Existential(_))
            and tcx.hir.as_local_node_id(def_id) is Some(node_id)
            and tcx.hir.get(node_id) is hir.map.NodeItem(item)
            and item.node is hir.ItemExistential(exist_ty)
            and exist_ty.impl_trait_fn is Some(parent)
        then return param_env(tcx, parent);

        ...
    }

    // data type define
    type Button(width Int, height Int, background String, title String) {
        click(self ref) Void = {
            printLine(title);
            doSomeThingA();
            doSomeThingB();
        }
    }

    // private members
    type Image(
        private width Int,
        private height Int,
        private source String,
    );

    // abstract type define
    trait Animation {
        move(self ref, s Int) Void;
        stop(self ref) Void;
    }

    // Combine Template
    type ImageButton(image Image, button Button);
    given ImageButton {
        move(self ref, s Int) Void = {
            let t = 5000/s;
            play( s + t );
        }
        stop(self ref) Void = {}
    }

    // Create an Template object
    let btn = Button(1, 2, "Cancel");
    let img = Image(1, 2, "?.jpg");
    let ib ImageButton = Image(img, btn);
    ib = (img, btn);
    // Calling property
    ib.title = "OK";
    // Calling method
    ib.show();
    // Calling protocol
    ib.move(6);

    // Use Interface
    let play_animation(a Animation type) = {
        a.move(1000);
        a.stop();
    }
    play_animation(ib);

    // Annotation
    @Table("user") 
    @Property(false, name = "d", hide = true)
    type User(
        @Column("id")
        @Required
        @Key
        id String,
        @Column("nick_name")
        @Required
        nick_name String,
        @Column("time_update")
        @Required
        time_update Int,
    );
    
    // Generic Type
    type [T Any]Table(mut data T);
    given[T Any] [T]Table {
        set_data(self ref, d T) Void = {
            self.data = d;
        }
    }
    [Int]Table(1);
    Table(1);

    // Generic function
    let [T Addable]add(x1 T, x2 T) T = x1 + x2;
    [Int]add(1, 2);
    add(1, 2);

    let opt() = {
        let mut a [Int]Option = Some(1);
        a = None();
        when a is {
            Some(v) -> printLine(v);
            None -> printLine("none");
        }

        let mut b [[Int]Option]Option = Some(Some(2));
        b = [[Int]Option]Option.Some([Int]Option.Some(2));
        when b is {
            Some(Some(v)) -> printLine(v);
            Some(None) -> printLine("some(none)");
            None -> printLine("none");
        }
    }
    
    type [T Any]MyList(mut arr [T]Array);
    // operator override
    given[T Any] [T]MyList {
        // self[i]
        get(self ref, index Int) T = self.arr[index];

        // self[i] = e
        set(self ref, index Int, element T) Void = self.arr[index] = element;
    }
}

// product types
type Foo(value Int);
// sum types
type TreeNode {
    Empty();
    Node(val Int, left [TreeNode]Box, right [TreeNode]Box);
}
// adt
type [T Any]Option {
    Some(value T);
    None();
}
// gadt
type [T Any]Expr {
    IntExpr(value Int) [Int]Expr;
    BoolExpr(value Bool) [Bool]Expr;
    EqualExpr(left [[T]Expr]Box, right [[T]Expr]Box) [Bool]Expr;
    AddExpr(left [[Int]Expr]Box, right [[Int]Expr]Box) [Int]Expr;
}
// type alias
type Byte = UInt8;
// opaque type
type C_Opaque;
// type trait
trait Equatable {
    equals(self ref, r Self ref) Bool;
}

trait Comparable where Self is Equatable {
    compare(self ref, r Self ref) Int;
}

trait Any {}

given[T Any, R Any] [T, R]Func {
    toAny(self) Any type = self;
}

given Int {
    default() Self = 0;
}

given String {
    default() Self = "";
}

given[T Any] [T]Array {
    default() Self = [];
}

trait ToString {
    toString(self ref) String;
}

given Foo { // 隐式实现
    toString(self ref) String = ...;
}

given Bar ToString { // 可选显式实现
    toString(self ref) String = ...;
}

given[T ToString] [T]Array {
    toString(self ref) String = ...;
}

given[T ToString] [T]Option {
    toString(self ref) String = 
        if self is Some(v) 
        then "Some(\{v})" 
        else "None()";
}

given Foo {
    toString(self ref) String = "foo";
}

trait InputStream {
    read(self ref, to [Byte]Array ref) Int;
}

trait OutputStream {
    write(self ref, from [Byte]Array ref) Int;
    flush(self ref) Void;
}

trait [T Any]Sequence {
    iterator(self) [T]Iterator type;
}

trait [T Any]Iterator {
    next(self ref) [T]Option;
}

given[T Any] [T]Iterator {
    [R Any]reduce(self, mut r R, f [R, T, R]Func) R = {
        for self as v then r = f(r, v);
        r
    }
    filter(self, f [T, Bool]Func) [T]FilterIterator = FilterIterator(self, f);
    [R Any]map(self, f [T, R]Func) [T, R]MapIterator = MapIterator(self, f);
}

type [T Any]FilterIterator(iter [T]Iterator, filter [T, Bool]Func) {
    next(self ref) [T]Option = 
        while self.iter.next() is Some(v) then {
            if self.filter(v) then return Some(v);
        } else None();
}

type [T Any, R Any]MapIterator(iter [T]Iterator, mapper [T, R]Func) {
    next(self ref) [R]Option = 
        if self.iter.next() is Some(v) then Some(mapper(v)) else None();
}

type [T Any]UnsafePointer(addr UInt) {
    // primitive implement
    alloc(count Int) Self = {...}
    // primitive implement
    as_ref(self ref) T ref = {...}
    // primitive implement
    store(self ref, v T) Void = {...}
    // primitive implement
    load(self ref) T = {...}
    // primitive implement
    offset(self ref, n Int) Self = {...}
    // primitive implement
    free(self ref) Void = {...}
}

let [T Any]new(v T) [T]Box = {...}

type [T Any]BoxImpl(mut strong Int, mut weak Int, mut data T);

type [T Any]Box(inner [[T]BoxImpl]UnsafePointer) {
    copy(self ref) Self = {...}
    drop(self) Void = {...}
    as_ref(self ref) T ref = {...}
}

type [T Copy and Drop]Array(mut source [T]UnsafaPointer, mut len Int, mut cap Int) {
    new() Self = Array([T]UnsafaPointer.alloc(0), 0);

    copy(self ref) Self = {...}

    drop(self) = {
        ... // ref_count--
        if ref_count_zero(self.source) then {
            for 0..self.len as i then {
                self.source.offset(i).as_ref().drop();
            }
            self.source.free()
        }
    }

    count(self ref) Int = self.len;

    get(self ref, index Int) T ref = self.source.offset(i).as_ref();
    
    set(self ref, index Int, value T) Void = {
        make_sure_unique(self);
        self.source.offset(i).as_ref() = value;
    }

    insert(self ref, index Int, value T) Void = {
        make_sure_unique(self);
        ...
    }

    remove(self ref, index Int) Void = {
        make_sure_unique(self);
        ...
    }

    iterator(self) [T]ArrayIterator =
        [T]ArrayIterator(self, 0);
}

type [T Copy and Drop]ArrayIterator(source [T]Array, mut index Int) {
    next(self ref) [T]Option = 
        if self.index < self.source.size() then {
            self.index += 1;
            Some(self.source[self.index])
        } else {
            None()
        }
}

type String(data [Rune]Array) {
    of(data [Rune]Array) Self = String(self.data);

    toString(self ref) Self = String(self.data);

    iterator(self) StringIterator = StringIterator(self, -1);
}

type StringIterator(_source String, mut index Int);

given StringIterator {
    next(self ref) [Rune]Option = 
        if self.index < self._source.data.size() then {
            self.index += 1;
            Some(self._source.data[self.index])
        } else {
            None()
        }
}

type [T Copy and Drop]Node(mut value T, mut next [[[T]Node]Box]Option, mut prev [[[T]Node]WeakBox]Option);

type [T Copy and Drop]LinkedList(mut head [[T]Node]Option, mut tail [[T]Node]Option, mut size Int);

type File(fd UInt) is not Copy and not Drop {
    open(path String) File = File(fopen(path, ...));

    read(self ref, buf [Byte]Array ref) Int = fread(self.fd, buf, 0, buf.size());
    write(self ref, buf [Byte]Array ref) Int = fwrite(self.fd, buf, 0, buf.size());

    close(self) Void = fclose(self.fd);
}

/*
1. 默认声明的类型都是值类型，等价于 c struct，但不是所有类型都能直接 copy。
2-1. 任意类型只要实现了 copy 函数，编译器就会自动根据需要调用 copy 来产生新实例。
2-2. 任意类型可以给自己声明 `is not Copy` 来标记不实现 Copy，编译器不会自动生成 copy 实现，如果类型内存在 copy 实现则会编译报错。
2-3. 任意类型内包含的成员变量如果全部都是 copy 类型，且没有标记为 `is not Copy`，那么编译器会给这个类型自动实现 copy（递归成员实现）。
3-1. 任意类型只要实现了 drop 函数，其实例生命周期结束时就由编译器插入调用 drop 来销毁。
3-2. 任意类型可以给自己声明 `is not Drop` 来标记不实现 Drop，编译器不会自动生成 drop 实现，如果类型内存在 drop 实现则会编译报错。
3-3. 任意类型内包含的成员变量如果全部都是 drop 类型，且没有标记为 `is not Drop`，那么编译器会给这个类型自动实现 drop（递归成员实现）。
3-4. 没有实现 Drop 的类型，需要手动消费所有权，不会自动销毁（等价于 linear type）。
4-1. 变量可以通过引用来传递，使用引用不会触发 copy 和 drop。
4-2. 只读和读写变量都能获取引用。
4-3. 引用具有独占性，编译器在作用域内做独占性检查，防止同一个来源同时存在多个引用重叠。
4-4. 引用的生命周期不能超过被引用对象的作用域，防止悬垂引用。
4-5. 引用不可逃逸（不能存入堆/闭包/跨线程）。
4-5. 引用的变量不会自动插入 copy，需要手动调用。
5. 如果编译器判断某个非引用变量的所有权被转移，则不会调用 copy 和 drop，只会 move 值。

lifetime 规则：
作用域包含函数体，if 的 then、else 分支，while 的 then 分支。
1. 变量（本地变量/函数参数/由函数调用和类型构造产生的隐藏变量）在作用域结束前必须被消费。
2. 消费包含 own 语义的绑定、解构、赋值、传参、返回、捕获，ref 语义的不会产生消费。
3. 对于实现了 Drop 的变量，如果没有显式的消费，则会在作用域结束前由编译器插入 drop 调用来消费。
4. 对于实现了 Copy 的变量，如果作用域内存在多于 1 次的消费，那么最后一次之前的消费会由编译器插入 copy 调用来产生新实例。
5. and 和 or 短路后只处理左侧表达式的临时对象生命周期，右侧未求值则无临时对象，已求值则按正常规则处理。
*/
