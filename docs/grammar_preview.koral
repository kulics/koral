// Grammar Overview

// Export Name Space
export demo;

// Import Name Space
import {
    System;
    System.Text;
    System.Threading.Tasks;
}

let main() = {
    // Define
    let string String = "10";
    let single_quote_string String = 'hello, world!';
    let number Float64 = 1.2;
    let integer Int = 123;
    let boolean Bool = true;
    let double Float64 = 1.23;
    let single Float32 = (Float32)double; // basic value convert

    // Mark String
    let format = "the value is \{integer}, \{number}, \{boolean}";
    let format = 'the value is \{integer}, \{number}, \{boolean}';

    // Array
    let array [3, Int]Array = [1,2,3];
    let matrix [3, [4, Int]Array]Array = [
        [1, 2, 3, 4],
        [5, 6, 7, 8],
        [9,10,11,12],
    ];

    // List
    let list [Int]List = [1, 2, 3, 4, 5];
    print( list[0] ); // 使用下标获取

    // Map, 前面为 key，后面为 value
    let map [String, Bool]Map = [("1", false), ("2", true)];
    print( map["1"] ); // 使用key获取

    // Function
    let f(a Int) Int = a;

    // Function with no params no return
    let do_something_void() Void = {
        do_something_a();
        do_something_b();
    }

    // Full Function with params and return
    let do_something_with_params(x Int, y String) [Int, String]Tuple = (x, y);

    // Function inferrence return type
    let let f(x Int, y Int) = x + y;

    // Function type
    let f [Int, Int, Int]Func = (x Int, y Int) Int -> x + y;
    let f [Int, Int, Int]Func = (x, y) -> x + y;
    let g [Void]Func = () -> {}

    // Currying
    let add = (x Int) -> (y Int) -> x + y;
    let add [Int, [Int, Int]Func]Func = (x) -> (y) -> x + y;
    let v = add(1)(2);

    // Lambda Function
    List.of(1, 2, 3, 4).filter((x) -> x % 2 == 0).map((x) -> x * x).sum();

    // Func params
    let f(i [Int, Int]Func) = i(1);
    f((x Int) Int -> x);
    f((x) -> x);

    do_something_void();
    // use _ discard return value
    _ = do_something_with_params(3, "test");

    // logic operator
    x and y;
    x or y;
    not x;
    // compare operator
    x == y; // eq
    x <> y; // ne
    x > y;  // gt
    x < y;  // lt
    x >= y; // ge
    x <= y; // le
    // calculate operator
    x + y;  // add
    x - y;  // sub
    x * y;  // muv
    x / y;  // div
    x % y;  // mod
    x ^ y;  // pow
    // bitwise operator
    x bitand y;
    x bitor y;
    x bitxor y;
    bitnot x;
    x bitshl y;
    x bitshr y;
    // compound assignment operators
    x += y;
    x -= y;
    x *= y;
    x /= y;
    x %= y;
    x ^= y;
    x bitand= y;
    x bitor= y;
    x bitxor= y;
    x bitshl= y;
    x bitshr= y;
    // range operator
    x = 1..5;    // 1 <= x <= 5
    x = 1..<5;   // 1 <= x < 5
    x = 1<..5;   // 1 < x <= 5
    x = 1<..<5;  // 1 < x < 5
    x = 1...;    // 1 <= x <= max
    x = 1<...;   // 1 < x <= max
    x = ...5;    // min <= x <= 5
    x = ...<5;   // min <= x < 5
    x = ....;    // min <= x <= max

    // if-then, single branch structure
    if a < b then {
        todo()
    }

    // with-init
    let a = 1 then if a < 0 then {
        todo()
    }

    // if-then-else, double branch structure
    let v = if true then 0 else 0;
    if true then {
        todo()
    } else {
        todo()
    }

    if a then {
        todo()
    } else if b then {
        todo()
    } else {
        todo()
    }

    let op [Int]Option = .Some(1);
    // if with pattern matching
    if op is .Some(v) then {
        printLine(v)
    }

    // while-then, single branch structure
    while a < b then {
        todo()
    }

    // with-init
    let mut i = 0 then while i < 10 then {
        printLine(i);
        i += 1;
    }

    // while-then-else, double branch structure, break can with value
    let v = while true then break 1 else 2;
    while true then {
        todo()
    } else {
        todo()
    }

    let iter [Int]Iterator = List.of(1,2,3).iterator();
    // while with pattern matching
    while iter.next() is .Some(v) then {
        printLine(v)
    }

    // for
    for item = list then {
        todo()
    }

    // with-init
    for item = [1,2,3,4] then {
        todo()
    }

    // Loop, use identify to take out single item
    for item = list then printLine(item);
    
    // take index and value, both worked at Dictionary
    for (index, value) = list.enumerate() then {
        printLine((index, value))
    }
    
    for i = 0..10 then {
        printLine(i)
    }

    for i = 0..10 then if i % 2 == 0 then print(i);

    // switch
    x match {
        1 -> "a";
        2 -> "b";
        3 -> "c";
        _ -> "d";
    }

    let num = 42;
    num match {
        0..7 or 8 or 9 ->
            print("single digit");
        10 ->
            print("double digits");
        11..99 -> 
            print("double digits");
        100..999 -> 
            print("triple digits");
        _ ->
            print("four or more digits");
    }

    // pattern matching
    val match {
        1 -> todo(); // int literal
        1.0 -> todo(); // float literal
        'a' -> todo(); // string literal
        "abc" -> todo(); // string literal
        true -> todo(); // bool literal
        _ -> todo(); // wildcard
        {y} -> todo(); // expression, y must be a constant
        x -> todo(); // binding
        mut x -> todo(); // mutable binding
        x Int -> todo(); // type casting
        Int -> todo(); // type casting
        Foo(x, y) -> todo(); // type deconstruct
        (x, y) -> todo(); // type deconstruct
        .Some(x) -> todo(); // enum
    }

    if foo() is A(x) and bar(x) is B(y) then {
        do_stuff_with(x, y)
    } else {
        some_long_expression
    }

    let param_env(tcx TyCtxt, def_id DefId) ParamEnv = {
        if tcx.describe_def(def_id) is .Some(Def.Existential(_))
            and tcx.hir.as_local_node_id(def_id) is .Some(node_id)
            and tcx.hir.get(node_id) is hir.map.NodeItem(item)
            and item.node is hir.ItemExistential(exist_ty)
            and exist_ty.impl_trait_fn is .Some(parent)
        then return param_env(tcx, parent);

        todo()
    }

    // data type define
    type Button(width Int, height Int, background String, title String);
    given Button {
        click(self ref) Void = {
            printLine(title);
            doSomeThingA();
            doSomeThingB();
        }
    }

    // private members
    type Image(
        private width Int,
        private height Int,
        private source String,
    );

    // abstract type define
    trait Animation {
        move(self ref, s Int) Void;
        stop(self ref) Void;
    }

    // Combine Template
    type ImageButton(image Image, button Button);
    given ImageButton {
        move(self ref, s Int) Void = {
            let t = 5000/s;
            play( s + t );
        }
        stop(self ref) Void = {}
    }

    // Create an Template object
    let btn = Button(1, 2, "Cancel");
    let img = Image(1, 2, "?.jpg");
    let ib ImageButton = Image(img, btn);
    ib = (img, btn);
    // Calling property
    ib.title = "OK";
    // Calling method
    ib.show();
    // Calling protocol
    ib.move(6);

    // Use Interface
    let play_animation(a Animation ref) = {
        a.move(1000);
        a.stop();
    }
    play_animation(ib);

    // Annotation
    @Table("user") 
    @Property(false, name = "d", hide = true)
    type User(
        @Column("id")
        @Required
        @Key
        id String,
        @Column("nick_name")
        @Required
        nick_name String,
        @Column("time_update")
        @Required
        time_update Int,
    );
    
    // Generic Type
    type [T Any]Table(mut data T);
    given[T Any] [T]Table {
        set_data(self ref, d T) Void = {
            self.data = d;
        }
    }
    [Int]Table(1);
    Table(1);

    // Generic function
    let [T Addable]add(x1 T, x2 T) T = x1 + x2;
    [Int]add(1, 2);
    add(1, 2);

    let opt() = {
        let mut a [Int]Option = .Some(1);
        a = .None();
        a match {
            .Some(v) -> printLine(v);
            .None -> printLine("none");
        }

        let mut b [[Int]Option]Option = .Some(.Some(2));
        b = [[Int]Option]Option.Some([Int]Option.Some(2));
        b match {
            .Some(.Some(v)) -> printLine(v);
            .Some(.None) -> printLine("some(none)");
            .None -> printLine("none");
        }
    }
    
    type [T Any]MyList(mut arr [T]List);
    // operator override
    given[T Any] [T]MyList {
        // self[i]
        get(self ref, index Int) T = self.arr[index];

        // self[i] = e
        set(self ref, index Int, element T) Void = self.arr[index] = element;
    }
}

// product types
type Foo(value Int);
// sum types
type TreeNode {
    Empty();
    Node(val Int, left TreeNode ref, right TreeNode ref);
}
// adt
type [T Any]Option {
    Some(value T);
    None();
}
// gadt
type [T Any]Expr {
    IntExpr(value Int) [Int]Expr;
    BoolExpr(value Bool) [Bool]Expr;
    EqualExpr(left [T]Expr ref, right [T]Expr ref) [Bool]Expr;
    AddExpr(left [Int]Expr ref, right [Int]Expr ref) [Int]Expr;
}
// type alias
type Byte = UInt8;
// opaque type
type C_Opaque;
// type trait
trait Equatable {
    equals(self ref, r Self ref) Bool;
}

trait Comparable Equatable {
    compare(self ref, r Self ref) Int;
}

trait Any {}

given[T Any, R Any] [T, R]Func {
    toAny(self) Any ref = self;
}

given Int {
    default() Self = 0;
}

given String {
    default() Self = "";
}

given[T Any] [T]List {
    default() Self = [];
}

trait ToString {
    toString(self ref) String;
}

given Foo { // 隐式实现
    toString(self ref) String = todo();
}

given Bar ToString { // 可选显式实现
    toString(self ref) String = todo();
}

given[T ToString] [T]List {
    toString(self ref) String = todo();
}

given[T ToString] [T]Option {
    toString(self ref) String = 
        if self is .Some(v) 
        then "Some(\{v})" 
        else "None()";
}

given Foo {
    toString(self ref) String = "foo";
}

trait InputStream {
    read(self ref, to [Byte]List ref) Int;
}

trait OutputStream {
    write(self ref, from [Byte]List ref) Int;
    flush(self ref) Void;
}

trait Copy {
}

trait Drop {
    // drop 只由编译器自动插入调用，用户代码禁止显式调用
    drop(self ref) Void;
}

type [T Copy]Node(mut value T, mut next [[T]Node ref]Option, mut prev [[T]Node weakref]Option);

type [T Copy]LinkedList(mut head [[T]Node]Option, mut tail [[T]Node]Option, mut size Int);

type File(fd UInt) not Copy;

given File {
    open(path String) File = File(fopen(path, todo()));

    read(self ref, buf [Byte]List ref) Int = fread(self.fd, buf, 0, buf.size());
    write(self ref, buf [Byte]List ref) Int = fwrite(self.fd, buf, 0, buf.size());

    drop(self ref) Void = fclose(self.fd);
}

/*
1. 默认声明的类型都是值类型，等价于 c struct，但不是所有类型都能直接 copy。
2-1. 任意类型默认都实现了 `Copy`，编译器就会自动根据需要使用 `Copy` 实现来产生新实例。
2-2. 任意类型可以给自己声明 `not Copy` 来标记不实现 Copy，编译器不会自动生成 `Copy` 实现。
2-3. 任意类型内包含的成员变量如果全部都是 `Copy` 类型，且没有标记为 `not Copy`，那么编译器会给这个类型自动实现 `Copy`（递归成员实现）。
2-4. 类型可以同时实现 `Copy` 与 `Drop`，编译器会在 `Copy` 时保持原值有效，在 `Drop` 时按实例逐个释放。
3-1. 任意类型只要显式实现了 drop 函数，其实例生命周期结束时就由编译器插入调用 drop 来销毁。
3-2. 任意类型如果没有显式实现 drop 函数，那么编译器会给这个类型自动实现 drop（递归成员实现）。
3-3. drop 函数不能手动调用。编译器会对手动调用 drop 的代码进行报错。
3-4. 在 drop 实现中移动出成员后，编译器会对被移动的值自动插入 drop，用户代码不需要也不应显式调用成员的 drop。
3-5. drop 函数虽然签名为 drop(self ref)，但调用点视为终结消费，调用后该值不可再读写或移动。
4-1. ref 是内置的智能指针类型，ref 可以从变量获取或者通过 new 函数主动分配，ref 实现了 Copy 和 Drop。
4-2. 只读和读写变量都能获取引用（ref）。当获取的 ref 会发生逃逸时，编译器会自动将变量分配在堆上。
4-3. ref 内部使用了自动引用计数，当 ref 发生 copy 时，引用计数会加1；当 ref 发生 drop 时，引用计数会减1，当计数为 0 时，会调用 ref 源的 drop 释放。
4-4. ref 是共享所有权，所有 ref 都会指向原来产生的变量或者分配的对象。
4-5. T ref 的成员/方法访问自动解引用；若需要获得值的副本，需使用 `deref` 语法调用 T 的 `Copy` 实现。
4-6. 当 ref 存在环引用时，需要通过 weakref 解开环引用。weakref 只操作弱计数，不影响对象存活，弱计数归零释放控制块。
5. 如果编译器判断某个非引用变量的所有权被转移，则不会调用 copy 和 drop，只会 move 值。

lifetime 规则：
作用域包含函数体，if 的 then、else 分支，while 的 then 分支。
1. 变量（本地变量/函数参数/由函数调用和类型构造产生的隐藏变量）在作用域结束前必须被消费。
2. 消费包含 own 语义的绑定、解构、赋值、传参、返回、捕获。
3. 对于实现了 Copy 的变量，如果作用域内存在多于 1 次的消费，那么最后一次之前的消费会由编译器插入 copy 调用来产生新实例。
4. 从变量中获取 ref 并且没有逃逸的话，该变量不会被消耗。如果发生了逃逸，那变量的所有权会转移到 ref 上。 
5. and 和 or 短路后只处理左侧表达式的临时对象生命周期，右侧未求值则无临时对象，已求值则按正常规则处理。
*/
