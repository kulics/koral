# Koral 编程语言

Koral 是一个专注于效率的开源编程语言，它可以帮你轻松构建跨平台软件。

通过精心设计的语法规则，这门语言可以有效降低读写负担，让你能够把真正的注意力放在解决问题上。  

## 关键特性

- 容易分辨、现代化的语法。
- 自动管理内存。
- 泛型。
- 多范式编程。
- 跨平台。
- Unicode。

## 目录

1. [安装与使用](#安装与使用)
1. [基础语法](#基础语法)
1. [基础类型](#基础类型)
1. [操作符](#操作符)
1. [选择结构](#选择结构)
1. [循环结构](#循环结构)
1. [函数](#函数)
1. [数据类型](#数据类型)
1. [泛型数据类型](#泛型数据类型)
1. [数组类型](#数组类型)
1. [泛型函数](#泛型函数)
1. [非逃逸修饰符](#非逃逸修饰符)

## 安装与使用

目前 `Koral` 支持编译到 `C`，因此需要在系统中安装 C 编译器。  

执行编译器就会扫描当前文件夹的 `.koral` 文件，并且自动转译为同名的目标文件。  

## 基础语法

### 基本语句

在 Koral 内，语句是最小的组成单位。

语句的基本形式如下。

```
let a = 0;
let b = 1;
```

一个语句通常以显式的分号结尾。但如果这个语句以 `}` 和换行结尾，我们可以选择省略分号。

例如：

```
let a = { 1 + 1 + 1
        + 1 + 1 }
let b = 1;
```

### 入口函数

我们需要定义一个入口来让程序知道从哪里启动，我们可以通过 main 函数声明。

```
let main() = {}
```

这里我们声明了一个名称为 main 的函数，`=` 右边是这个函数的返回值，`{}` 表示这个函数什么也不执行。

关于函数的更多细节将在之后的章节中说明。

### 显示信息

现在让我们的程序输出一些内容看看，我们可以使用 `printLine` 函数向控制台打印一些信息。

```
let main() = printLine("Hello, world!");
```

现在尝试执行这个程序，我们可以看到控制台上显示了 `Hello, world!`。

### 注释

注释只用来向使用者提供额外的信息，并不会被真正编译到可执行的程序中。

例如：
```
// 行注释

/*
    块
    注释
*/
```

### 变量

Koral 的变量是一种绑定语义，相当于是把一个变量名和一个值绑定在一起，从而建立起了关联关系，类似于键值对。为了安全性的考虑，变量默认是不可以改变的，当然 我们也提供了另一种变量——可变变量。

#### 只读变量

在 Koral 中是通过 let 关键字来声明只读变量的，变量遵循先声明后使用的原则。

Koral 通过静态类型确保类型安全，变量绑定可以在声明时显式通过 `type` 标注类型，在上下文中有足够的信息时，我们也可以省略类型，编译器回从上下文中推断出变量的类型。

示例代码如下：

```
let a Int = 5; // 显式标注类型
let b = 123; // 自动推断类型
```

一旦只读变量被声明之后，它的类型和值在当前作用域内就不会再被改变。

如果我们尝试对只读变量赋值，编译器会报错。

```
let a = 5;
a = 6; // 错误
```

#### 可变变量

如果我们需要一个可以被重新赋值的变量，可以使用可变变量声明。

在 Koral 中通过 let mut 关键字来声明可变变量，同样遵循先声明后使用的原则。

示例代码如下：

```
let mut a Int = 5; // 显式标注类型
let mut b = 123; // 自动推断类型
```

### 赋值

对于可变变量，我们可以在需要的时候多次改变它的值。

Koral 的赋值语句与大多数语言一样，都使用 `=` 声明，`=` 左边必须是可以被赋值的变量，程序会将 `=` 右边的值赋值给左边的变量。

示例代码如下：

```
let mut a = 0;
a = 1;
a = 2;
```

### 块表达式

在 Koral 中，`{}` 表示一个块表达式，块表达式可以包含一系列语句以及一个可选的最后一个表达式，块表达式的结果也是一个表达式。

块表达式中最后一个表达式的值就是块的值。如果没有最后一个表达式，那么块的值就是 Void。

通过块表达式可以组合一系列操作，比如多步初始化某个复杂的值。

```
let a Void = {}
let b Int = {
    let c = 7;
    let d = c + 14;
    (c + 3) * 5 + d / 3
}
```

### 标识符

标识符就是给变量、函数、结构体、接口等指定的名字。构成标识符的字母均有一定的规范，这门语言中标识符的命名规则如下：

1. 区分大小写，Myname 与 myname 是两个不同的标识符；
1. 类型和构造器只能使用大写字母开头，变量和函数只能使用小写字母开头，后面接其它字符。
1. 标识符首字符可以以下划线 `_` 或者字母开始，但不能是数字；
1. 标识符中其他字符可以是下划线 `_` 、字母或数字。
1. 在同一个 `{}` 内，不能重复定义相同名称的标识符。
1. 在不同 `{}` 内，可以定义重名的标识符，语言会优先选择当前范围内定义的标识符。

## 基础类型

我们只需要一些简单的基础类型，就可以开展大部分工作。

### Integer 整数

由于我们目前的计算机结构比较擅长计算整数，因此一个独立的整数类型有助于提升程序的运行效率。

在 Koral 中，默认的整数为 `Int` 类型，它可以表示有符号整数类型数据。

例如：

```
let i Int = 3987349;
```

### Float 浮点数

整数不能满足我们对数字的需求，我们很多时候还需要处理小数。

在 Koral 中，默认的小数为 `Float` 类型，它可以表示浮点型数据。

例如：

```
let f1 Float = 855.544;
let f2 Float = 0.3141592653;
```

### String 字符串

我们在并不是生活在一个只有数字的世界，所以我们也非常需要使用文字来显示我们需要的信息。

在本语言中，默认的文字为 `String` 类型，它是一个不限长度的字符串数据。

你只需要使用 `""` 或 `''` 包裹一段文字内容，它就会被识别为字符串值。

例如：

```
let s1 String = "Hello, world!";
let s2 String = 'Hello, world!'; // 和 s1 相同
```

需要注意的是，字符串是由多个字符组成的类型，所以实际上字符串是一个固定顺序的列表，两者存在对应关系。很多时候我们可以像使用列表那样对字符串进行处理。

### Boolean 布尔

布尔指逻辑上的值，它们只能是真或者假。它经常用以辅助判断逻辑。

在本语言中，默认的布尔为 `Bool` 类型，它是一个只有 true 值和 false 值的类型。

例如：

```
let b1 Bool = true;
let b2 Bool = false;
```

## 操作符

操作符是一种告诉编译器执行特定的数学或逻辑操作的符号。

我们可以简单地理解成数学中的计算符号，但是编程语言有它不同的地方。

### 算术操作符

算数操作符主要被使用在数字类型的数据运算上，大部分声明符合数学中的预期。

例如：

```
let a = 4;
let b = 2;
printLine( a + b );    // + 加
printLine( a - b );    // - 减
printLine( a * b );    // * 乘
printLine( a / b );    // / 除
printLine( a % b );    // % 取余，意思是整除后剩下的余数
```

### 比较操作符

比较操作符主要被使用在判断条件中，用来计算两个数据的关系，结果符合预期的为 `true`，不符合的为 `false`。

例如：

```
let a = 4;
let b = 2;
printLine( a == b );     // == 等于
printLine( a != b );     // != 不等于
printLine( a > b );      // > 大于
printLine( a >= b );     // >= 大于或等于
printLine( a < b );      // < 小于
printLine( a <= b );     // <= 小于或等于
```

### 逻辑操作符

逻辑操作符主要也被使用在判断条件中，用来进行逻辑运算（与、或、非）。

例如：

```
let a = true;
let b = false;
printLine( a & b );     // 与，两者同时为真才为真
printLine( a | b );     // 或，两者其中一者为真就为真
printLine( !a );        // 非，布尔值取反
```

## 选择结构

选择结构用于判断给定的条件，根据判断的结果判断某些条件，根据判断的结果来控制程序的流程。

在 Koral 中选择结构使用 if 语法表示，if 后面紧跟判断条件，在条件为 `true` 时执行条件后面的 `then` 分支，在条件为 `false` 时执行 else 关键字后面的 `else` 分支。

例如：

```
let main() = if 1 == 1 then printLine("yes") else printLine("no");
```

执行上面的程序会看到 `yes`。

if 同样也是表达式，`then` 和 `else` 分支后面都必须是表达式，根据 if 的条件，if 表达式的值可能是 `then` 或 `else` 分支其中的一个。

因此上面那段程序我们也可以这样写，两种写法结果等价。

```
let main() = printLine(if 1 == 1 then "yes" else "no");
```

由于 if 本身也是表达式，因此 else 后面自然也可以接另外一个 if 表达式，这样我们就可以实现连续的条件判断。

```
let x = 0;
let y = if x > 0 then "bigger" else if x == 0 then "equal" else "less";
```

当我们不需要处理 else 分支时，可以省略 else 分支，这时它的值是 Void。

```
let main() = if 1 == 1 then printLine("yes");
```

### 短路逻辑运算

在选择结构或循环结构的条件中，我们可以使用短路逻辑运算 `and` 和 `or` 来组合逻辑。短路逻辑运算的可以跳过部分不必要的计算，以节省计算资源或避免副作用。

短路逻辑与用 `and` 表示，当左侧的条件为 `false` 时，将会跳过右侧的条件计算。

```
let main() = {
    if false and f() then { // 不会执行 f()
        ...
    }
}
```

短路逻辑或用 `or` 表示，当左侧的条件为 `true` 时，将会跳过右侧的条件计算。

```
let main() = {
    if true or f() then { // 不会执行 f()
        ...
    }
}
```

### 初始化语句

在选择结构或循环结构的条件中，我们可以额外包含一个初始化语句（比如定义一个新的变量）。这种语法定义的变量只能在当前选择结构或循环结构后面的代码块中使用（包括 else 后面的代码块）。

在不使用初始化语句的情况下我们可能会这样写，来达到缩小作用域的效果：

```
{
    let val = getValue();
    if condition(val) then {
        // some codes if is true
    } else {
        // some codes if is false
    }
}
```

可以看出，val 属于一个单独的一个块表达式中，这样不会将 val 暴露在 if 之外的作用域中。

使用初始化语句的话我们可以这样写：

```
if let val = getValue(); condition(val) then {
    // some codes if is true
} else {
    // some codes if is false
}
```

如此一来，val 就只能在 if 和 else 中可见，不会泄露到其它作用域中去了。

## 循环结构

循环结构是指在程序中需要反复执行某个功能而设置的一种程序结构。它由循环体中的条件，判断继续执行某个功能还是退出循环。

在 Koral 中循环结构使用 while 语法表示，while 后面紧跟判断条件，在条件为 `true` 时执行后面表达式，然后重新回到判断条件处进行判断进入下一轮循环，在条件为 `false` 结束循环。

这种 while 语法是表达式。

例如：

```
let main() = {
    let mut i = 0;
    while i <= 10 then {
        printLine(i);
        i = i + 1
    }
}
```

执行以上程序会打印 0 到 10。

当我们需要在循环中主动退出循环时，可以使用 break 语句。程序会在执行到 break 时退出当前最近的一层循环。

```
let main() = {
    let mut i = 0;
    while true then {
        if i > 20 then break;
        printLine(i);
        i = i + 1
    }
}
```

执行以上程序会打印 0 到 20。

如果我们需要在循环中跳过某些轮，可以使用 continue 语句。程序会在执行到 continue 时跳过当前一轮循环，继续执行下一次循环。

```
let main() = {
    let mut i = 0;
    while i <= 10 then {
        if i % 2 == 0 then continue;
        printLine(i);
        i = i + 1
    }
}
```

执行以上程序会打印 0 到 10 之间的奇数。

## 函数

函数是用来完成特定任务的独立的代码块。

通常我们会将一系列需要重复使用的任务处理封装成为函数，方便在其它地方重复使用。

### 定义

之前我们已经见过了入口函数，它使用了固定名称 main 来定义。

当我们需要定义其它函数时，我们可以使用同样的语法定义其它名称的函数。

函数通过 let 关键字定义，函数的名字后面使用 `()` 表示这个函数接受的参数，括号后面是这个函数的返回类型。返回类型在上下文明确时可以省略，由编译器推断返回类型。

函数的 `=` 右边必须声明一个表达式，这个表达式的值就是函数的返回值。

```
let f1() Int = 1;
let f2(a Int) = a + 1;
```

### 调用

那么怎么使用这些定义好的函数呢？我们只需要在函数表达式后面使用 `()` 语法就可以调用函数，从而得到函数的返回值。

`()` 必须按函数定义的参数要求传入对应类型的参数。

```
let a = f1();
let b = f2(1);
```

### 参数

参数是函数执行时能够接收的数据，通过这些不同的参数我们就可以让函数输出不同的返回值。

比如我们可以实现一个平方函数，每次调用可以返回参数的平方值。

非常简单的，我们只需要使用 `参数名 类型` 就可以声明参数。

```
let sqrt(x Int) = x * x;
let a = sqrt(x); // a == 4
```

sqrt 接收一个 Int 类型的参数 x，然后返回它的平方值。调用 sqrt 的时候我们需要给出对应 Int 类型的表达式，就可以完成调用。

如果我们需要多个参数，可以按顺序逐个声明它们，中间使用 `,` 分割。调用也需要按同样的顺序给出表达式。

```
let add(x Int, y Int) = x + y;
let a = add(1, 2); // a == 3
```

### 函数类型

在 Koral 中，函数与 Int、Float 等类型一样，也是一种类型，同理函数也可以作为表达式使用。

函数的类型使用 `(T1, T2, T3,... R)Func` 语法声明，跟函数定义一样需要声明参数和返回类型。其中，`T1, T2, T3, ...` 部分是参数类型序列，当没有参数时为空，否则按顺序排列直到列举完所有参数类型。R 是返回类型。

函数定义之后，这个函数名就可以作为表达式使用，可以赋值给其它变量或者作为参数和返回值。

函数类型的变量跟函数一样使用 `()` 语法调用。

```
let sqrt(x Int) = x * x; // (Int, Int)Func
let f (Int, Int)Func = sqrt;
let a = f(2); // a == 4
```

利用这个特性，我们也可以定义函数类型的参数或者返回值。

```
let hello() = printLine("Hello, world!");
let run(f (Void)Func) = f();
let toRun() = run;

let main() = toRun()(hello);
```

执行上面的代码我们会看到 `Hello, world!`。

### Lambda 表达式

如上面那种方式先定义一个函数再传入使用有时候显得比较啰嗦，因为我们仅仅只是希望执行一小段功能而已，未必想定义一个函数提供给其它地方使用。

这时我们可以使用 Lambda 表达式 的语法来简化我们的代码。

Lambda 表达式与函数定义很相似，只是 `=` 换成了 `->`，并且没有函数名和 let 关键字。

如下面的代码所示，f2 的值是一个 lambda，它们的类型与 f1 一样，语法上也非常相似，lambda 的同样需要声明参数和返回类型，并且需要一个表达式作为返回值。

```
let f1(x Int) Int = x + 1; // (Int, Int)Func
let f2 = (x Int) Int -> x + 1; // (Int, Int)Func
let a = f1(1) + f2(1); // a == 4
```

在我们的上下文中可以得知 lambda 的类型时，我们可以省略它的参数类型和返回类型。

```
let f (Int, Int)Func = (x) -> x + 1;
```

## 数据类型

数据类型是由一系列具有相同类型或不同类型的数据构成的数据集合，它是一种复合数据类型。

显而易见，数据类型适合用来将不同数据包装到一起，形成一个新类型，便于操作复杂的数据。

### 定义

我们可以使用 `type` 关键字声明一个新数据类型，数据类型需要使用 `()` 声明它所拥有的成员变量，与函数的参数类似。

```
type Empty();
```

上面我们声明了一个名叫 Empty 的新数据类型，这个数据类型什么数据都不包含。

接下来让我们定义一些更有意义的数据类型试试。

```
type Point(x Int, y Int);
```

Point 是一个具有 x 和 y 两个成员变量的数据类型，它可以用来表示二维坐标系中的某一个点。这样我们就可以使用 Point 这个类型表示我们在坐标系中的数据，而不用总是使用两个独立的 Int 数据。

### 构造

那么我们怎么构造一个新的 Point 数据呢？

和函数类型类似，我们同样使用 `()` 语法来调用我们的构造器，就可以得到我们需要的数据。

```
let a Point = Point(0, 0);
```

### 使用成员变量

现在我们已经有了一个 Point 数据，我们要怎么使用里面的 x 和 y 呢？

很简单，我们只需要使用 `.` 语法，就能访问它们了。

```
type Point(x Int, y Int);

let main() = {
    let a = Point(64, 128);
    printLine(a.x);
    printLine(a.y)
}
```

执行上面的程序，我们可以看到 64 和 128。

### 可变类型

成员变量与变量一样，默认都是只读的。所以我们不能对 Point 中的 x 和 y 再次赋值。如果我们尝试这么做，编译器会报错。

```
type Point(x Int, y Int);

let main() = {
    let a = Point(64, 28);
    a.x = 2 // 错误
}
```

我们可以在类型定义的时候标注 mut 关键字，这样它就会被定义为是一个可变类型。对于可变类型的实例，我们可以对其中的成员变量进行赋值。

成员变量的可变性是跟随类型的，与实例变量是否可变没有关系，所以我们即使声明了只读变量也可以修改可变成员变量。

```
type mut Point(x Int, y Int);

let main() = {
    let a Point = Point(64, 128); // `a` 不需要声明为 mut
    a.x = 2; // ok
    a.y = 0 // ok
}
```

当我们将一个可变类型的变量赋值给另一个变量使用时，两个变量都会会指向同一个实例，所以我们对成员变量的修改会影响到所有相同引用的变量。换句话说，可变类型可以被认为是其它语言中的引用类型。

```
type mut Point(x Int, y Int);

let main() = {
    let a Point = Point(64, 128); 
    let b Point = a; // ok
    printLine(a.x); // 64
    printLine(b.x); // 64
    a.x = 128;
    printLine(a.x); // 128
    printLine(b.x); // 128
}
```

### 成员函数

除了成员变量以外，数据类型还可以定义成员函数。成员函数能让我们的类型直接提供丰富的功能，而不需要依赖外部函数。

定义成员函数很简单，在类型定义的后面声明一个包含成员函数的块即可。

```
type Rectangle(length Int, width Int) {
    self.area() Int = self.length * self.width;
}
```

如上面的代码展示的，我们定义了一个成员函数 `area`，它用来计算 Rectangle 的面积。

跟普通的函数定义有差别的是，成员函数不需要使用 `let` 开头，而且通常前面会带上 `self.`。它用来表示当前类型的实例参数。

也许你已经注意到，在成员函数中我们访问成员变量跟在外部访问成员变量类似，只是我们需要使用 `self` 来表示实例的变量名。

和成员变量的访问一样，我们只需要使用 `.` 语法，就能访问成员函数了。

```
let main() = {
    let r = Rectangle(2, 4);
    printLine(r.area())
}
```

执行上面的程序，我们可以看到 8。

除了包含 `self` 的成员函数以外，我们还可以定义不包含 `self` 的成员函数。

这一类函数不能使用实例访问，只能使用类型名称访问。它可以让我们定义一些与类型关联性很高的函数但不需要实例作为参数的函数。

```
type Point(x Int, y Int) {
    default() Point = Point(0, 0);
}

let main() = {
    let a = Point.default();
    printLine(a.x); // 0
    printLine(a.y); // 0
}
```

例如上面的例子，我们为 Point 定义一个构造默认值的成员函数。然后使用 `Point.default` 的方式调用了它。

## 泛型数据类型

让我们来想想这样一个场景，当我们想在函数的返回类型上返回两个值该怎么做？

对于简单的情况，我们可以定义出一个固定的类型来包装两个值。

```
type Pair(left Int, right Int);

let f() Pair = Pair(1, 2);
```

但如果我们有很多不同的类型需要包装，以上这种方式就显得不够通用了。

我们需要一种能表示容纳任意类型的 Pair，我们可以借助泛型数据类型定义它。

泛型数据类型与数据类型的区别在于它需要额外声明类型参数，这些类型参数表示将来会由实际传入的类型替换，从而让成员变量或成员函数的类型可以在后续实例化的时候替换为具体的类型。

```
type (T1, T2)Pair(left T1, right T2);
```

如上代码所示，我们在 `Pair` 的左边用另一种参数的形式声明了 T1 和 T2 两个类型参数。

如果我们需要多个类型参数，可以按顺序逐个声明它们，中间使用 `,` 分割。调用也需要按同样的顺序给出实际类型。

和普通参数不一样的是，类型参数的标识符总是以大写字母开头，并且没有类型标注。

接下来我们看看如何构造泛型数据类型。

```
let main() = {
    lef a1 (Int, Int)Pair = (Int, Int)Pair(1, 2);
    // a1.left Int, a1.right Int
    lef a2 (Bool, Bool)Pair = (Bool, Bool)Pair(true, false);
    // a2.left Bool, a2.right Bool
    lef a3 (Int, String)Pair = (Int, String)Pair(1, "a");
    // a3.left Int, a3.right String
}
```

如上代码所示，当我们使用泛型 Pair 的时候，需要在泛型参数的位置传入实际的类型。根据我们传入的类型不同，对应变量的 left 和 right 的类型也会有所不同。

这样我们就实现了一个足够通用的 Pair 类型，对于任意类型的两个值，我们都可以使用它来作为我们的返回类型，大大简化了我们需要定义的类型数量。

上面的代码写起来还是比较繁琐，实际上当上下文类型明确的时候，我们可以省略泛型类型构造时的类型参数。所以我们可以使用更简洁的方式来实现上面的功能。

就像下面的代码这样，它和上面的代码是等价的。

```
let main() = {
    lef a1 = Pair(1, 2);
    // a1 (Int, Int)Pair
    lef a2 = Pair(true, false);
    // a2 (Bool, Bool)Pair
    lef a3 = Pair(1, "a");
    // a3 (Int, String)Pair
}
```

## 数组类型

数组是一种泛型的数据类型，它可以存储一组相同类型的数据元素，每个元素都有一个索引来表示它在数组中的位置。数组的长度是固定的，它可以通过索引快速访问任意元素。

我们使用 `(T)Array` 来表示数组类型，其中 `T` 可以是任意类型。

数组类型可以使用数组字面量(`[elem1, elem2, …]`)的方式来初始化，其中 `elem1` 和 `elem2` 表示对应位置的元素，不同的元素之间使用 (`,`) 分割，我们可以传入任何表达式，但所有的元素必须是相同的类型。 

```
let x (Int)Array = [1, 2, 3, 4, 5];
```

如上面的代码所示，我们使用数组字面量语法创建了一个 `(Int)Array`，它的元素就像字面量表示的那样是 `1, 2, 3, 4, 5`。

除了这种列举元素的字面量以外，我们也可以用另一种创建一个指定大小和默认值的数组字面量(`[default; size]`)来构造，`default` 是默认值，`size` 是元素的个数。

```
let y (Int)Array = [0; 3];
// y == [0, 0, 0]
```

我们可以使用数组的 `size` 成员函数来获取它的元素个数。

```
printLine(x.size()); // 5
```

我们可以使用下标语法 `[index]` 的方式来访问指定索引的元素，`index` 只能是 `Int` 类型的值。下标的起始是 0，`[0]` 对应第一个元素，后续元素以此类推。

```
printLine(x[0]); // 1
printLine(x[2]); // 3
printLine(x[4]); // 5
```

配合 `while` 语法，我们就可以对数组的元素实现遍历，就像下面的代码一样。

```
let main() = {
    let x = [1, 2, 3, 4, 5];
    while let mut n = 0; n < x.size() then {
        printLine(x[n]);
        n = n + 1;
    }
}
```

数组也是一种可变类型。对数组元素的修改和对成员变量进行赋值是类似的，只不过需要使用下标语法。

```
let main() = {
    let x = [1, 2, 3, 4, 5];
    printLine(x[0]); // 1
    x[0] = 5;
    printLine(x[0]); // 5
}
```

如上面的代码所示，我们将 x 声明为数组，然后就可以使用 `[index] = value` 的方式对指定下标的元素进行赋值。

## 泛型函数

现在我们已经拥有了强大的泛型数据类型，但我们还没有办法对一个任意类型的泛型类型实现功能，比如说合并任意两个相同类型的数组。

是的，我们需要具备泛型的函数才能实现它。

泛型函数和泛型类型很类似，都是在标识符的前面使用相同的语法定义泛型参数。

```
let (T)mergeArray(a (T)Array, b (T)Array) = {
    ...
}
```

如上代码所示，我们在 `mergeArray` 的左边用同样的泛型语法声明了 T 这个类型参数。

接下来我们看看如何调用泛型函数。

```
let main() = {
    let x = [1, 2, 3];
    let y = [4, 5, 6];
    let z = (Int)mergeArray(x, y);
    // z == [1, 2, 3, 4, 5, 6]
}
```

如上代码所示，它跟普通的函数调用差不多，不同的只是在函数名的前面增加了类型参数，就像泛型数据类型的构造一样。

同样的道理，在上下文明确的时候，我们也可以省略类型参数，下面的代码等价于上面的代码。

```
let main() = {
    let x = [1, 2, 3];
    let y = [4, 5, 6];
    let z = mergeArray(x, y);
}
```

## 非逃逸修饰符

在 Koral 中，我们可以使用非逃逸修饰符来控制参数和返回类型的生命周期。这些修饰符包括 `in` 参数修饰符，`out` 返回类型修饰符，`inout` 参数修饰符。在显式标记这些修饰符的情况下，编译器可以进行最大程度的逃逸分析，从而减少堆对象的分配，提升性能表现。

### in 参数修饰符

`in` 参数修饰符表示这个参数只能在函数体内访问其成员或传递给其它 `in` 参数，该参数本身不能逃逸到函数体外，包括不能赋值给其它变量以及作为返回值。

```koral
type Foo(x Int, y Int);
let sum(a in Foo) Int = {
    a.x + a.y // ok
}
let escape(a in Foo) Foo = {
    a // error
}
```

在上面的代码中，参数 `a` 被标记为 `in`，表示它只能在函数体内使用，不能逃逸到函数体外。如果编译器检查发现了逃逸，就会报出编译错误。

`in` 参数在调用时和普通参数的语法一样。

```koral
let main() = {
    let b = Foo(1, 2);
    let use(a in Foo) Int = sum(a); // ok
    use(b); // ok
}
```

### out 返回类型修饰符

`out` 返回类型修饰符表示这个函数的返回值不会逃逸到调用者的作用域之外，函数内的返回值只能是就地构造的值或者是来自其它 `out` 返回的函数调用，而不能来自于变量或变量的成员。

```koral
type Foo(x Int, y Int);
let new() out Foo = {
    Foo(1, 2) // ok
}
let mut b Foo = Foo(2, 1);
let escape(a Foo) out Foo = {
    return a; // error
    let c = Foo(1, 2);
    b = c;
    c // error, c has already escaped
}
```

在上面的代码中，返回类型 `Foo` 被标记为 `out`，表示它只能在函数体内原地构造新值，这个新值除了返回以外不能逃逸。其它情况都会报出编译错误。

`out` 返回的值在调用时和普通参数的语法一样。

```koral
let main() = {
    let inner_new() Foo = new(); // ok
    let temp = inner_new();
}
```

### inout 参数修饰符

`inout` 参数修饰符必须和 `out` 返回类型修饰符搭配使用，`inout` 表示该参数必须被消费给返回值，而不能发生其它逃逸，这意味着参数的所有权被转移给了返回值。

```koral
type Foo(x Int, y Int);
type WrapperFoo(foo Foo);

let transfer(a inout Foo) out WrapperFoo = {
    WrapperFoo(a) // ok
}
let escape(a inout Foo) Foo = {
    a // error
}
```

在上面的代码中，参数 `a` 被标记为 `inout`，表示它的生命周期会与函数体内的 `WrapperFoo` 的生命周期保持一致。如果编译器检查发现了逃逸，就会报出编译错误。

`inout` 参数在调用时和普通参数的语法一样。

```koral
let main() = {
    let b = Foo(1, 2);
    let trans(a inout Foo) out WrapperFoo = transfer(a); // ok
    let wrapped = trans(b); // ok
}
```

