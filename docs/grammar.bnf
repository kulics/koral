// Koral Language Grammar (BNF)
// Updated to match current implementation (Lexer/Parser)

<program> ::= <using-decl>* <global-decl>*

// using 必须出现在其他全局声明之前

<using-decl> ::= <access-modifier>? "using" <using-path> ";"?
<using-path> ::= <file-merge-path>
               | <external-path>
               | <submodule-path>
               | <parent-path>

<file-merge-path> ::= <string-literal>

<external-path> ::= <external-alias>? <path-segments> <batch-import>?
<external-alias> ::= <identifier> "="

<submodule-path> ::= "self" "." <path-segments> <batch-import>?

<parent-path> ::= "super" ("." "super")* ("." <identifier>)* <batch-import>?

<path-segments> ::= <identifier> ("." <identifier>)*
<batch-import> ::= "." "*"

// 说明：
// 1) file merge (using "file") 不允许访问修饰符
// 2) alias 只支持 external path（using alias = std.text）

// ============================================================================
// Global Declarations
// ============================================================================

<global-decl> ::= <access-modifier>? "intrinsic"? <let-decl>
               | <access-modifier>? "intrinsic"? <type-decl>
               | <access-modifier>? <trait-decl>
               | "intrinsic"? <given-decl>

<access-modifier> ::= "public" | "private" | "protected"

// ============================================================================
// Let Declarations (Variables and Functions)
// ============================================================================

<let-decl> ::= "let" <generic-params>? <identifier> <function-signature> "=" <expression> ";"?
             | "let" "mut"? <identifier> <type-annotation>? "=" <expression> ";"?
             | "let" <generic-params>? <identifier> <function-signature> ";"?  // intrinsic function
// 说明：出现 mut 时必须是变量声明（不可接函数参数列表）

<function-signature> ::= "(" <func-param-list>? ")" <type-annotation>?
<func-param-list> ::= <func-param> ("," <func-param>)* ","?
<func-param> ::= "mut"? <identifier> <type-annotation>

<method-param-list> ::= <method-first-param> ("," <func-param>)* ","?
<method-first-param> ::= "self" ("ref")?
                       | <func-param>

<type-annotation> ::= <type>

// ============================================================================
// Type Declarations
// ============================================================================

<type-decl> ::= "type" <generic-params>? <type-identifier> <type-body>
              | "type" <generic-params>? <type-identifier>            // intrinsic type (no body)
<type-body> ::= "(" <field-list>? ")"                 // struct
              | "{" <variant-list>? "}"                // union (sum type)

<field-list> ::= <field> ("," <field>)* ","?
<field> ::= <access-modifier>? "mut"? <identifier> <type-annotation>

<variant-list> ::= <variant> ("," <variant>)* ","?
<variant> ::= <identifier> "(" <variant-field-list>? ")"
<variant-field-list> ::= <variant-field> ("," <variant-field>)* ","?
<variant-field> ::= <identifier> <type-annotation>

// ============================================================================
// Trait Declarations
// ============================================================================

<trait-decl> ::= "trait" <generic-params>? <type-identifier> <trait-parents>? "{" <trait-member>* "}"
<trait-parents> ::= <type-identifier> ("and" <type-identifier>)*
<trait-member> ::= <access-modifier>? <identifier> "(" <method-param-list>? ")" <type-annotation>? ";"?
// 说明：trait method 不支持泛型参数和方法体

// ============================================================================
// Given Declarations (Type Implementations)
// ============================================================================

<given-decl> ::= "given" <generic-params>? <type> "{" <given-member>* "}"
<given-member> ::= <access-modifier>? <generic-params>? <identifier> "(" <method-param-list>? ")" <type-annotation>? "=" <expression> ";"?
                 | <access-modifier>? <generic-params>? <identifier> "(" <method-param-list>? ")" <type-annotation>? ";"?  // intrinsic given method

// ============================================================================
// Generic Parameters
// ============================================================================

<generic-params> ::= "[" <generic-param-list> "]"
<generic-param-list> ::= <generic-param> ("," <generic-param>)*
<generic-param> ::= <identifier> <trait-constraints>
<trait-constraints> ::= <type-identifier> ("and" <type-identifier>)*

// ============================================================================
// Types
// ============================================================================

<type> ::= <type-identifier> ("ref")?
         | <generic-type> ("ref")?
         | <function-type> ("ref")?
         | "Self" ("ref")?

<generic-type> ::= "[" <type-list> "]" <type-identifier>
<function-type> ::= "[" <type-list> "]" "Func"
// Function type: [ParamType1, ParamType2, ..., ReturnType]Func
// The last type is the return type, all others are parameter types
// Examples:
//   [Int]Func           - () -> Int (no params, returns Int)
//   [Int, Int]Func      - (Int) -> Int (one param, returns Int)
//   [Int, Int, Int]Func - (Int, Int) -> Int (two params, returns Int)

<type-list> ::= <type> ("," <type>)*

// ============================================================================
// Statements
// ============================================================================

<statement> ::= <let-statement>
              | <assignment-statement>
              | <return-statement>
              | <break-statement>
              | <continue-statement>
              | <expression-statement>

<let-statement> ::= "let" "mut"? <identifier> <type-annotation>? "=" <expression> ";"?

<assignment-statement> ::= <expression> <assign-op> <expression> ";"?
<assign-op> ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "**=" | "&=" | "|=" | "^=" | "<<=" | ">>="

<return-statement> ::= "return" <expression>? ";"?
<break-statement> ::= "break" ";"?
<continue-statement> ::= "continue" ";"?

<expression-statement> ::= <expression> ";"?

// ============================================================================
// Expressions
// ============================================================================

<expression> ::= <let-expression>
               | <if-expression>
               | <while-expression>
               | <for-expression>
               | <when-expression>
               | <or-expression>

<let-expression> ::= "let" "mut"? <identifier> <type-annotation>? "=" <expression> "then" <expression>

<if-expression> ::= "if" <expression> "then" <expression> ("else" <expression>)?
                 | "if" <expression> "is" <pattern> "then" <expression> ("else" <expression>)?

<while-expression> ::= "while" <expression> "then" <expression>
                     | "while" <expression> "is" <pattern> "then" <expression>

<for-expression> ::= "for" <pattern> "=" <expression> "then" <expression>

<when-expression> ::= "when" <expression> "is" "{" <match-arm-list> "}"
<match-arm-list> ::= <match-arm> ("," <match-arm>)* ","?
<match-arm> ::= <pattern> "then" <expression>

// ============================================================================
// Binary Expressions (by precedence, lowest to highest)
// ============================================================================

<or-expression> ::= <and-expression> ("or" <and-expression>)*
<and-expression> ::= <not-expression> ("and" <not-expression>)*
<not-expression> ::= "not" <bitwise-or-expression> | <bitwise-or-expression>

<bitwise-or-expression> ::= <bitwise-xor-expression> ("|" <bitwise-xor-expression>)*
<bitwise-xor-expression> ::= <bitwise-and-expression> ("^" <bitwise-and-expression>)*
<bitwise-and-expression> ::= <range-expression> ("&" <range-expression>)*

<range-expression> ::= <comparison-expression> <range-suffix>?
                     | <range-prefix> <comparison-expression>
                     | "...."

<range-suffix> ::= <range-op> <comparison-expression>
                 | <postfix-range-op>

<range-op> ::= ".." | "..<" | "<.." | "<..<"
<postfix-range-op> ::= "..." | "<..."
<range-prefix> ::= "..." | "...<"

<comparison-expression> ::= <shift-expression> (<comparison-op> <shift-expression>)*
<comparison-op> ::= "==" | "<>" | ">" | "<" | ">=" | "<="

<shift-expression> ::= <additive-expression> (<shift-op> <additive-expression>)*
<shift-op> ::= "<<" | ">>"

<additive-expression> ::= <multiplicative-expression> (<additive-op> <multiplicative-expression>)*
<additive-op> ::= "+" | "-"

<multiplicative-expression> ::= <power-expression> (<multiplicative-op> <power-expression>)*
<multiplicative-op> ::= "*" | "/" | "%"

<power-expression> ::= <prefix-expression> ("**" <power-expression>)?

// ============================================================================
// Prefix Expressions
// ============================================================================

<prefix-expression> ::= <cast-expression>
                      | "ref" <prefix-expression>
                      | "deref" <prefix-expression>
                      | "~" <prefix-expression>
                      | <postfix-expression>

<cast-expression> ::= "(" <type> ")" <prefix-expression>

// ============================================================================
// Postfix Expressions
// ============================================================================

<postfix-expression> ::= <primary-expression> <postfix-suffix>*
<postfix-suffix> ::= <call-suffix>
                   | <subscript-suffix>
                   | <member-suffix>

<call-suffix> ::= "(" <argument-list>? ")"
<subscript-suffix> ::= "[" <expression-list> "]"
<member-suffix> ::= "." <identifier>

<argument-list> ::= <expression> ("," <expression>)* ","?
<expression-list> ::= <expression> ("," <expression>)* ","?

// ============================================================================
// Primary Expressions
// ============================================================================

<primary-expression> ::= <literal>
                       | <identifier>
                       | "self"
                       | <generic-instantiation>
                       | <block-expression>
                       | <lambda-expression>
                       | "(" <expression> ")"

<generic-instantiation> ::= "[" <type-list> "]" <identifier>

<block-expression> ::= "{" <statement>* <expression>? "}"

<lambda-expression> ::= "(" <lambda-param-list>? ")" <type-annotation>? "->" <expression>
<lambda-param-list> ::= <lambda-param> ("," <lambda-param>)* ","?
<lambda-param> ::= <identifier> <type-annotation>?
// Lambda expression examples:
//   () -> 42                           - no params
//   (x) -> x * 2                       - single param, type inferred
//   (x Int) -> x * 2                   - single param with type
//   (x, y) -> x + y                    - multiple params, types inferred
//   (x Int, y Int) Int -> x + y        - full type annotations
//   (x) -> { let y = x * 2; y + 1 }    - block body

// ============================================================================
// Patterns
// ============================================================================

<pattern> ::= <or-pattern>

<or-pattern> ::= <and-pattern> ("or" <and-pattern>)*
<and-pattern> ::= <not-pattern> ("and" <not-pattern>)*
<not-pattern> ::= "not" <not-pattern>
               | <primary-pattern>

<primary-pattern> ::= "_"                                     // wildcard
                    | "-"? <integer-literal>                  // integer literal pattern (including negative)
                    | <bool-literal>                          // bool literal pattern
                    | <string-literal>                        // string literal pattern
                    | "mut"? <identifier>                     // variable binding
                    | <comparison-pattern>                    // comparison pattern
                    | <union-case-pattern>                    // union case pattern

<comparison-pattern> ::= <comparison-op> "-"? <integer-literal>
// Comparison patterns: > n, < n, >= n, <= n (where n is an integer literal, optionally negative)

<union-case-pattern> ::= "." <identifier> ("(" <pattern-list>? ")")?
<pattern-list> ::= <pattern> ("," <pattern>)* ","?

// ============================================================================
// Literals
// ============================================================================

<literal> ::= <integer-literal>
            | <float-literal>
            | <string-literal>
            | <bool-literal>

<integer-literal> ::= [0-9]+ ("_" [0-9]+)* <integer-suffix>?
<integer-suffix> ::= "i" | "i8" | "i16" | "i32" | "i64"
                   | "u" | "u8" | "u16" | "u32" | "u64"

<float-literal> ::= [0-9]+ ("_" [0-9]+)* "." [0-9]+ ("_" [0-9]+)* <float-suffix>?
<float-suffix> ::= "f32" | "f64"

<string-literal> ::= '"' <string-char>* '"'
                   | "'" <string-char>* "'"

<string-char> ::= <escape-sequence> | ~["\\\n]
<escape-sequence> ::= "\\" ("n" | "t" | "r" | "v" | "f" | "0" | "\\" | '"' | "'")

<bool-literal> ::= "true" | "false"

<identifier> ::= [a-zA-Z_][a-zA-Z0-9_]*
<type-identifier> ::= [A-Z][a-zA-Z0-9_]*

// ============================================================================
// Keywords
// ============================================================================

// Reserved keywords:
//   let, mut, type, trait, given, intrinsic
//   using, self, Self, super
//   if, then, else, while, for, when, is
//   and, or, not
//   ref, deref
//   return, break, continue
//   true, false
//   public, private, protected

// ============================================================================
// Operators
// ============================================================================

// Arithmetic: + - * / % **
// Comparison: == <> > < >= <=
// Logical: and or not
// Bitwise: & | ^ ~ << >>
// Assignment: = += -= *= /= %= **= &= |= ^= <<= >>=
// Range: .. ..< <.. <..< ... <... ...< ....
// Lambda: ->
// Other: . , ; : ( ) [ ] { }

// ============================================================================
// Comments
// ============================================================================

// Line comment: // ...
// Block comment: /* ... */

// ============================================================================
// Automatic Semicolon Insertion
// ============================================================================

// Koral uses newline-based statement termination with continuation rules:
// - Semicolons are optional at end of statements/declarations
// - A newline terminates a statement unless:
//   1. The next token is a continuation token (infix operators, dot, arrow)
//   2. The statement is inside parentheses, brackets, or braces
// - Blank lines and comments block line continuation
