// Koral Language Grammar (BNF)
// Updated to match current implementation

<program> ::= <item>*

<item> ::= <global-decl>

// ============================================================================
// Global Declarations
// ============================================================================

<global-decl> ::= <access-modifier>? "intrinsic"? <let-decl>
               | <access-modifier>? "intrinsic"? <type-decl>
               | <access-modifier>? <trait-decl>
               | "intrinsic"? <given-decl>

<access-modifier> ::= "public" | "private" | "protected"

// ============================================================================
// Let Declarations (Variables and Functions)
// ============================================================================

<let-decl> ::= "let" <generic-params>? <identifier> <function-signature> "=" <expression> ";"?
             | "let" "mut"? <identifier> <type-annotation>? "=" <expression> ";"?
             | "let" <generic-params>? <identifier> <function-signature> ";"?  // intrinsic function

<function-signature> ::= "(" <param-list>? ")" <type-annotation>?
<param-list> ::= <param> ("," <param>)* ","?
<param> ::= "mut"? <identifier> <type-annotation>
          | "self" ("ref")?                           // self parameter in methods

<type-annotation> ::= <type>

// ============================================================================
// Type Declarations
// ============================================================================

<type-decl> ::= "type" <generic-params>? <identifier> <type-body>?
<type-body> ::= "(" <field-list>? ")"                 // struct
              | "{" <variant-list> "}"                // union (sum type)

<field-list> ::= <field> ("," <field>)* ","?
<field> ::= <access-modifier>? "mut"? <identifier> <type-annotation>

<variant-list> ::= <variant> ("," <variant>)* ","?
<variant> ::= <identifier> "(" <variant-field-list>? ")"
<variant-field-list> ::= <variant-field> ("," <variant-field>)* ","?
<variant-field> ::= <identifier> <type-annotation>

// ============================================================================
// Trait Declarations
// ============================================================================

<trait-decl> ::= "trait" <generic-params>? <identifier> <trait-parents>? "{" <trait-member>* "}"
<trait-parents> ::= <identifier> ("and" <identifier>)*
<trait-member> ::= <access-modifier>? <generic-params>? <identifier> <function-signature> ";"?

// ============================================================================
// Given Declarations (Type Implementations)
// ============================================================================

<given-decl> ::= "given" <generic-params>? <type> "{" <given-member>* "}"
<given-member> ::= <access-modifier>? <generic-params>? <identifier> <function-signature> "=" <expression> ";"?
                 | <access-modifier>? <generic-params>? <identifier> <function-signature> ";"?  // intrinsic method

// ============================================================================
// Generic Parameters
// ============================================================================

<generic-params> ::= "[" <generic-param-list> "]"
<generic-param-list> ::= <generic-param> ("," <generic-param>)*
<generic-param> ::= <identifier> <trait-constraints>?
<trait-constraints> ::= <identifier> ("and" <identifier>)*

// ============================================================================
// Types
// ============================================================================

<type> ::= <simple-type> ("ref")*

<simple-type> ::= <identifier>                                    // simple type: Int, String
                | <generic-type>                                  // generic type: [T]List, [K, V]Map
                | "Self"                                          // Self type in traits/given

<generic-type> ::= "[" <type-list> "]" <identifier>
<type-list> ::= <type> ("," <type>)*

// ============================================================================
// Statements
// ============================================================================

<statement> ::= <let-statement>
              | <assignment-statement>
              | <return-statement>
              | <break-statement>
              | <continue-statement>
              | <expression-statement>

<let-statement> ::= "let" "mut"? <identifier> <type-annotation>? "=" <expression> ";"?

<assignment-statement> ::= <expression> <assign-op> <expression> ";"?
<assign-op> ::= "=" | "+=" | "-=" | "*=" | "/=" | "%="

<return-statement> ::= "return" <expression>? ";"?
<break-statement> ::= "break" ";"?
<continue-statement> ::= "continue" ";"?

<expression-statement> ::= <expression> ";"?

// ============================================================================
// Expressions
// ============================================================================

<expression> ::= <let-expression>
               | <if-expression>
               | <while-expression>
               | <for-expression>
               | <when-expression>
               | <or-expression>

<let-expression> ::= "let" "mut"? <identifier> <type-annotation>? "=" <expression> "then" <expression>

<if-expression> ::= "if" <expression> "then" <expression> ("else" <expression>)?

<while-expression> ::= "while" <expression> "then" <expression>

<for-expression> ::= "for" <pattern> "=" <expression> "then" <expression>

<when-expression> ::= "when" <expression> "is" "{" <match-arm-list> "}"
<match-arm-list> ::= <match-arm> ("," <match-arm>)* ","?
<match-arm> ::= <pattern> "then" <expression>

// ============================================================================
// Binary Expressions (by precedence, lowest to highest)
// ============================================================================

<or-expression> ::= <and-expression> ("or" <and-expression>)*
<and-expression> ::= <not-expression> ("and" <not-expression>)*
<not-expression> ::= "not" <bitwise-or-expression> | <bitwise-or-expression>

<bitwise-or-expression> ::= <bitwise-xor-expression> ("bitor" <bitwise-xor-expression>)*
<bitwise-xor-expression> ::= <bitwise-and-expression> ("bitxor" <bitwise-and-expression>)*
<bitwise-and-expression> ::= <range-expression> ("bitand" <range-expression>)*

<range-expression> ::= <comparison-expression> <range-op> <comparison-expression>
                     | <comparison-expression> <postfix-range-op>
                     | <prefix-range-op> <comparison-expression>
                     | "...."
                     | <comparison-expression>

<range-op> ::= ".." | "..<" | "<.." | "<..<"
<postfix-range-op> ::= "..." | "<..."
<prefix-range-op> ::= "..." | "...<"

<comparison-expression> ::= <shift-expression> (<comparison-op> <shift-expression>)*
<comparison-op> ::= "==" | "<>" | ">" | "<" | ">=" | "<="

<shift-expression> ::= <additive-expression> (<shift-op> <additive-expression>)*
<shift-op> ::= "bitshl" | "bitshr"

<additive-expression> ::= <multiplicative-expression> (<additive-op> <multiplicative-expression>)*
<additive-op> ::= "+" | "-"

<multiplicative-expression> ::= <prefix-expression> (<multiplicative-op> <prefix-expression>)*
<multiplicative-op> ::= "*" | "/" | "%"

// ============================================================================
// Prefix Expressions
// ============================================================================

<prefix-expression> ::= <cast-expression>
                      | "ref" <prefix-expression>
                      | "deref" <prefix-expression>
                      | "bitnot" <prefix-expression>
                      | <postfix-expression>

<cast-expression> ::= "(" <type> ")" <prefix-expression>

// ============================================================================
// Postfix Expressions
// ============================================================================

<postfix-expression> ::= <primary-expression> <postfix-suffix>*
<postfix-suffix> ::= <call-suffix>
                   | <subscript-suffix>
                   | <member-suffix>

<call-suffix> ::= "(" <argument-list>? ")"
<subscript-suffix> ::= "[" <expression-list> "]"
<member-suffix> ::= "." <identifier>

<argument-list> ::= <expression> ("," <expression>)* ","?
<expression-list> ::= <expression> ("," <expression>)* ","?

// ============================================================================
// Primary Expressions
// ============================================================================

<primary-expression> ::= <literal>
                       | <identifier>
                       | "self"
                       | <generic-instantiation>
                       | <block-expression>
                       | "(" <expression> ")"

<generic-instantiation> ::= "[" <type-list> "]" <identifier>

<block-expression> ::= "{" <statement>* <expression>? "}"

// ============================================================================
// Patterns
// ============================================================================

<pattern> ::= "_"                                     // wildcard
            | <literal>                               // literal pattern
            | "mut"? <identifier>                     // variable binding
            | <range-pattern>                         // range pattern
            | <union-case-pattern>                    // union case pattern

<range-pattern> ::= <pattern-operand> <range-op> <pattern-operand>
                  | <pattern-operand> <postfix-range-op>
                  | <prefix-range-op> <pattern-operand>
                  | "...."

<pattern-operand> ::= "-"? <integer-literal>

<union-case-pattern> ::= "." <identifier> ("(" <pattern-list>? ")")?
<pattern-list> ::= <pattern> ("," <pattern>)* ","?

// ============================================================================
// Literals
// ============================================================================

<literal> ::= <integer-literal>
            | <float-literal>
            | <string-literal>
            | <bool-literal>

<integer-literal> ::= [0-9]+ ("_" [0-9]+)* <integer-suffix>?
<integer-suffix> ::= "i" | "i8" | "i16" | "i32" | "i64"
                   | "u" | "u8" | "u16" | "u32" | "u64"

<float-literal> ::= [0-9]+ ("_" [0-9]+)* "." [0-9]+ ("_" [0-9]+)* <float-suffix>?
<float-suffix> ::= "f32" | "f64"

<string-literal> ::= '"' <string-char>* '"'
                   | "'" <string-char>* "'"

<string-char> ::= <escape-sequence> | ~["\\\n]
<escape-sequence> ::= "\\" ("n" | "t" | "r" | "v" | "f" | "0" | "\\" | '"' | "'")

<bool-literal> ::= "true" | "false"

<identifier> ::= [a-zA-Z_][a-zA-Z0-9_]*

// ============================================================================
// Keywords
// ============================================================================

// Reserved keywords:
//   let, mut, type, trait, given, intrinsic
//   if, then, else, while, for, when, is
//   and, or, not
//   bitand, bitor, bitxor, bitnot, bitshl, bitshr
//   ref, deref
//   self, Self
//   return, break, continue
//   true, false
//   public, private, protected

// ============================================================================
// Operators
// ============================================================================

// Arithmetic: + - * / % ^
// Comparison: == <> > < >= <=
// Logical: and or not
// Bitwise: bitand bitor bitxor bitnot bitshl bitshr
// Assignment: = += -= *= /= %=
// Range: .. ..< <.. <..< ... <... ...< ....
// Other: -> . , ; : ( ) [ ] { }

// ============================================================================
// Comments
// ============================================================================

// Line comment: // ...
// Block comment: /* ... */

// ============================================================================
// Automatic Semicolon Insertion
// ============================================================================

// Koral uses newline-based statement termination with continuation rules:
// - Semicolons are optional at end of statements/declarations
// - A newline terminates a statement unless:
//   1. The next token is a continuation token (infix operators, dot, arrow)
//   2. The statement is inside parentheses, brackets, or braces
// - Blank lines and comments block line continuation
