// Koral Language Grammar (BNF)
// Updated to match current implementation (Lexer/Parser)

<program> ::= (<using-decl> | <foreign-using-decl>)* <global-decl>*

// using 必须出现在其他全局声明之前

<using-decl> ::= <access-modifier>? "using" <using-path> ";"?
<foreign-using-decl> ::= "foreign" "using" <string-literal> ";"?
// 说明：foreign using 的 string-literal 是链接库名（如 "m"），
// 编译器在链接阶段添加 -l<name> 参数。
<using-path> ::= <file-merge-path>
               | <external-path>
               | <submodule-path>
               | <parent-path>

<file-merge-path> ::= <string-literal>

<external-path> ::= <external-alias>? <path-segments> <batch-import>?
<external-alias> ::= <identifier> "="

<submodule-path> ::= "self" "." <path-segments> <batch-import>?

<parent-path> ::= "super" ("." "super")* ("." <identifier>)* <batch-import>?

<path-segments> ::= <identifier> ("." <identifier>)*
<batch-import> ::= "." "*"

// 说明：
// 1) file merge (using "file") 不允许访问修饰符
// 2) alias 只支持 external path（using alias = std.text）

// ============================================================================
// Global Declarations
// ============================================================================

<global-decl> ::= <access-modifier>? "intrinsic"? <let-decl>
               | <access-modifier>? "foreign" <foreign-let-decl>
               | <access-modifier>? "intrinsic"? <type-decl>
               | <access-modifier>? "foreign" <foreign-type-decl>
               | <access-modifier>? <trait-decl>
               | "intrinsic"? <given-decl>

<access-modifier> ::= "public" | "private" | "protected"

// ============================================================================
// Let Declarations (Variables and Functions)
// ============================================================================

<let-decl> ::= "let" <generic-params>? <identifier> <function-signature> "=" <expression> ";"?
             | "let" "mut"? <identifier> <type-annotation>? "=" <expression> ";"?
             | "let" <generic-params>? <identifier> <function-signature> ";"?  // intrinsic function
// 说明：出现 mut 时必须是变量声明（不可接函数参数列表）

<foreign-let-decl> ::= "let" "mut"? <identifier> <type-annotation> ";"?
                     | "let" <identifier> <function-signature> <type-annotation>? ";"?
// 说明：
// 1) foreign 变量声明必须有类型（支持 mut）
// 2) foreign 函数不允许函数体，不支持泛型

<function-signature> ::= "(" <func-param-list>? ")" <type-annotation>?
<func-param-list> ::= <func-param> ("," <func-param>)* ","?
<func-param> ::= "mut"? <identifier> <type-annotation>

<method-param-list> ::= <method-first-param> ("," <func-param>)* ","?
<method-first-param> ::= "self" ("ref")?
                       | <func-param>

<type-annotation> ::= <type>

// ============================================================================
// Type Declarations
// ============================================================================

<type-decl> ::= "type" <generic-params>? <type-identifier> <type-body>
              | "type" <generic-params>? <type-identifier>            // intrinsic type (no body)
              | "type" <type-identifier> "=" <type>                   // type alias
// 说明：类型别名不支持泛型参数，但目标类型可以是泛型实例化类型（如 [Int]List）
// 类型别名在语义检查阶段被完全消除，后续阶段无需感知其存在
<type-body> ::= "(" <field-list>? ")"                 // struct
              | "{" <variant-list>? "}"                // union (sum type)

<foreign-type-decl> ::= "type" <string-literal>? <type-identifier> ("(" <field-list>? ")")? ";"?
// 说明：
// 1) 可选 string-literal 为 C 侧类型名（cname）
// 2) foreign type 可以有字段（用于 FFI 结构体布局对齐），也可以没有（opaque type）

<field-list> ::= <field> ("," <field>)* ","?
<field> ::= <access-modifier>? "mut"? <identifier> <type-annotation>

<variant-list> ::= <variant> ("," <variant>)* ","?
<variant> ::= <identifier> "(" <variant-field-list>? ")"
<variant-field-list> ::= <variant-field> ("," <variant-field>)* ","?
<variant-field> ::= <identifier> <type-annotation>

// ============================================================================
// Trait Declarations
// ============================================================================

<trait-decl> ::= "trait" <generic-params>? <type-identifier> <trait-parents>? "{" <trait-member>* "}"
<trait-parents> ::= <type> ("and" <type>)*
<trait-member> ::= <access-modifier>? <generic-params>? <identifier> "(" <method-param-list>? ")" <type-annotation>? ";"?
// 说明：trait method 支持泛型参数，但不支持方法体

// ============================================================================
// Given Declarations (Type Implementations)
// ============================================================================

<given-decl> ::= "given" <generic-params>? <type> <type>? "{" <given-member>* "}"
<given-member> ::= <access-modifier>? <generic-params>? <identifier> "(" <method-param-list>? ")" <type-annotation>? "=" <expression> ";"?
                 | <access-modifier>? <generic-params>? <identifier> "(" <method-param-list>? ")" <type-annotation>? ";"?  // intrinsic given method
// 说明：
// 1) `given Type { ... }` 为类型固有实现
// 2) `given Type Trait { ... }` 为 trait 实现

// ============================================================================
// Generic Parameters
// ============================================================================

<generic-params> ::= "[" <generic-param-list> "]"
<generic-param-list> ::= <generic-param> ("," <generic-param>)*
<generic-param> ::= <identifier> <trait-constraints>
<trait-constraints> ::= <type-identifier> ("and" <type-identifier>)*

// ============================================================================
// Types
// ============================================================================

<type> ::= <type-identifier> <type-suffix>*
         | <generic-type> <type-suffix>*
         | <function-type> <type-suffix>*
         | <module-qualified-type> <type-suffix>*
         | <module-qualified-generic-type> <type-suffix>*
         | "Self" <type-suffix>*

<module-qualified-type> ::= <identifier> "." <type-identifier>
<module-qualified-generic-type> ::= <identifier> "." <generic-type>

<type-suffix> ::= "ref" | "ptr" | "weakref"

<generic-type> ::= "[" <type-list> "]" <type-identifier>
<function-type> ::= "[" <type-list> "]" "Func"
// Function type: [ParamType1, ParamType2, ..., ReturnType]Func
// The last type is the return type, all others are parameter types
// Examples:
//   [Int]Func           - () -> Int (no params, returns Int)
//   [Int, Int]Func      - (Int) -> Int (one param, returns Int)
//   [Int, Int, Int]Func - (Int, Int) -> Int (two params, returns Int)

<type-list> ::= <type> ("," <type>)*

// ============================================================================
// Statements
// ============================================================================

<statement> ::= <let-statement>
              | <assignment-statement>
              | <return-statement>
              | <break-statement>
              | <continue-statement>
              | <defer-statement>
              | <yield-statement>
              | <expression-statement>

<let-statement> ::= "let" "mut"? <identifier> <type-annotation>? "=" <expression> ";"?

<assignment-statement> ::= <expression> <assign-op> <expression> ";"?
<assign-op> ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>="

<return-statement> ::= "return" <expression>? ";"?
<break-statement> ::= "break" ";"?
<continue-statement> ::= "continue" ";"?

<defer-statement> ::= "defer" <expression> ";"?

<yield-statement> ::= "yield" <expression> ";"?

<expression-statement> ::= <expression> ";"?

// ============================================================================
// Expressions
// ============================================================================

<expression> ::= <let-expression>
               | <if-expression>
               | <while-expression>
               | <for-expression>
               | <when-expression>
               | <or-else-expression>

<let-expression> ::= "let" "mut"? <identifier> <type-annotation>? "=" <expression> "then" <expression>

<if-expression> ::= "if" <expression> "then" <expression> ("else" <expression>)?
                 | "if" <expression> "is" <pattern> "then" <expression> ("else" <expression>)?

<while-expression> ::= "while" <expression> "then" <expression>
                     | "while" <expression> "is" <pattern> "then" <expression>

<for-expression> ::= "for" <pattern> "in" <expression> "then" <expression>

<when-expression> ::= "when" <expression> "in" "{" <match-arm-list> "}"
<match-arm-list> ::= <match-arm> ("," <match-arm>)* ","?
<match-arm> ::= <pattern> "then" <expression>

// ============================================================================
// Binary Expressions (by precedence, lowest to highest)
// ============================================================================

<or-else-expression> ::= <or-expression> ("or" "else" <or-expression>)*
// "or else" is value coalescing for Option/Result types

<or-expression> ::= <and-then-expression> ("or" <and-then-expression>)*

<and-then-expression> ::= <and-expression> ("and" "then" <and-expression>)*
// "and then" is optional chaining / value transformation for Option/Result types

<and-expression> ::= <not-expression> ("and" <not-expression>)*
<not-expression> ::= "not" <bitwise-or-expression> | <bitwise-or-expression>

<bitwise-or-expression> ::= <bitwise-xor-expression> ("|" <bitwise-xor-expression>)*
<bitwise-xor-expression> ::= <bitwise-and-expression> ("^" <bitwise-and-expression>)*
<bitwise-and-expression> ::= <range-expression> ("&" <range-expression>)*

<range-expression> ::= <comparison-expression> <range-suffix>?
                     | <range-prefix> <comparison-expression>
                     | "...."

<range-suffix> ::= <range-op> <comparison-expression>
                 | <postfix-range-op>

<range-op> ::= ".." | "..<" | "<.." | "<..<"
<postfix-range-op> ::= "..." | "<..."
<range-prefix> ::= "..." | "...<"

<comparison-expression> ::= <shift-expression> (<comparison-op> <shift-expression>)*
<comparison-op> ::= "==" | "<>" | ">" | "<" | ">=" | "<="

<shift-expression> ::= <additive-expression> (<shift-op> <additive-expression>)*
<shift-op> ::= "<<" | ">>"

<additive-expression> ::= <multiplicative-expression> (<additive-op> <multiplicative-expression>)*
<additive-op> ::= "+" | "-"

<multiplicative-expression> ::= <prefix-expression> (<multiplicative-op> <prefix-expression>)*
<multiplicative-op> ::= "*" | "/" | "%"

// ============================================================================
// Prefix Expressions
// ============================================================================

<prefix-expression> ::= <cast-expression>
                      | "ref" <prefix-expression>
                      | "ptr" <prefix-expression>
                      | "deptr" <prefix-expression>
                      | "deref" <prefix-expression>
                      | "~" <prefix-expression>
                      | <postfix-expression>

<cast-expression> ::= "(" <type> ")" <prefix-expression>

// ============================================================================
// Postfix Expressions
// ============================================================================

<postfix-expression> ::= <primary-expression> <postfix-suffix>*
<postfix-suffix> ::= <call-suffix>
                   | <subscript-suffix>
                   | <member-suffix>

<call-suffix> ::= "(" <argument-list>? ")"
<subscript-suffix> ::= "[" <expression-list> "]"
<member-suffix> ::= "." <identifier>

<argument-list> ::= <expression> ("," <expression>)* ","?
<expression-list> ::= <expression> ("," <expression>)* ","?

// ============================================================================
// Primary Expressions
// ============================================================================

<primary-expression> ::= <literal>
                       | <identifier>
                       | "self"
                       | <implicit-member-expression>
                       | <generic-instantiation>
                       | <block-expression>
                       | <lambda-expression>
                       | "(" <expression> ")"

<generic-instantiation> ::= "[" <type-list> "]" <identifier>

<implicit-member-expression> ::= "." <identifier> ("(" <argument-list>? ")")?
// 隐式成员表达式：当期望类型已知时，可以省略类型名直接使用 .成员名
// 用于 union case 构造和静态方法调用
// 例如: .Some(42), .None(), .new(), .with_capacity(10)

<block-expression> ::= "{" <statement>* "}"

<lambda-expression> ::= "(" <lambda-param-list>? ")" <type-annotation>? "->" <expression>
<lambda-param-list> ::= <lambda-param> ("," <lambda-param>)* ","?
<lambda-param> ::= <identifier> <type-annotation>?
// Lambda expression examples:
//   () -> 42                           - no params
//   (x) -> x * 2                       - single param, type inferred
//   (x Int) -> x * 2                   - single param with type
//   (x, y) -> x + y                    - multiple params, types inferred
//   (x Int, y Int) Int -> x + y        - full type annotations
//   (x) -> { let y = x * 2; y + 1 }    - block body

// ============================================================================
// Patterns
// ============================================================================

<pattern> ::= <or-pattern>

<or-pattern> ::= <and-pattern> ("or" <and-pattern>)*
<and-pattern> ::= <not-pattern> ("and" <not-pattern>)*
<not-pattern> ::= "not" <not-pattern>
               | <primary-pattern>

<primary-pattern> ::= "_"                                     // wildcard
                    | "-"? <integer-literal>                  // integer literal pattern (including negative)
                    | <bool-literal>                          // bool literal pattern
                    | <string-literal>                        // string literal pattern
                    | "mut"? <identifier>                     // variable binding
                    | <struct-pattern>                        // struct destructuring pattern
                    | <comparison-pattern>                    // comparison pattern
                    | <union-case-pattern>                    // union case pattern
                    | "(" <pattern> ")"                       // parenthesized pattern (grouping)

<struct-pattern> ::= <type-identifier> "(" <pattern-list>? ")"
// Struct destructuring pattern: matches a struct value and destructures its fields by position.
// TypeName must refer to a struct type. The number of sub-patterns must match the number of fields.
// Sub-patterns can be any pattern (wildcard, variable binding, literal, nested struct, etc.)
// Examples:
//   Point(x, y)              - bind fields to x and y
//   Point(_, y)              - ignore first field, bind second
//   Point(0, y)              - match first field literally, bind second
//   Rect(Point(a, b), w, h)  - nested struct destructuring
//   Box(v)                   - works with generic structs (e.g., [Int]Box)

<comparison-pattern> ::= <comparison-op> "-"? <integer-literal>
// Comparison patterns: > n, < n, >= n, <= n (where n is an integer literal, optionally negative)

<union-case-pattern> ::= "." <identifier> ("(" <pattern-list>? ")")?
<pattern-list> ::= <pattern> ("," <pattern>)* ","?

// ============================================================================
// Literals
// ============================================================================

<literal> ::= <integer-literal>
            | <float-literal>
            | <string-literal>
            | <interpolated-string-literal>
            | <bool-literal>

<integer-literal> ::= <decimal-literal>
                  | <binary-literal>
                  | <octal-literal>
                  | <hex-literal>

<decimal-literal> ::= [0-9]+ ("_" [0-9]+)*
<binary-literal> ::= "0b" [0-1]+ ("_" [0-1]+)*
<octal-literal> ::= "0o" [0-7]+ ("_" [0-7]+)*
<hex-literal> ::= "0x" [0-9a-fA-F]+ ("_" [0-9a-fA-F]+)*

<float-literal> ::= [0-9]+ ("_" [0-9]+)* "." [0-9]+ ("_" [0-9]+)*

<string-literal> ::= '"' <string-char>* '"'
                   | "'" <string-char>* "'"

<interpolated-string-literal> ::= '"' (<string-char> | <interpolation>)* '"'
                                | "'" (<string-char> | <interpolation>)* "'"
<interpolation> ::= "\(" <expression> ")"

<string-char> ::= <escape-sequence> | ~["\\\n]
<escape-sequence> ::= "\\" ("n" | "t" | "r" | "v" | "f" | "0" | "\\" | '"' | "'")

<bool-literal> ::= "true" | "false"

<identifier> ::= [a-zA-Z_][a-zA-Z0-9_]*
<type-identifier> ::= [A-Z][a-zA-Z0-9_]*

// ============================================================================
// Keywords
// ============================================================================

// Reserved keywords:
//   let, mut, type, trait, given, intrinsic, foreign
//   using, self, Self, super
//   if, then, else, while, for, when, is
//   and, or, not
//   ref, deref, ptr, deptr, weakref
//   return, break, continue, defer, yield
//   true, false
//   public, private, protected

// ============================================================================
// Operators
// ============================================================================

// Arithmetic: + - * / %
// Comparison: == <> > < >= <=
// Logical: and or not
// Bitwise: & | ^ ~ << >>
// Assignment: = += -= *= /= %= &= |= ^= <<= >>=
// Range: .. ..< <.. <..< ... <... ...< ....
// Lambda: ->
// Value coalescing: or else
// Optional chaining: and then
// Other: . , ; : ( ) [ ] { }

// ============================================================================
// Comments
// ============================================================================

// Line comment: // ...
// Block comment: /* ... */

// ============================================================================
// Automatic Semicolon Insertion
// ============================================================================

// Koral uses newline-based statement termination with continuation rules:
// - Semicolons are optional at end of statements/declarations
// - A newline terminates a statement unless:
//   1. The next token is a continuation token (infix operators, dot, arrow)
//   2. The statement is inside parentheses, brackets, or braces
// - Blank lines and comments block line continuation
