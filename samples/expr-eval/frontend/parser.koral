// 表达式求值器 - 语法分析器

// 导入 types 模块
using super.types

public type Parser(
    tokens [types.Token]List,
    mut pos UInt,
)

given Parser {
    public new(tokens [types.Token]List) Parser = Parser(tokens, 0)

    private peek(self) types.Token = {
        if self.pos >= self.tokens.count() then {
            return types.Token.EOF()
        }
        return self.tokens[self.pos]
    }

    private peek_next(self) types.Token = {
        if self.pos + 1 >= self.tokens.count() then {
            return types.Token.EOF()
        }
        return self.tokens[self.pos + 1]
    }

    private advance(self ref) types.Token = {
        let token = self.peek()
        self.pos += 1
        return token
    }

    private check_plus(self) Bool = when self.peek() in { .Plus then true, _ then false }
    private check_minus(self) Bool = when self.peek() in { .Minus then true, _ then false }
    private check_star(self) Bool = when self.peek() in { .Star then true, _ then false }
    private check_slash(self) Bool = when self.peek() in { .Slash then true, _ then false }
    private check_percent(self) Bool = when self.peek() in { .Percent then true, _ then false }
    private check_power(self) Bool = when self.peek() in { .Power then true, _ then false }
    private check_left_paren(self) Bool = when self.peek() in { .LeftParen then true, _ then false }
    private check_right_paren(self) Bool = when self.peek() in { .RightParen then true, _ then false }
    private check_comma(self) Bool = when self.peek() in { .Comma then true, _ then false }
    private check_eof(self) Bool = when self.peek() in { .EOF then true, _ then false }

    private expect_right_paren(self ref) [Void]Result = {
        if self.check_right_paren() then {
            self.advance()
            return Result.Ok({})
        }

        let msg = String.zero()
        msg.push_string("Parse error: expected ')', found ")
        msg.push_string(self.peek().to_string())
        return Result.Error(ref msg)
    }

    public parse(self ref) [Expr ref]Result = {
        when self.parse_expression() in {
            .Ok(expr) then {
                if not self.check_eof() then {
                    let msg = String.zero()
                    msg.push_string("Parse error: unexpected token ")
                    msg.push_string(self.peek().to_string())
                    return Result.Error(ref msg)
                }
                return Result.Ok(expr)
            },
            .Error(e) then {
                return Result.Error(e)
            },
        }
    }

    private parse_expression(self ref) [Expr ref]Result = self.parse_assignment()

    private parse_assignment(self ref) [Expr ref]Result =
        when self.peek() in {
            .Identifier(name) then {
                if self.peek_next() is .Equals then {
                    self.advance()
                    self.advance()
                    yield when self.parse_assignment() in {
                        .Ok(value) then Result.Ok(ref Expr.Assignment(name, value)),
                        .Error(e) then Result.Error(e),
                    }
                }
                yield self.parse_additive()
            },
            _ then self.parse_additive(),
        }

    private parse_additive(self ref) [Expr ref]Result =
        when self.parse_multiplicative() in {
            .Ok(mut left) then {
                while self.check_plus() or self.check_minus() then {
                    let op = if self.check_plus() then BinaryOperator.Add() else BinaryOperator.Sub()
                    self.advance()
                    when self.parse_multiplicative() in {
                        .Ok(right) then { left = ref Expr.BinaryOp(op, left, right) },
                        .Error(e) then { return Result.Error(e) },
                    }
                }
                yield Result.Ok(left)
            },
            .Error(e) then Result.Error(e),
        }

    private parse_multiplicative(self ref) [Expr ref]Result =
        when self.parse_power() in {
            .Ok(mut left) then {
                while self.check_star() or self.check_slash() or self.check_percent() then {
                    let op = if self.check_star() then BinaryOperator.Mul()
                             else if self.check_slash() then BinaryOperator.Div()
                             else BinaryOperator.Mod()
                    self.advance()
                    when self.parse_power() in {
                        .Ok(right) then { left = ref Expr.BinaryOp(op, left, right) },
                        .Error(e) then { return Result.Error(e) },
                    }
                }
                yield Result.Ok(left)
            },
            .Error(e) then Result.Error(e),
        }
    

    private parse_power(self ref) [Expr ref]Result =
        when self.parse_unary() in {
            .Ok(left) then {
                if self.check_power() then {
                    self.advance()
                    yield when self.parse_power() in {
                        .Ok(right) then Result.Ok(ref Expr.BinaryOp(BinaryOperator.Pow(), left, right)),
                        .Error(e) then Result.Error(e),
                    }
                }
                yield Result.Ok(left)
            },
            .Error(e) then Result.Error(e),
        }

    private parse_unary(self ref) [Expr ref]Result =
        if self.check_minus() then {
            self.advance()
            yield when self.parse_unary() in {
                .Ok(operand) then Result.Ok(ref Expr.UnaryOp(UnaryOperator.Neg(), operand)),
                .Error(e) then Result.Error(e),
            }
        } else self.parse_call()

    private parse_call(self ref) [Expr ref]Result = {
        when self.parse_primary() in {
            .Ok(primary) then {
                when primary in {
                    .Variable(name) then {
                        if self.check_left_paren() then {
                            self.advance()
                            when self.parse_arguments() in {
                                .Ok(args) then {
                                    return when self.expect_right_paren() in {
                                        .Ok(_) then Result.Ok(ref Expr.FunctionCall(name, args)),
                                        .Error(e) then Result.Error(e),
                                    }
                                },
                                .Error(e) then {
                                    return Result.Error(e)
                                },
                            }
                        }

                        return Result.Ok(primary)
                    },
                    _ then {
                        return Result.Ok(primary)
                    },
                }
            },
            .Error(e) then {
                return Result.Error(e)
            },
        }
    }

    private parse_arguments(self ref) [[Expr ref]List]Result = {
        let args = [Expr ref]List.new()
        
        if self.check_right_paren() then {
            return Result.Ok(args)
        }

        return when self.parse_expression() in {
            .Ok(first) then {
                args.push(first)
                while self.check_comma() then {
                    self.advance()
                    when self.parse_expression() in {
                        .Ok(arg) then args.push(arg),
                        .Error(e) then { return Result.Error(e) },
                    }
                }
                yield Result.Ok(args)
            },
            .Error(e) then Result.Error(e),
        }
    }

    private parse_primary(self ref) [Expr ref]Result =
        when self.peek() in {
            .IntLiteral(v) then {
                self.advance()
                yield Result.Ok(ref Expr.Number(types.Value.IntVal(v)))
            },
            .FloatLiteral(v) then {
                self.advance()
                yield Result.Ok(ref Expr.Number(types.Value.FloatVal(v)))
            },
            .Identifier(name) then {
                self.advance()
                yield Result.Ok(ref Expr.Variable(name))
            },
            .LeftParen then {
                self.advance()
                yield when self.parse_expression() in {
                    .Ok(expr) then when self.expect_right_paren() in {
                        .Ok(_) then Result.Ok(expr),
                        .Error(e) then Result.Error(e),
                    },
                    .Error(e) then Result.Error(e),
                }
            },
            _ then {
                let msg = String.zero()
                msg.push_string("Parse error: unexpected token ")
                msg.push_string(self.peek().to_string())
                yield Result.Error(ref msg)
            },
        }
}
