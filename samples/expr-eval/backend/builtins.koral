// 表达式求值器 - 内置函数
using std.math.*

// 内置函数：abs - 绝对值
public let builtin_abs(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "abs() takes exactly 1 argument");
    }
    when args[0] is {
        .IntVal(x) then Result.Ok(types.Value.IntVal(abs(x))),
        .FloatVal(x) then Result.Ok(types.Value.FloatVal(fabs(x))),
    }
}

// 内置函数：sqrt - 平方根
public let builtin_sqrt(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "sqrt() takes exactly 1 argument");
    }
    let x = args[0].to_float()
    if x < 0.0 then Result.Error(ref "sqrt() argument must be non-negative")
    else Result.Ok(types.Value.FloatVal(sqrt(x)))
}

// 内置函数：min - 最小值
public let builtin_min(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 2 then {
        return Result.Error(ref "min() takes exactly 2 arguments");
    }
    let a = args[0]
    let b = args[1]
    if a.is_int() and b.is_int() then {
        when a is {
            .IntVal(av) then when b is {
                .IntVal(bv) then Result.Ok(types.Value.IntVal(min(av, bv))),
                _ then Result.Error(ref "unreachable"),
            },
            _ then Result.Error(ref "unreachable"),
        }
    } else {
        let af = a.to_float()
        let bf = b.to_float()
        Result.Ok(types.Value.FloatVal(min(af, bf)))
    }
}

// 内置函数：max - 最大值
public let builtin_max(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 2 then {
        return Result.Error(ref "max() takes exactly 2 arguments");
    }
    let a = args[0]
    let b = args[1]
    if a.is_int() and b.is_int() then {
        when a is {
            .IntVal(av) then when b is {
                .IntVal(bv) then Result.Ok(types.Value.IntVal(max(av, bv))),
                _ then Result.Error(ref "unreachable"),
            },
            _ then Result.Error(ref "unreachable"),
        }
    } else {
        let af = a.to_float()
        let bf = b.to_float()
        Result.Ok(types.Value.FloatVal(max(af, bf)))
    }
}

// 内置函数：floor - 向下取整
public let builtin_floor(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "floor() takes exactly 1 argument");
    }
    Result.Ok(types.Value.IntVal((Int)floor(args[0].to_float())))
}

// 内置函数：ceil - 向上取整
public let builtin_ceil(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "ceil() takes exactly 1 argument");
    }
    Result.Ok(types.Value.IntVal((Int)ceil(args[0].to_float())))
}

// 内置函数：round - 四舍五入
public let builtin_round(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "round() takes exactly 1 argument");
    }
    Result.Ok(types.Value.IntVal((Int)round(args[0].to_float())))
}

// 内置函数：sin
public let builtin_sin(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "sin() takes exactly 1 argument");
    }
    Result.Ok(types.Value.FloatVal(sin(args[0].to_float())))
}

// 内置函数：cos
public let builtin_cos(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "cos() takes exactly 1 argument");
    }
    Result.Ok(types.Value.FloatVal(cos(args[0].to_float())))
}

// 内置函数：tan
public let builtin_tan(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "tan() takes exactly 1 argument");
    }
    Result.Ok(types.Value.FloatVal(tan(args[0].to_float())))
}

// 内置函数：ln
public let builtin_ln(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "ln() takes exactly 1 argument");
    }
    let x = args[0].to_float()
    if x <= 0.0 then Result.Error(ref "ln() argument must be positive")
    else Result.Ok(types.Value.FloatVal(ln(x)))
}

// 内置函数：log2
public let builtin_log2(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "log2() takes exactly 1 argument");
    }
    let x = args[0].to_float()
    if x <= 0.0 then Result.Error(ref "log2() argument must be positive")
    else Result.Ok(types.Value.FloatVal(log2(x)))
}

// 内置函数：log10
public let builtin_log10(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "log10() takes exactly 1 argument");
    }
    let x = args[0].to_float()
    if x <= 0.0 then Result.Error(ref "log10() argument must be positive")
    else Result.Ok(types.Value.FloatVal(log10(x)))
}

// 内置函数：exp
public let builtin_exp(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "exp() takes exactly 1 argument");
    }
    Result.Ok(types.Value.FloatVal(exp(args[0].to_float())))
}

// 调用内置函数的分发器
public let call_builtin(name String, args [types.Value]List) [types.Value]Result = {
    if name == "abs" then builtin_abs(args)
    else if name == "sqrt" then builtin_sqrt(args)
    else if name == "min" then builtin_min(args)
    else if name == "max" then builtin_max(args)
    else if name == "floor" then builtin_floor(args)
    else if name == "ceil" then builtin_ceil(args)
    else if name == "round" then builtin_round(args)
    else if name == "sin" then builtin_sin(args)
    else if name == "cos" then builtin_cos(args)
    else if name == "tan" then builtin_tan(args)
    else if name == "ln" then builtin_ln(args)
    else if name == "log2" then builtin_log2(args)
    else if name == "log10" then builtin_log10(args)
    else if name == "exp" then builtin_exp(args)
    else {
        let msg = String.zero()
        msg.push_string("Unknown function: ")
        msg.push_string(name)
        Result.Error(ref msg)
    }
}
