// 表达式求值器 - 内置函数
using std.math.*

// 内置函数：abs - 绝对值
public let builtin_abs(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "abs() takes exactly 1 argument");
    }
    return when args[0] in {
        .IntVal(x) then Result.Ok(types.Value.IntVal(abs(x))),
        .FloatVal(x) then Result.Ok(types.Value.FloatVal(fabs(x))),
    }
}

// 内置函数：sqrt - 平方根
public let builtin_sqrt(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "sqrt() takes exactly 1 argument");
    }
    let x = args[0].to_float()
    if x < 0.0 then {
        return Result.Error(ref "sqrt() argument must be non-negative")
    }
    return Result.Ok(types.Value.FloatVal(sqrt(x)))
}

// 内置函数：min - 最小值
public let builtin_min(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 2 then {
        return Result.Error(ref "min() takes exactly 2 arguments");
    }
    let a = args[0]
    let b = args[1]
    if a.is_int() and b.is_int() then {
        return when a in {
            .IntVal(av) then when b in {
                .IntVal(bv) then Result.Ok(types.Value.IntVal(min(av, bv))),
                _ then Result.Error(ref "unreachable"),
            },
            _ then Result.Error(ref "unreachable"),
        }
    }
    let af = a.to_float()
    let bf = b.to_float()
    return Result.Ok(types.Value.FloatVal(min(af, bf)))
}

// 内置函数：max - 最大值
public let builtin_max(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 2 then {
        return Result.Error(ref "max() takes exactly 2 arguments");
    }
    let a = args[0]
    let b = args[1]
    if a.is_int() and b.is_int() then {
        return when a in {
            .IntVal(av) then when b in {
                .IntVal(bv) then Result.Ok(types.Value.IntVal(max(av, bv))),
                _ then Result.Error(ref "unreachable"),
            },
            _ then Result.Error(ref "unreachable"),
        }
    }
    let af = a.to_float()
    let bf = b.to_float()
    return Result.Ok(types.Value.FloatVal(max(af, bf)))
}

// 内置函数：floor - 向下取整
public let builtin_floor(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "floor() takes exactly 1 argument");
    }
    return Result.Ok(types.Value.IntVal((Int)floor(args[0].to_float())))
}

// 内置函数：ceil - 向上取整
public let builtin_ceil(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "ceil() takes exactly 1 argument");
    }
    return Result.Ok(types.Value.IntVal((Int)ceil(args[0].to_float())))
}

// 内置函数：round - 四舍五入
public let builtin_round(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "round() takes exactly 1 argument");
    }
    return Result.Ok(types.Value.IntVal((Int)round(args[0].to_float())))
}

// 内置函数：sin
public let builtin_sin(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "sin() takes exactly 1 argument");
    }
    return Result.Ok(types.Value.FloatVal(sin(args[0].to_float())))
}

// 内置函数：cos
public let builtin_cos(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "cos() takes exactly 1 argument");
    }
    return Result.Ok(types.Value.FloatVal(cos(args[0].to_float())))
}

// 内置函数：tan
public let builtin_tan(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "tan() takes exactly 1 argument");
    }
    return Result.Ok(types.Value.FloatVal(tan(args[0].to_float())))
}

// 内置函数：ln
public let builtin_ln(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "ln() takes exactly 1 argument");
    }
    let x = args[0].to_float()
    if x <= 0.0 then {
        return Result.Error(ref "ln() argument must be positive")
    }
    return Result.Ok(types.Value.FloatVal(ln(x)))
}

// 内置函数：log2
public let builtin_log2(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "log2() takes exactly 1 argument");
    }
    let x = args[0].to_float()
    if x <= 0.0 then {
        return Result.Error(ref "log2() argument must be positive")
    }
    return Result.Ok(types.Value.FloatVal(log2(x)))
}

// 内置函数：log10
public let builtin_log10(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "log10() takes exactly 1 argument");
    }
    let x = args[0].to_float()
    if x <= 0.0 then {
        return Result.Error(ref "log10() argument must be positive")
    }
    return Result.Ok(types.Value.FloatVal(log10(x)))
}

// 内置函数：exp
public let builtin_exp(args [types.Value]List) [types.Value]Result = {
    if args.count() <> 1 then {
        return Result.Error(ref "exp() takes exactly 1 argument");
    }
    return Result.Ok(types.Value.FloatVal(exp(args[0].to_float())))
}

// 调用内置函数的分发器
public let call_builtin(name String, args [types.Value]List) [types.Value]Result = {
    if name == "abs" then { return builtin_abs(args) }
    else if name == "sqrt" then { return builtin_sqrt(args) }
    else if name == "min" then { return builtin_min(args) }
    else if name == "max" then { return builtin_max(args) }
    else if name == "floor" then { return builtin_floor(args) }
    else if name == "ceil" then { return builtin_ceil(args) }
    else if name == "round" then { return builtin_round(args) }
    else if name == "sin" then { return builtin_sin(args) }
    else if name == "cos" then { return builtin_cos(args) }
    else if name == "tan" then { return builtin_tan(args) }
    else if name == "ln" then { return builtin_ln(args) }
    else if name == "log2" then { return builtin_log2(args) }
    else if name == "log10" then { return builtin_log10(args) }
    else if name == "exp" then { return builtin_exp(args) }

    let msg = String.zero()
    msg.push_string("Unknown function: ")
    msg.push_string(name)
    return Result.Error(ref msg)
}
