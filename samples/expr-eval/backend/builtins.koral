// 表达式求值器 - 内置函数

// 内置函数：abs - 绝对值
public let builtin_abs(args [types.Value]List) [types.Value, String]Result = {
    if args.count() <> 1 then {
        return Result.Error("abs() takes exactly 1 argument");
    }
    when args[0] is {
        .IntVal(x) then Result.Ok(types.Value.IntVal(math_abs_int(x))),
        .FloatVal(x) then Result.Ok(types.Value.FloatVal(math_abs_float(x))),
    }
}

// 内置函数：sqrt - 平方根
public let builtin_sqrt(args [types.Value]List) [types.Value, String]Result = {
    if args.count() <> 1 then {
        return Result.Error("sqrt() takes exactly 1 argument");
    }
    let x = args[0].to_float()
    if x < 0.0 then Result.Error("sqrt() argument must be non-negative")
    else Result.Ok(types.Value.FloatVal(math_sqrt(x)))
}

// 内置函数：min - 最小值
public let builtin_min(args [types.Value]List) [types.Value, String]Result = {
    if args.count() <> 2 then {
        return Result.Error("min() takes exactly 2 arguments");
    }
    let a = args[0]
    let b = args[1]
    if a.is_int() and b.is_int() then {
        when a is {
            .IntVal(av) then when b is {
                .IntVal(bv) then Result.Ok(types.Value.IntVal(if av < bv then av else bv)),
                _ then Result.Error("unreachable"),
            },
            _ then Result.Error("unreachable"),
        }
    } else {
        let af = a.to_float()
        let bf = b.to_float()
        Result.Ok(types.Value.FloatVal(if af < bf then af else bf))
    }
}

// 内置函数：max - 最大值
public let builtin_max(args [types.Value]List) [types.Value, String]Result = {
    if args.count() <> 2 then {
        return Result.Error("max() takes exactly 2 arguments");
    }
    let a = args[0]
    let b = args[1]
    if a.is_int() and b.is_int() then {
        when a is {
            .IntVal(av) then when b is {
                .IntVal(bv) then Result.Ok(types.Value.IntVal(if av > bv then av else bv)),
                _ then Result.Error("unreachable"),
            },
            _ then Result.Error("unreachable"),
        }
    } else {
        let af = a.to_float()
        let bf = b.to_float()
        Result.Ok(types.Value.FloatVal(if af > bf then af else bf))
    }
}

// 内置函数：floor - 向下取整
public let builtin_floor(args [types.Value]List) [types.Value, String]Result = {
    if args.count() <> 1 then {
        return Result.Error("floor() takes exactly 1 argument");
    }
    Result.Ok(types.Value.IntVal(math_floor(args[0].to_float())))
}

// 内置函数：ceil - 向上取整
public let builtin_ceil(args [types.Value]List) [types.Value, String]Result = {
    if args.count() <> 1 then {
        return Result.Error("ceil() takes exactly 1 argument");
    }
    Result.Ok(types.Value.IntVal(math_ceil(args[0].to_float())))
}

// 内置函数：round - 四舍五入
public let builtin_round(args [types.Value]List) [types.Value, String]Result = {
    if args.count() <> 1 then {
        return Result.Error("round() takes exactly 1 argument");
    }
    Result.Ok(types.Value.IntVal(math_round(args[0].to_float())))
}

// 调用内置函数的分发器
public let call_builtin(name String, args [types.Value]List) [types.Value, String]Result = {
    if name == "abs" then builtin_abs(args)
    else if name == "sqrt" then builtin_sqrt(args)
    else if name == "min" then builtin_min(args)
    else if name == "max" then builtin_max(args)
    else if name == "floor" then builtin_floor(args)
    else if name == "ceil" then builtin_ceil(args)
    else if name == "round" then builtin_round(args)
    else {
        let msg = String.empty()
        msg.push_string("Unknown function: ")
        msg.push_string(name)
        Result.Error(msg)
    }
}
