// ============================================================================
// Koral Standard Library - Rune Type
// ============================================================================
// NOTE: This file is merged into core.koral, so primitives, traits, and option are already available.
// ============================================================================

// ============================================================================
// Rune Type - Unicode Code Point
// ============================================================================

// Unicode code point wrapper type (0x0000 to 0x10FFFF)
public type Rune(value UInt32)

given Rune {
    // Unicode replacement character U+FFFD
    public replacement_char() Rune = Rune(65533)

    // Constructor from UInt32
    public from_uint32(value UInt32) Rune = Rune(value)

    // Get internal UInt32 value
    public to_uint32(self) UInt32 = self.value
}

given Rune Eq {
    public equals(self, other Rune) Bool = self.value == other.value
}

given Rune Ord {
    public compare(self, other Rune) Int =
        if self.value < other.value then 0 - 1 else if self.value > other.value then 1 else 0
}

// ============================================================================
// Rune UTF-8 Encoding Methods
// ============================================================================
given Rune {
    // Check if rune is valid Unicode code point
    public is_valid(self) Bool = {
        let cp = self.value
        // Valid range: 0x0000-0x10FFFF, excluding surrogates 0xD800-0xDFFF
        return cp <= 1114111 and (cp < 55296 or cp > 57343)
    }

    // Return number of bytes needed to encode this rune in UTF-8
    public byte_count(self) UInt = {
        let cp = self.value
        if not self.is_valid() then {
            return 3
        } // Replacement char length
        return if cp < 128 then (UInt)1 else if cp < 2048 then (UInt)2 else if cp < 65536 then (UInt)3 else (UInt)4
    }

    // Convert rune to UTF-8 encoded string
    public to_string(self) String = {
        let cp = self.value

        // Handle invalid code points - return replacement character
        if not self.is_valid() then {
            let data = [UInt8]alloc_memory(4)
            init_memory(data + 0, 239) // 0xEF
            init_memory(data + 1, 191) // 0xBF
            init_memory(data + 2, 189) // 0xBD
            init_memory(data + 3, 0)
            let storage = ref StringStorage(data, 3, 4)
            return String(storage)
        }

        // 1-byte sequence (ASCII)
        if cp < 128 then {
            let data = [UInt8]alloc_memory(2)
            init_memory(data + 0, (UInt8)cp)
            init_memory(data + 1, 0)
            let storage = ref StringStorage(data, 1, 2)
            return String(storage)
        }

        // 2-byte sequence
        if cp < 2048 then {
            let data = [UInt8]alloc_memory(3)
            init_memory(data + 0, (UInt8)(cp >> 6) | 192)
            init_memory(data + 1, (UInt8)(cp & 63) | 128)
            init_memory(data + 2, 0)
            let storage = ref StringStorage(data, 2, 3)
            return String(storage)
        }

        // 3-byte sequence
        if cp < 65536 then {
            let data = [UInt8]alloc_memory(4)
            init_memory(data + 0, (UInt8)(cp >> 12) | 224)
            init_memory(data + 1, (UInt8)((cp >> 6) & 63) | 128)
            init_memory(data + 2, (UInt8)(cp & 63) | 128)
            init_memory(data + 3, 0)
            let storage = ref StringStorage(data, 3, 4)
            return String(storage)
        }

        // 4-byte sequence
        let data = [UInt8]alloc_memory(5)
        init_memory(data + 0, (UInt8)(cp >> 18) | 240)
        init_memory(data + 1, (UInt8)((cp >> 12) & 63) | 128)
        init_memory(data + 2, (UInt8)((cp >> 6) & 63) | 128)
        init_memory(data + 3, (UInt8)(cp & 63) | 128)
        init_memory(data + 4, 0)
        let storage = ref StringStorage(data, 4, 5)
        return String(storage)
    }
}

// ============================================================================
// Rune Character Classification Methods
// ============================================================================
given Rune {
    // Check if rune is in ASCII range (0x00-0x7F)
    public is_ascii(self) Bool = self.value < 128

    // Check if rune is ASCII digit (0-9)
    public is_ascii_digit(self) Bool = {
        let cp = self.value
        return cp >= 48 and cp <= 57 // '0' to '9'
    }

    // Check if rune is ASCII whitespace
    public is_ascii_whitespace(self) Bool = {
        let cp = self.value
        return cp == 32 or // Space
        cp == 9 or // Tab
        cp == 10 or // LF
        cp == 13 or // CR
        cp == 12 or // Form feed
        cp == 11 // Vertical tab
    }

    // Check if rune is ASCII letter (A-Z, a-z)
    public is_ascii_letter(self) Bool = {
        let cp = self.value
        return (cp >= 65 and cp <= 90) or // A-Z
        (cp >= 97 and cp <= 122) // a-z
    }

    // Check if rune is ASCII alphanumeric
    public is_ascii_alphanumeric(self) Bool =
        self.is_ascii_letter() or self.is_ascii_digit()
}

given Rune {
    // Check if rune is Unicode letter (simplified: ASCII + Latin Extended + CJK)
    public is_letter(self) Bool = {
        let cp = self.value
        // ASCII letters
        if (cp >= 65 and cp <= 90) or (cp >= 97 and cp <= 122) then {
            return true
        }
        // Latin Extended-A, Extended-B, and more (0x00C0-0x024F)
        if cp >= 192 and cp <= 591 then {
            return true
        }
        // CJK Unified Ideographs (0x4E00-0x9FFF)
        if cp >= 19968 and cp <= 40959 then {
            return true
        }
        // CJK Extension A (0x3400-0x4DBF)
        if cp >= 13312 and cp <= 19903 then {
            return true
        }
        // Hiragana (0x3040-0x309F)
        if cp >= 12352 and cp <= 12447 then {
            return true
        }
        // Katakana (0x30A0-0x30FF)
        if cp >= 12448 and cp <= 12543 then {
            return true
        }
        // Hangul Syllables (0xAC00-0xD7AF)
        if cp >= 44032 and cp <= 55215 then {
            return true
        }
        // Greek (0x0370-0x03FF)
        if cp >= 880 and cp <= 1023 then {
            return true
        }
        // Cyrillic (0x0400-0x04FF)
        if cp >= 1024 and cp <= 1279 then {
            return true
        }
        return false
    }

    // Check if rune is Unicode digit (simplified: ASCII digits only for now)
    public is_digit(self) Bool = self.is_ascii_digit()

    // Check if rune is Unicode whitespace
    public is_whitespace(self) Bool = {
        let cp = self.value
        // ASCII whitespace
        if self.is_ascii_whitespace() then {
            return true
        }
        // NEL (Next Line)
        if cp == 133 then {
            return true
        }
        // NBSP (No-Break Space)
        if cp == 160 then {
            return true
        }
        // Various Unicode spaces (0x2000-0x200A)
        if cp >= 8192 and cp <= 8202 then {
            return true
        }
        // Line Separator
        if cp == 8232 then {
            return true
        }
        // Paragraph Separator
        if cp == 8233 then {
            return true
        }
        // Narrow No-Break Space
        if cp == 8239 then {
            return true
        }
        // Medium Mathematical Space
        if cp == 8287 then {
            return true
        }
        // Ideographic Space
        if cp == 12288 then {
            return true
        }
        return false
    }

    // Check if rune is newline character
    public is_newline(self) Bool = {
        let cp = self.value
        return cp == 10 or // LF
        cp == 13 or // CR
        cp == 133 or // NEL (Next Line)
        cp == 8232 or // Line Separator
        cp == 8233 // Paragraph Separator
    }
}

given Rune {
    // Check if rune can start an identifier (letter or underscore)
    public is_identifier_start(self) Bool = {
        let cp = self.value
        // Underscore
        if cp == 95 then {
            return true
        }
        // Letter
        return self.is_letter()
    }

    // Check if rune can continue an identifier (letter, digit, or underscore)
    public is_identifier_continue(self) Bool = {
        let cp = self.value
        // Underscore
        if cp == 95 then {
            return true
        }
        // Letter or digit
        return self.is_letter() or self.is_digit()
    }
}
