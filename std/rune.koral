// ============================================================================
// Koral Standard Library - Rune Type
// ============================================================================
// NOTE: This file is merged into core.koral, so primitives, traits, and option are already available.
// ============================================================================

// ============================================================================
// Rune Type - Unicode Code Point
// ============================================================================

// Unicode code point wrapper type (0x0000 to 0x10FFFF)
public type Rune(value UInt32)

given Rune {
    // Unicode replacement character U+FFFD
    public replacement_char() Rune = Rune((UInt32)65533)
    
    // Constructor from UInt32
    public from_uint32(value UInt32) Rune = Rune(value)
    
    // Get internal UInt32 value
    public to_uint32(self) UInt32 = self.value
    
    // Eq comparison
    public equals(self, other Rune) Bool = self.value == other.value
    
    // Ord comparison
    public compare(self, other Rune) Int = {
        if self.value < other.value then 0 - 1
        else if self.value > other.value then 1
        else 0
    }
}


// ============================================================================
// Rune UTF-8 Encoding Methods
// ============================================================================

given Rune {
    // Check if rune is valid Unicode code point
    public is_valid(self) Bool = {
        let cp = self.value
        // Valid range: 0x0000-0x10FFFF, excluding surrogates 0xD800-0xDFFF
        cp <= (UInt32)1114111 and (cp < (UInt32)55296 or cp > (UInt32)57343)
    }
    
    // Return number of bytes needed to encode this rune in UTF-8
    public byte_count(self) Int = {
        let cp = self.value
        if not self.is_valid() then { return 3; }  // Replacement char length
        if cp < (UInt32)128 then 1
        else if cp < (UInt32)2048 then 2
        else if cp < (UInt32)65536 then 3
        else 4
    }
    
    // Convert rune to UTF-8 encoded string
    public to_string(self) String = {
        let cp = self.value
        
        // Handle invalid code points - return replacement character
        if not self.is_valid() then {
            let data = [UInt8]alloc_memory(4)
            init_memory(offset_ptr(data, 0), (UInt8)239)   // 0xEF
            init_memory(offset_ptr(data, 1), (UInt8)191)   // 0xBF
            init_memory(offset_ptr(data, 2), (UInt8)189)   // 0xBD
            init_memory(offset_ptr(data, 3), (UInt8)0)
            let storage = ref StringStorage(data, 3, 4)
            return String(storage)
        }
        
        // 1-byte sequence (ASCII)
        if cp < (UInt32)128 then {
            let data = [UInt8]alloc_memory(2)
            init_memory(offset_ptr(data, 0), (UInt8)cp)
            init_memory(offset_ptr(data, 1), (UInt8)0)
            let storage = ref StringStorage(data, 1, 2)
            return String(storage)
        }
        
        // 2-byte sequence
        if cp < (UInt32)2048 then {
            let data = [UInt8]alloc_memory(3)
            init_memory(offset_ptr(data, 0), (UInt8){ cp >> 6 } | (UInt8)192)
            init_memory(offset_ptr(data, 1), (UInt8){ cp & (UInt32)63 } | (UInt8)128)
            init_memory(offset_ptr(data, 2), (UInt8)0)
            let storage = ref StringStorage(data, 2, 3)
            return String(storage)
        }
        
        // 3-byte sequence
        if cp < (UInt32)65536 then {
            let data = [UInt8]alloc_memory(4)
            init_memory(offset_ptr(data, 0), (UInt8){ cp >> 12 } | (UInt8)224)
            init_memory(offset_ptr(data, 1), (UInt8){ { cp >> 6 } & (UInt32)63 } | (UInt8)128)
            init_memory(offset_ptr(data, 2), (UInt8){ cp & (UInt32)63 } | (UInt8)128)
            init_memory(offset_ptr(data, 3), (UInt8)0)
            let storage = ref StringStorage(data, 3, 4)
            return String(storage)
        }
        
        // 4-byte sequence
        let data = [UInt8]alloc_memory(5)
        init_memory(offset_ptr(data, 0), (UInt8){ cp >> 18 } | (UInt8)240)
        init_memory(offset_ptr(data, 1), (UInt8){ { cp >> 12 } & (UInt32)63 } | (UInt8)128)
        init_memory(offset_ptr(data, 2), (UInt8){ { cp >> 6 } & (UInt32)63 } | (UInt8)128)
        init_memory(offset_ptr(data, 3), (UInt8){ cp & (UInt32)63 } | (UInt8)128)
        init_memory(offset_ptr(data, 4), (UInt8)0)
        let storage = ref StringStorage(data, 4, 5)
        String(storage)
    }
}


// ============================================================================
// Rune Character Classification Methods
// ============================================================================

given Rune {
    // Check if rune is in ASCII range (0x00-0x7F)
    public is_ascii(self) Bool = self.value < (UInt32)128
    
    // Check if rune is ASCII digit (0-9)
    public is_ascii_digit(self) Bool = {
        let cp = self.value
        cp >= (UInt32)48 and cp <= (UInt32)57  // '0' to '9'
    }
    
    // Check if rune is ASCII whitespace
    public is_ascii_whitespace(self) Bool = {
        let cp = self.value
        cp == (UInt32)32 or   // Space
        cp == (UInt32)9 or    // Tab
        cp == (UInt32)10 or   // LF
        cp == (UInt32)13 or   // CR
        cp == (UInt32)12 or   // Form feed
        cp == (UInt32)11      // Vertical tab
    }
    
    // Check if rune is ASCII letter (A-Z, a-z)
    public is_ascii_letter(self) Bool = {
        let cp = self.value
        (cp >= (UInt32)65 and cp <= (UInt32)90) or   // A-Z
        (cp >= (UInt32)97 and cp <= (UInt32)122)     // a-z
    }
    
    // Check if rune is ASCII alphanumeric
    public is_ascii_alphanumeric(self) Bool = 
        self.is_ascii_letter() or self.is_ascii_digit()
}


given Rune {
    // Check if rune is Unicode letter (simplified: ASCII + Latin Extended + CJK)
    public is_letter(self) Bool = {
        let cp = self.value
        // ASCII letters
        if (cp >= (UInt32)65 and cp <= (UInt32)90) or (cp >= (UInt32)97 and cp <= (UInt32)122) then {
            return true
        }
        // Latin Extended-A, Extended-B, and more (0x00C0-0x024F)
        if cp >= (UInt32)192 and cp <= (UInt32)591 then { return true; }
        // CJK Unified Ideographs (0x4E00-0x9FFF)
        if cp >= (UInt32)19968 and cp <= (UInt32)40959 then { return true; }
        // CJK Extension A (0x3400-0x4DBF)
        if cp >= (UInt32)13312 and cp <= (UInt32)19903 then { return true; }
        // Hiragana (0x3040-0x309F)
        if cp >= (UInt32)12352 and cp <= (UInt32)12447 then { return true; }
        // Katakana (0x30A0-0x30FF)
        if cp >= (UInt32)12448 and cp <= (UInt32)12543 then { return true; }
        // Hangul Syllables (0xAC00-0xD7AF)
        if cp >= (UInt32)44032 and cp <= (UInt32)55215 then { return true; }
        // Greek (0x0370-0x03FF)
        if cp >= (UInt32)880 and cp <= (UInt32)1023 then { return true; }
        // Cyrillic (0x0400-0x04FF)
        if cp >= (UInt32)1024 and cp <= (UInt32)1279 then { return true; }
        false
    }
    
    // Check if rune is Unicode digit (simplified: ASCII digits only for now)
    public is_digit(self) Bool = self.is_ascii_digit()
    
    // Check if rune is Unicode whitespace
    public is_whitespace(self) Bool = {
        let cp = self.value
        // ASCII whitespace
        if self.is_ascii_whitespace() then { return true; }
        // NEL (Next Line)
        if cp == (UInt32)133 then { return true; }
        // NBSP (No-Break Space)
        if cp == (UInt32)160 then { return true; }
        // Various Unicode spaces (0x2000-0x200A)
        if cp >= (UInt32)8192 and cp <= (UInt32)8202 then { return true; }
        // Line Separator
        if cp == (UInt32)8232 then { return true; }
        // Paragraph Separator
        if cp == (UInt32)8233 then { return true; }
        // Narrow No-Break Space
        if cp == (UInt32)8239 then { return true; }
        // Medium Mathematical Space
        if cp == (UInt32)8287 then { return true; }
        // Ideographic Space
        if cp == (UInt32)12288 then { return true; }
        false
    }
    
    // Check if rune is newline character
    public is_newline(self) Bool = {
        let cp = self.value
        cp == (UInt32)10 or   // LF
        cp == (UInt32)13 or   // CR
        cp == (UInt32)133 or  // NEL (Next Line)
        cp == (UInt32)8232 or // Line Separator
        cp == (UInt32)8233    // Paragraph Separator
    }
}


given Rune {
    // Check if rune can start an identifier (letter or underscore)
    public is_identifier_start(self) Bool = {
        let cp = self.value
        // Underscore
        if cp == (UInt32)95 then { return true; }
        // Letter
        self.is_letter()
    }
    
    // Check if rune can continue an identifier (letter, digit, or underscore)
    public is_identifier_continue(self) Bool = {
        let cp = self.value
        // Underscore
        if cp == (UInt32)95 then { return true; }
        // Letter or digit
        self.is_letter() or self.is_digit()
    }
}
