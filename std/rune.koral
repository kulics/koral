// ============================================================================
// Koral Standard Library - Rune Type
// ============================================================================
// NOTE: This file is merged into core.koral, so primitives, traits, and option are already available.
// ============================================================================

// ============================================================================
// Rune Type - Unicode Code Point
// ============================================================================

// Unicode code point wrapper type (0x0000 to 0x10FFFF)
public type Rune(value UInt32)

given Rune {
    // Unicode replacement character U+FFFD
    public replacement_char() Rune = Rune(65533u32)
    
    // Constructor from UInt32
    public from_uint32(value UInt32) Rune = Rune(value)
    
    // Get internal UInt32 value
    public to_uint32(self) UInt32 = self.value
    
    // Equality comparison
    public equals(self, other Rune) Bool = self.value == other.value
    
    // Ordering comparison
    public compare(self, other Rune) Int = {
        if self.value < other.value then 0 - 1
        else if self.value > other.value then 1
        else 0
    }
}


// ============================================================================
// Rune UTF-8 Encoding Methods
// ============================================================================

given Rune {
    // Check if rune is valid Unicode code point
    public is_valid(self) Bool = {
        let cp = self.value
        // Valid range: 0x0000-0x10FFFF, excluding surrogates 0xD800-0xDFFF
        cp <= 1114111u32 and (cp < 55296u32 or cp > 57343u32)
    }
    
    // Return number of bytes needed to encode this rune in UTF-8
    public byte_count(self) Int = {
        let cp = self.value
        if not self.is_valid() then { return 3; }  // Replacement char length
        if cp < 128u32 then 1
        else if cp < 2048u32 then 2
        else if cp < 65536u32 then 3
        else 4
    }
    
    // Convert rune to UTF-8 encoded string
    public to_string(self) String = {
        let cp = self.value
        
        // Handle invalid code points - return replacement character
        if not self.is_valid() then {
            let data = [UInt8]alloc_memory(4)
            init_memory(offset_ptr(data, 0), 239u8)   // 0xEF
            init_memory(offset_ptr(data, 1), 191u8)   // 0xBF
            init_memory(offset_ptr(data, 2), 189u8)   // 0xBD
            init_memory(offset_ptr(data, 3), 0u8)
            let storage = ref StringStorage(data, 3, 4)
            return String(storage)
        }
        
        // 1-byte sequence (ASCII)
        if cp < 128u32 then {
            let data = [UInt8]alloc_memory(2)
            init_memory(offset_ptr(data, 0), (UInt8)cp)
            init_memory(offset_ptr(data, 1), 0u8)
            let storage = ref StringStorage(data, 1, 2)
            return String(storage)
        }
        
        // 2-byte sequence
        if cp < 2048u32 then {
            let data = [UInt8]alloc_memory(3)
            init_memory(offset_ptr(data, 0), (UInt8){ cp >> 6 } | 192u8)
            init_memory(offset_ptr(data, 1), (UInt8){ cp & 63u32 } | 128u8)
            init_memory(offset_ptr(data, 2), 0u8)
            let storage = ref StringStorage(data, 2, 3)
            return String(storage)
        }
        
        // 3-byte sequence
        if cp < 65536u32 then {
            let data = [UInt8]alloc_memory(4)
            init_memory(offset_ptr(data, 0), (UInt8){ cp >> 12 } | 224u8)
            init_memory(offset_ptr(data, 1), (UInt8){ { cp >> 6 } & 63u32 } | 128u8)
            init_memory(offset_ptr(data, 2), (UInt8){ cp & 63u32 } | 128u8)
            init_memory(offset_ptr(data, 3), 0u8)
            let storage = ref StringStorage(data, 3, 4)
            return String(storage)
        }
        
        // 4-byte sequence
        let data = [UInt8]alloc_memory(5)
        init_memory(offset_ptr(data, 0), (UInt8){ cp >> 18 } | 240u8)
        init_memory(offset_ptr(data, 1), (UInt8){ { cp >> 12 } & 63u32 } | 128u8)
        init_memory(offset_ptr(data, 2), (UInt8){ { cp >> 6 } & 63u32 } | 128u8)
        init_memory(offset_ptr(data, 3), (UInt8){ cp & 63u32 } | 128u8)
        init_memory(offset_ptr(data, 4), 0u8)
        let storage = ref StringStorage(data, 4, 5)
        String(storage)
    }
}


// ============================================================================
// Rune Character Classification Methods
// ============================================================================

given Rune {
    // Check if rune is in ASCII range (0x00-0x7F)
    public is_ascii(self) Bool = self.value < 128u32
    
    // Check if rune is ASCII digit (0-9)
    public is_ascii_digit(self) Bool = {
        let cp = self.value
        cp >= 48u32 and cp <= 57u32  // '0' to '9'
    }
    
    // Check if rune is ASCII whitespace
    public is_ascii_whitespace(self) Bool = {
        let cp = self.value
        cp == 32u32 or   // Space
        cp == 9u32 or    // Tab
        cp == 10u32 or   // LF
        cp == 13u32 or   // CR
        cp == 12u32 or   // Form feed
        cp == 11u32      // Vertical tab
    }
    
    // Check if rune is ASCII letter (A-Z, a-z)
    public is_ascii_letter(self) Bool = {
        let cp = self.value
        (cp >= 65u32 and cp <= 90u32) or   // A-Z
        (cp >= 97u32 and cp <= 122u32)     // a-z
    }
    
    // Check if rune is ASCII alphanumeric
    public is_ascii_alphanumeric(self) Bool = 
        self.is_ascii_letter() or self.is_ascii_digit()
}


given Rune {
    // Check if rune is Unicode letter (simplified: ASCII + Latin Extended + CJK)
    public is_letter(self) Bool = {
        let cp = self.value
        // ASCII letters
        if (cp >= 65u32 and cp <= 90u32) or (cp >= 97u32 and cp <= 122u32) then {
            return true
        }
        // Latin Extended-A, Extended-B, and more (0x00C0-0x024F)
        if cp >= 192u32 and cp <= 591u32 then { return true; }
        // CJK Unified Ideographs (0x4E00-0x9FFF)
        if cp >= 19968u32 and cp <= 40959u32 then { return true; }
        // CJK Extension A (0x3400-0x4DBF)
        if cp >= 13312u32 and cp <= 19903u32 then { return true; }
        // Hiragana (0x3040-0x309F)
        if cp >= 12352u32 and cp <= 12447u32 then { return true; }
        // Katakana (0x30A0-0x30FF)
        if cp >= 12448u32 and cp <= 12543u32 then { return true; }
        // Hangul Syllables (0xAC00-0xD7AF)
        if cp >= 44032u32 and cp <= 55215u32 then { return true; }
        // Greek (0x0370-0x03FF)
        if cp >= 880u32 and cp <= 1023u32 then { return true; }
        // Cyrillic (0x0400-0x04FF)
        if cp >= 1024u32 and cp <= 1279u32 then { return true; }
        false
    }
    
    // Check if rune is Unicode digit (simplified: ASCII digits only for now)
    public is_digit(self) Bool = self.is_ascii_digit()
    
    // Check if rune is Unicode whitespace
    public is_whitespace(self) Bool = {
        let cp = self.value
        // ASCII whitespace
        if self.is_ascii_whitespace() then { return true; }
        // NEL (Next Line)
        if cp == 133u32 then { return true; }
        // NBSP (No-Break Space)
        if cp == 160u32 then { return true; }
        // Various Unicode spaces (0x2000-0x200A)
        if cp >= 8192u32 and cp <= 8202u32 then { return true; }
        // Line Separator
        if cp == 8232u32 then { return true; }
        // Paragraph Separator
        if cp == 8233u32 then { return true; }
        // Narrow No-Break Space
        if cp == 8239u32 then { return true; }
        // Medium Mathematical Space
        if cp == 8287u32 then { return true; }
        // Ideographic Space
        if cp == 12288u32 then { return true; }
        false
    }
    
    // Check if rune is newline character
    public is_newline(self) Bool = {
        let cp = self.value
        cp == 10u32 or   // LF
        cp == 13u32 or   // CR
        cp == 133u32 or  // NEL (Next Line)
        cp == 8232u32 or // Line Separator
        cp == 8233u32    // Paragraph Separator
    }
}


given Rune {
    // Check if rune can start an identifier (letter or underscore)
    public is_identifier_start(self) Bool = {
        let cp = self.value
        // Underscore
        if cp == 95u32 then { return true; }
        // Letter
        self.is_letter()
    }
    
    // Check if rune can continue an identifier (letter, digit, or underscore)
    public is_identifier_continue(self) Bool = {
        let cp = self.value
        // Underscore
        if cp == 95u32 then { return true; }
        // Letter or digit
        self.is_letter() or self.is_digit()
    }
}
