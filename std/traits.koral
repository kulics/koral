// ============================================================================
// Koral Standard Library - Traits
// ============================================================================
// NOTE: This file is merged into core.koral, so primitives are already available.
// ============================================================================

// ============================================================================
// Core Traits
// ============================================================================

public trait Equality {
    equals(self, other Self) Bool
}

public trait Ordering Equality {
    compare(self, other Self) Int
}

// Hash utilities
public let combine_hash(seed UInt, value UInt) UInt = {
    let magic UInt = 2654435769  // 0x9e3779b9
    seed ^ {value + magic + {seed << 6} + {seed >> 2}}
}

public trait Hashable Equality {
    hash(self) UInt
}

public trait ToString {
    to_string(self) String
}

// Generic Iterator trait for for-loop support
public trait [T Any]Iterator {
    next(self ref) [T]Option
}

// Iterable trait - types that can produce an iterator
public trait [T Any, R [T]Iterator]Iterable {
    iterator(self) R
}

// ============================================================================
// Algebraic and Indexing Traits (Operator Lowering)
// ============================================================================

public trait [K Any, V Any]Index {
    at(self, key K) V
}

public trait [K Any, V Any]MutableIndex {
    update_at(self ref, key K, value V) Void
}

public trait AdditiveSemigroup {
    add(self, other Self) Self
}

public trait AdditiveMonoid AdditiveSemigroup {
    zero() Self
}

public trait AdditiveGroup AdditiveMonoid {
    neg(self) Self
    // Optional fast path for subtraction
    sub(self, other Self) Self
}

public trait MultiplicativeSemigroup {
    mul(self, other Self) Self
}

public trait MultiplicativeMonoid MultiplicativeSemigroup {
    one() Self
}

public trait Divisible {
    div(self, other Self) Self
}

public trait Remainder {
    rem(self, other Self) Self
}

public trait [Scalar Any]VectorSpace AdditiveGroup {
    scale(self, k Scalar) Self
}

public trait [Scalar Any]Scalable [Scalar]VectorSpace {
    unscale(self, k Scalar) Self
}

public trait [Vector Any]AffineSpace {
    add_vector(self, v Vector) Self
    sub_vector(self, v Vector) Self
    sub_point(self, other Self) Vector
}

// ============================================================================
// Primitive Hashable Implementations
// ============================================================================

given Bool {
    public hash(self) UInt = if self then 1u else 0u
}

given UInt {
    public hash(self) UInt = self
}

given UInt8 {
    public hash(self) UInt = (UInt)self
}

given UInt16 {
    public hash(self) UInt = (UInt)self
}

given UInt32 {
    public hash(self) UInt = (UInt)self
}

given UInt64 {
    public hash(self) UInt = {
        let v UInt64 = self
        let lo UInt = (UInt)v
        let hi UInt = (UInt){ v / (UInt64)4294967296 }
        combine_hash(combine_hash(0u, lo), hi)
    }
}

given Int {
    public hash(self) UInt = (UInt)self
}

given Int8 {
    public hash(self) UInt = (UInt)self
}

given Int16 {
    public hash(self) UInt = (UInt)self
}

given Int32 {
    public hash(self) UInt = (UInt)self
}

given Int64 {
    public hash(self) UInt = {
        let v UInt64 = (UInt64)self
        let lo UInt = (UInt)v
        let hi UInt = (UInt){ v / (UInt64)4294967296 }
        combine_hash(combine_hash(0u, lo), hi)
    }
}

given Float32 {
    public hash(self) UInt = {
        let bits UInt32 = self.to_bits()
        combine_hash(0u, (UInt)bits)
    }
}

given Float64 {
    public hash(self) UInt = {
        let bits UInt64 = self.to_bits()
        let lo UInt = (UInt)bits
        let hi UInt = (UInt){ bits / 4294967296u64 }
        combine_hash(combine_hash(0u, lo), hi)
    }
}

given[T Any] T ptr {
    public hash(self) UInt = (UInt)self
}
