// ============================================================================
// Koral Standard Library - Traits
// ============================================================================
// NOTE: This file is merged into core.koral, so primitives are already available.
// ============================================================================

// ============================================================================
// Core Traits
// ============================================================================

public trait Eq {
    equals(self, other Self) Bool
}

public trait Ord Eq {
    compare(self, other Self) Int
}

// Hash utilities
public let combine_hash(seed UInt, value UInt) UInt = {
    let magic UInt = 2654435769  // 0x9e3779b9
    seed ^ {value + magic + {seed << 6} + {seed >> 2}}
}

public trait Hashable Eq {
    hash(self) UInt
}

public trait ToString {
    to_string(self) String
}

// Generic Iterator trait for for-loop support
public trait [T Any]Iterator {
    next(self ref) [T]Option
}

// Iterable trait - types that can produce an iterator
public trait [T Any, R [T]Iterator]Iterable {
    iterator(self) R
}

// ============================================================================
// Algebraic and Indexing Traits (Operator Lowering)
// ============================================================================

public trait [K Any, V Any]Index {
    at(self, key K) V
}

public trait [K Any, V Any]MutIndex [K, V]Index {
    set_at(self ref, key K, value V) Void
}

public trait Add {
    add(self, other Self) Self
    zero() Self
}

public trait Sub Add {
    neg(self) Self
    sub(self, other Self) Self
}

public trait Mul {
    mul(self, other Self) Self
    one() Self
}

public trait Div Mul {
    div(self, other Self) Self
}

public trait Rem Div {
    rem(self, other Self) Self
}

public trait [Scalar Any]Scale {
    scale(self, k Scalar) Self
}

public trait [Scalar Any]InvScale [Scalar]Scale {
    unscale(self, k Scalar) Self
}

public trait [Vector Sub]Affine {
    add_vector(self, v Vector) Self
    sub_vector(self, v Vector) Self
    sub_point(self, other Self) Vector
}

// ============================================================================
// Primitive Arithmetic Implementations (intrinsic)
// ============================================================================

// NOTE: These are declared as intrinsic to avoid implementing them in terms of
// operators that lower back to the same trait methods (infinite recursion).

intrinsic given Int {
    add(self, other Int) Int
    neg(self) Int
    sub(self, other Int) Int
    mul(self, other Int) Int
    div(self, other Int) Int
    rem(self, other Int) Int
}

given Int {
    public zero() Int = 0
    public one() Int = 1
}

intrinsic given Int8 {
    add(self, other Int8) Int8
    neg(self) Int8
    sub(self, other Int8) Int8
    mul(self, other Int8) Int8
    div(self, other Int8) Int8
    rem(self, other Int8) Int8
}

given Int8 {
    public zero() Int8 = (Int8)0
    public one() Int8 = (Int8)1
}

intrinsic given Int16 {
    add(self, other Int16) Int16
    neg(self) Int16
    sub(self, other Int16) Int16
    mul(self, other Int16) Int16
    div(self, other Int16) Int16
    rem(self, other Int16) Int16
}

given Int16 {
    public zero() Int16 = (Int16)0
    public one() Int16 = (Int16)1
}

intrinsic given Int32 {
    add(self, other Int32) Int32
    neg(self) Int32
    sub(self, other Int32) Int32
    mul(self, other Int32) Int32
    div(self, other Int32) Int32
    rem(self, other Int32) Int32
}

given Int32 {
    public zero() Int32 = (Int32)0
    public one() Int32 = (Int32)1
}

intrinsic given Int64 {
    add(self, other Int64) Int64
    neg(self) Int64
    sub(self, other Int64) Int64
    mul(self, other Int64) Int64
    div(self, other Int64) Int64
    rem(self, other Int64) Int64
}

given Int64 {
    public zero() Int64 = (Int64)0
    public one() Int64 = (Int64)1
}

intrinsic given UInt {
    add(self, other UInt) UInt
    neg(self) UInt
    sub(self, other UInt) UInt
    mul(self, other UInt) UInt
    div(self, other UInt) UInt
    rem(self, other UInt) UInt
}

given UInt {
    public zero() UInt = (UInt)0
    public one() UInt = (UInt)1
}

intrinsic given UInt8 {
    add(self, other UInt8) UInt8
    neg(self) UInt8
    sub(self, other UInt8) UInt8
    mul(self, other UInt8) UInt8
    div(self, other UInt8) UInt8
    rem(self, other UInt8) UInt8
}

given UInt8 {
    public zero() UInt8 = (UInt8)0
    public one() UInt8 = (UInt8)1
}

intrinsic given UInt16 {
    add(self, other UInt16) UInt16
    neg(self) UInt16
    sub(self, other UInt16) UInt16
    mul(self, other UInt16) UInt16
    div(self, other UInt16) UInt16
    rem(self, other UInt16) UInt16
}

given UInt16 {
    public zero() UInt16 = (UInt16)0
    public one() UInt16 = (UInt16)1
}

intrinsic given UInt32 {
    add(self, other UInt32) UInt32
    neg(self) UInt32
    sub(self, other UInt32) UInt32
    mul(self, other UInt32) UInt32
    div(self, other UInt32) UInt32
    rem(self, other UInt32) UInt32
}

given UInt32 {
    public zero() UInt32 = (UInt32)0
    public one() UInt32 = (UInt32)1
}

intrinsic given UInt64 {
    add(self, other UInt64) UInt64
    neg(self) UInt64
    sub(self, other UInt64) UInt64
    mul(self, other UInt64) UInt64
    div(self, other UInt64) UInt64
    rem(self, other UInt64) UInt64
}

given UInt64 {
    public zero() UInt64 = (UInt64)0
    public one() UInt64 = (UInt64)1
}

intrinsic given Float32 {
    add(self, other Float32) Float32
    neg(self) Float32
    sub(self, other Float32) Float32
    mul(self, other Float32) Float32
    div(self, other Float32) Float32
}

given Float32 {
    public zero() Float32 = (Float32)0.0
    public one() Float32 = (Float32)1.0
}

intrinsic given Float64 {
    add(self, other Float64) Float64
    neg(self) Float64
    sub(self, other Float64) Float64
    mul(self, other Float64) Float64
    div(self, other Float64) Float64
}

given Float64 {
    public zero() Float64 = 0.0
    public one() Float64 = 1.0
}

// ============================================================================
// Primitive Hashable Implementations
// ============================================================================

given Bool {
    public hash(self) UInt = if self then (UInt)1 else (UInt)0
}

given UInt {
    public hash(self) UInt = self
}

given UInt8 {
    public hash(self) UInt = (UInt)self
}

given UInt16 {
    public hash(self) UInt = (UInt)self
}

given UInt32 {
    public hash(self) UInt = (UInt)self
}

given UInt64 {
    public hash(self) UInt = {
        let v UInt64 = self
        let lo UInt = (UInt)v
        let hi UInt = (UInt){ v / (UInt64)4294967296 }
        combine_hash(combine_hash((UInt)0, lo), hi)
    }
}

given Int {
    public hash(self) UInt = (UInt)self
}

given Int8 {
    public hash(self) UInt = (UInt)self
}

given Int16 {
    public hash(self) UInt = (UInt)self
}

given Int32 {
    public hash(self) UInt = (UInt)self
}

given Int64 {
    public hash(self) UInt = {
        let v UInt64 = (UInt64)self
        let lo UInt = (UInt)v
        let hi UInt = (UInt){ v / (UInt64)4294967296 }
        combine_hash(combine_hash((UInt)0, lo), hi)
    }
}

given Float32 {
    public hash(self) UInt = {
        let bits UInt32 = self.to_bits()
        combine_hash((UInt)0, (UInt)bits)
    }
}

given Float64 {
    public hash(self) UInt = {
        let bits UInt64 = self.to_bits()
        let lo UInt = (UInt)bits
        let hi UInt = (UInt){ bits / (UInt64)4294967296 }
        combine_hash(combine_hash((UInt)0, lo), hi)
    }
}

given[T Any] T ptr {
    public hash(self) UInt = (UInt)self
}
