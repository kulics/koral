// ============================================================================
// Koral Standard Library - Traits
// ============================================================================
// NOTE: This file is merged into core.koral, so primitives are already available.
// ============================================================================

// ============================================================================
// Core Traits
// ============================================================================
public trait Eq {
    equals(self, other Self) Bool
}

public trait Ord Eq {
    compare(self, other Self) Int
}

// Hash utilities
public let combine_hash(seed UInt, value UInt) UInt = {
    let magic UInt = 2654435769 // 0x9e3779b9
    return seed ^ value.wrapping_add(magic).wrapping_add(seed << 6).wrapping_add(seed >> 2)
}

public trait Hashable Eq {
    hash(self) UInt
}

public trait ToString {
    to_string(self) String
}

public trait Error {
    message(self) String
}

given String Error {
    public message(self) String = self
}

given Bool Eq {
    public equals(self, other Bool) Bool = self == other
}

given Bool Ord {
    public compare(self, other Bool) Int =
        if self == other then 0 else if self then 1 else -1
}

// ============================================================================
// Algebraic and Indexing Traits (Operator Lowering)
// ============================================================================
public trait [K Any, V Any]Index {
    at(self, key K) V
}

public trait [K Any, V Any]MutIndex [K, V]Index {
    set_at(self ref, key K, value V) Void
}

public trait Add {
    add(self, other Self) Self
    zero() Self
}

public trait Sub Add {
    neg(self) Self
    sub(self, other Self) Self
}

public trait Mul {
    mul(self, other Self) Self
    one() Self
}

public trait Div Mul {
    div(self, other Self) Self
}

public trait Rem Div {
    rem(self, other Self) Self
}

public trait [Scalar Any]Scale {
    scale(self, k Scalar) Self
}

public trait [Scalar Any]InvScale [Scalar]Scale {
    unscale(self, k Scalar) Self
}

public trait [Vector Sub]Affine {
    add_vector(self, v Vector) Self
    sub_vector(self, v Vector) Self
    sub_point(self, other Self) Vector
}

// ============================================================================
// Primitive Arithmetic Implementations (intrinsic)
// ============================================================================

// NOTE: These are declared as intrinsic to avoid implementing them in terms of
// operators that lower back to the same trait methods (infinite recursion).
intrinsic given Int {
    add(self, other Int) Int
    neg(self) Int
    sub(self, other Int) Int
    mul(self, other Int) Int
    div(self, other Int) Int
    rem(self, other Int) Int
    public wrapping_add(self, other Int) Int
    public wrapping_sub(self, other Int) Int
    public wrapping_mul(self, other Int) Int
    public wrapping_div(self, other Int) Int
    public wrapping_rem(self, other Int) Int
    public wrapping_neg(self) Int
    public wrapping_shl(self, other Int) Int
    public wrapping_shr(self, other Int) Int
}

given Int Eq {
    public equals(self, other Int) Bool = self == other
}

given Int Ord {
    public compare(self, other Int) Int =
        if self < other then -1 else if self > other then 1 else 0
}

intrinsic given Int8 {
    add(self, other Int8) Int8
    neg(self) Int8
    sub(self, other Int8) Int8
    mul(self, other Int8) Int8
    div(self, other Int8) Int8
    rem(self, other Int8) Int8
    public wrapping_add(self, other Int8) Int8
    public wrapping_sub(self, other Int8) Int8
    public wrapping_mul(self, other Int8) Int8
    public wrapping_div(self, other Int8) Int8
    public wrapping_rem(self, other Int8) Int8
    public wrapping_neg(self) Int8
    public wrapping_shl(self, other Int8) Int8
    public wrapping_shr(self, other Int8) Int8
}

given Int8 Eq {
    public equals(self, other Int8) Bool = self == other
}

given Int8 Ord {
    public compare(self, other Int8) Int =
        if self < other then -1 else if self > other then 1 else 0
}

intrinsic given Int16 {
    add(self, other Int16) Int16
    neg(self) Int16
    sub(self, other Int16) Int16
    mul(self, other Int16) Int16
    div(self, other Int16) Int16
    rem(self, other Int16) Int16
    public wrapping_add(self, other Int16) Int16
    public wrapping_sub(self, other Int16) Int16
    public wrapping_mul(self, other Int16) Int16
    public wrapping_div(self, other Int16) Int16
    public wrapping_rem(self, other Int16) Int16
    public wrapping_neg(self) Int16
    public wrapping_shl(self, other Int16) Int16
    public wrapping_shr(self, other Int16) Int16
}

given Int16 Eq {
    public equals(self, other Int16) Bool = self == other
}

given Int16 Ord {
    public compare(self, other Int16) Int =
        if self < other then -1 else if self > other then 1 else 0
}

intrinsic given Int32 {
    add(self, other Int32) Int32
    neg(self) Int32
    sub(self, other Int32) Int32
    mul(self, other Int32) Int32
    div(self, other Int32) Int32
    rem(self, other Int32) Int32
    public wrapping_add(self, other Int32) Int32
    public wrapping_sub(self, other Int32) Int32
    public wrapping_mul(self, other Int32) Int32
    public wrapping_div(self, other Int32) Int32
    public wrapping_rem(self, other Int32) Int32
    public wrapping_neg(self) Int32
    public wrapping_shl(self, other Int32) Int32
    public wrapping_shr(self, other Int32) Int32
}

given Int32 Eq {
    public equals(self, other Int32) Bool = self == other
}

given Int32 Ord {
    public compare(self, other Int32) Int =
        if self < other then -1 else if self > other then 1 else 0
}

intrinsic given Int64 {
    add(self, other Int64) Int64
    neg(self) Int64
    sub(self, other Int64) Int64
    mul(self, other Int64) Int64
    div(self, other Int64) Int64
    rem(self, other Int64) Int64
    public wrapping_add(self, other Int64) Int64
    public wrapping_sub(self, other Int64) Int64
    public wrapping_mul(self, other Int64) Int64
    public wrapping_div(self, other Int64) Int64
    public wrapping_rem(self, other Int64) Int64
    public wrapping_neg(self) Int64
    public wrapping_shl(self, other Int64) Int64
    public wrapping_shr(self, other Int64) Int64
}

given Int64 Eq {
    public equals(self, other Int64) Bool = self == other
}

given Int64 Ord {
    public compare(self, other Int64) Int =
        if self < other then -1 else if self > other then 1 else 0
}

intrinsic given UInt {
    add(self, other UInt) UInt
    neg(self) UInt
    sub(self, other UInt) UInt
    mul(self, other UInt) UInt
    div(self, other UInt) UInt
    rem(self, other UInt) UInt
    public wrapping_add(self, other UInt) UInt
    public wrapping_sub(self, other UInt) UInt
    public wrapping_mul(self, other UInt) UInt
    public wrapping_div(self, other UInt) UInt
    public wrapping_rem(self, other UInt) UInt
    public wrapping_neg(self) UInt
    public wrapping_shl(self, other UInt) UInt
    public wrapping_shr(self, other UInt) UInt
}

given UInt Eq {
    public equals(self, other UInt) Bool = self == other
}

given UInt Ord {
    public compare(self, other UInt) Int =
        if self < other then -1 else if self > other then 1 else 0
}

intrinsic given UInt8 {
    add(self, other UInt8) UInt8
    neg(self) UInt8
    sub(self, other UInt8) UInt8
    mul(self, other UInt8) UInt8
    div(self, other UInt8) UInt8
    rem(self, other UInt8) UInt8
    public wrapping_add(self, other UInt8) UInt8
    public wrapping_sub(self, other UInt8) UInt8
    public wrapping_mul(self, other UInt8) UInt8
    public wrapping_div(self, other UInt8) UInt8
    public wrapping_rem(self, other UInt8) UInt8
    public wrapping_neg(self) UInt8
    public wrapping_shl(self, other UInt8) UInt8
    public wrapping_shr(self, other UInt8) UInt8
}

given UInt8 Eq {
    public equals(self, other UInt8) Bool = self == other
}

given UInt8 Ord {
    public compare(self, other UInt8) Int =
        if self < other then -1 else if self > other then 1 else 0
}

intrinsic given UInt16 {
    add(self, other UInt16) UInt16
    neg(self) UInt16
    sub(self, other UInt16) UInt16
    mul(self, other UInt16) UInt16
    div(self, other UInt16) UInt16
    rem(self, other UInt16) UInt16
    public wrapping_add(self, other UInt16) UInt16
    public wrapping_sub(self, other UInt16) UInt16
    public wrapping_mul(self, other UInt16) UInt16
    public wrapping_div(self, other UInt16) UInt16
    public wrapping_rem(self, other UInt16) UInt16
    public wrapping_neg(self) UInt16
    public wrapping_shl(self, other UInt16) UInt16
    public wrapping_shr(self, other UInt16) UInt16
}

given UInt16 Eq {
    public equals(self, other UInt16) Bool = self == other
}

given UInt16 Ord {
    public compare(self, other UInt16) Int =
        if self < other then -1 else if self > other then 1 else 0
}

intrinsic given UInt32 {
    add(self, other UInt32) UInt32
    neg(self) UInt32
    sub(self, other UInt32) UInt32
    mul(self, other UInt32) UInt32
    div(self, other UInt32) UInt32
    rem(self, other UInt32) UInt32
    public wrapping_add(self, other UInt32) UInt32
    public wrapping_sub(self, other UInt32) UInt32
    public wrapping_mul(self, other UInt32) UInt32
    public wrapping_div(self, other UInt32) UInt32
    public wrapping_rem(self, other UInt32) UInt32
    public wrapping_neg(self) UInt32
    public wrapping_shl(self, other UInt32) UInt32
    public wrapping_shr(self, other UInt32) UInt32
}

given UInt32 Eq {
    public equals(self, other UInt32) Bool = self == other
}

given UInt32 Ord {
    public compare(self, other UInt32) Int =
        if self < other then -1 else if self > other then 1 else 0
}

intrinsic given UInt64 {
    add(self, other UInt64) UInt64
    neg(self) UInt64
    sub(self, other UInt64) UInt64
    mul(self, other UInt64) UInt64
    div(self, other UInt64) UInt64
    rem(self, other UInt64) UInt64
    public wrapping_add(self, other UInt64) UInt64
    public wrapping_sub(self, other UInt64) UInt64
    public wrapping_mul(self, other UInt64) UInt64
    public wrapping_div(self, other UInt64) UInt64
    public wrapping_rem(self, other UInt64) UInt64
    public wrapping_neg(self) UInt64
    public wrapping_shl(self, other UInt64) UInt64
    public wrapping_shr(self, other UInt64) UInt64
}

given UInt64 Eq {
    public equals(self, other UInt64) Bool = self == other
}

given UInt64 Ord {
    public compare(self, other UInt64) Int =
        if self < other then -1 else if self > other then 1 else 0
}

intrinsic given Float32 {
    add(self, other Float32) Float32
    neg(self) Float32
    sub(self, other Float32) Float32
    mul(self, other Float32) Float32
    div(self, other Float32) Float32
}

given Float32 Eq {
    public equals(self, other Float32) Bool = self == other
}

given Float32 Ord {
    public compare(self, other Float32) Int =
        if self < other then -1 else if self > other then 1 else 0
}

intrinsic given Float64 {
    add(self, other Float64) Float64
    neg(self) Float64
    sub(self, other Float64) Float64
    mul(self, other Float64) Float64
    div(self, other Float64) Float64
}

given Float64 Eq {
    public equals(self, other Float64) Bool = self == other
}

given Float64 Ord {
    public compare(self, other Float64) Int =
        if self < other then -1 else if self > other then 1 else 0
}

// ============================================================================
// Primitive Explicit Algebraic Conformances
// ============================================================================
given Int Add {
    public add(self, other Int) Int = self + other
    public zero() Int = 0
}
given Int Sub {
    public neg(self) Int = -self
    public sub(self, other Int) Int = self - other
}
given Int Mul {
    public mul(self, other Int) Int = self * other
    public one() Int = 1
}
given Int Div {
    public div(self, other Int) Int = self / other
}
given Int Rem {
    public rem(self, other Int) Int = self % other
}

given Int8 Add {
    public add(self, other Int8) Int8 = self + other
    public zero() Int8 = (Int8)0
}
given Int8 Sub {
    public neg(self) Int8 = -self
    public sub(self, other Int8) Int8 = self - other
}
given Int8 Mul {
    public mul(self, other Int8) Int8 = self * other
    public one() Int8 = (Int8)1
}
given Int8 Div {
    public div(self, other Int8) Int8 = self / other
}
given Int8 Rem {
    public rem(self, other Int8) Int8 = self % other
}

given Int16 Add {
    public add(self, other Int16) Int16 = self + other
    public zero() Int16 = (Int16)0
}
given Int16 Sub {
    public neg(self) Int16 = -self
    public sub(self, other Int16) Int16 = self - other
}
given Int16 Mul {
    public mul(self, other Int16) Int16 = self * other
    public one() Int16 = (Int16)1
}
given Int16 Div {
    public div(self, other Int16) Int16 = self / other
}
given Int16 Rem {
    public rem(self, other Int16) Int16 = self % other
}

given Int32 Add {
    public add(self, other Int32) Int32 = self + other
    public zero() Int32 = (Int32)0
}
given Int32 Sub {
    public neg(self) Int32 = -self
    public sub(self, other Int32) Int32 = self - other
}
given Int32 Mul {
    public mul(self, other Int32) Int32 = self * other
    public one() Int32 = (Int32)1
}
given Int32 Div {
    public div(self, other Int32) Int32 = self / other
}
given Int32 Rem {
    public rem(self, other Int32) Int32 = self % other
}

given Int64 Add {
    public add(self, other Int64) Int64 = self + other
    public zero() Int64 = (Int64)0
}
given Int64 Sub {
    public neg(self) Int64 = -self
    public sub(self, other Int64) Int64 = self - other
}
given Int64 Mul {
    public mul(self, other Int64) Int64 = self * other
    public one() Int64 = (Int64)1
}
given Int64 Div {
    public div(self, other Int64) Int64 = self / other
}
given Int64 Rem {
    public rem(self, other Int64) Int64 = self % other
}

given UInt Add {
    public add(self, other UInt) UInt = self + other
    public zero() UInt = (UInt)0
}
given UInt Sub {
    public neg(self) UInt = (UInt)0 - self
    public sub(self, other UInt) UInt = self - other
}
given UInt Mul {
    public mul(self, other UInt) UInt = self * other
    public one() UInt = (UInt)1
}
given UInt Div {
    public div(self, other UInt) UInt = self / other
}
given UInt Rem {
    public rem(self, other UInt) UInt = self % other
}

given UInt8 Add {
    public add(self, other UInt8) UInt8 = self + other
    public zero() UInt8 = (UInt8)0
}
given UInt8 Sub {
    public neg(self) UInt8 = (UInt8)0 - self
    public sub(self, other UInt8) UInt8 = self - other
}
given UInt8 Mul {
    public mul(self, other UInt8) UInt8 = self * other
    public one() UInt8 = (UInt8)1
}
given UInt8 Div {
    public div(self, other UInt8) UInt8 = self / other
}
given UInt8 Rem {
    public rem(self, other UInt8) UInt8 = self % other
}

given UInt16 Add {
    public add(self, other UInt16) UInt16 = self + other
    public zero() UInt16 = (UInt16)0
}
given UInt16 Sub {
    public neg(self) UInt16 = (UInt16)0 - self
    public sub(self, other UInt16) UInt16 = self - other
}
given UInt16 Mul {
    public mul(self, other UInt16) UInt16 = self * other
    public one() UInt16 = (UInt16)1
}
given UInt16 Div {
    public div(self, other UInt16) UInt16 = self / other
}
given UInt16 Rem {
    public rem(self, other UInt16) UInt16 = self % other
}

given UInt32 Add {
    public add(self, other UInt32) UInt32 = self + other
    public zero() UInt32 = (UInt32)0
}
given UInt32 Sub {
    public neg(self) UInt32 = (UInt32)0 - self
    public sub(self, other UInt32) UInt32 = self - other
}
given UInt32 Mul {
    public mul(self, other UInt32) UInt32 = self * other
    public one() UInt32 = (UInt32)1
}
given UInt32 Div {
    public div(self, other UInt32) UInt32 = self / other
}
given UInt32 Rem {
    public rem(self, other UInt32) UInt32 = self % other
}

given UInt64 Add {
    public add(self, other UInt64) UInt64 = self + other
    public zero() UInt64 = (UInt64)0
}
given UInt64 Sub {
    public neg(self) UInt64 = (UInt64)0 - self
    public sub(self, other UInt64) UInt64 = self - other
}
given UInt64 Mul {
    public mul(self, other UInt64) UInt64 = self * other
    public one() UInt64 = (UInt64)1
}
given UInt64 Div {
    public div(self, other UInt64) UInt64 = self / other
}
given UInt64 Rem {
    public rem(self, other UInt64) UInt64 = self % other
}

given Float32 Add {
    public add(self, other Float32) Float32 = self + other
    public zero() Float32 = 0.0
}
given Float32 Sub {
    public neg(self) Float32 = -self
    public sub(self, other Float32) Float32 = self - other
}
given Float32 Mul {
    public mul(self, other Float32) Float32 = self * other
    public one() Float32 = 1.0
}
given Float32 Div {
    public div(self, other Float32) Float32 = self / other
}

given Float64 Add {
    public add(self, other Float64) Float64 = self + other
    public zero() Float64 = 0.0
}
given Float64 Sub {
    public neg(self) Float64 = -self
    public sub(self, other Float64) Float64 = self - other
}
given Float64 Mul {
    public mul(self, other Float64) Float64 = self * other
    public one() Float64 = 1.0
}
given Float64 Div {
    public div(self, other Float64) Float64 = self / other
}

// ============================================================================
// Primitive Hashable Implementations
// ============================================================================
given Bool Hashable {
    public hash(self) UInt = if self then 1 else 0
}

given UInt Hashable {
    public hash(self) UInt = self
}

given UInt8 Hashable {
    public hash(self) UInt = (UInt)self
}

given UInt16 Hashable {
    public hash(self) UInt = (UInt)self
}

given UInt32 Hashable {
    public hash(self) UInt = (UInt)self
}

given UInt64 Hashable {
    public hash(self) UInt = {
        let v UInt64 = self
        let lo UInt = (UInt)v
        let hi UInt = (UInt)(v / 4294967296)
        return combine_hash(combine_hash(0, lo), hi)
    }
}

given Int Hashable {
    public hash(self) UInt = (UInt)self
}

given Int8 Hashable {
    public hash(self) UInt = (UInt)self
}

given Int16 Hashable {
    public hash(self) UInt = (UInt)self
}

given Int32 Hashable {
    public hash(self) UInt = (UInt)self
}

given Int64 Hashable {
    public hash(self) UInt = {
        let v UInt64 = (UInt64)self
        let lo UInt = (UInt)v
        let hi UInt = (UInt)(v / 4294967296)
        return combine_hash(combine_hash(0, lo), hi)
    }
}

given Float32 Hashable {
    public hash(self) UInt = {
        let bits UInt32 = self.to_bits()
        return combine_hash(0, (UInt)bits)
    }
}

given Float64 Hashable {
    public hash(self) UInt = {
        let bits UInt64 = self.to_bits()
        let lo UInt = (UInt)bits
        let hi UInt = (UInt)(bits / 4294967296)
        return combine_hash(combine_hash(0, lo), hi)
    }
}

given[T Any] T ptr Eq {
    public equals(self, other T ptr) Bool = self == other
}

given[T Any] T ptr Hashable {
    public hash(self) UInt = (UInt)self
}
