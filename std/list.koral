// ============================================================================
// Koral Standard Library - List Type
// ============================================================================
// NOTE: This file is merged into core.koral, so primitives, traits, option, and string are already available.
// ============================================================================

// ============================================================================
// List Storage and Type Definition
// ============================================================================

public type [T Any]ListStorage(mut source T ptr, mut len Int, mut cap Int)

given[T Any] [T]ListStorage {
    __drop(self ref) = {
        let mut i = 0
        while i < self.len then {
            deinit_memory(offset_ptr(self.source, i))
            i += 1
        }
        dealloc_memory(self.source)
    }
}

public type [T Any]List(mut storage [T]ListStorage ref)

public type [T Any]ListIterator(storage [T]ListStorage ref, mut index Int)

// ============================================================================
// List Methods
// ============================================================================

given[T Any] [T]List {
    public new() Self = {
        let cap = 10
        let source = [T]alloc_memory(cap)
        let storage = ref [T]ListStorage(source, 0, cap)
        [T]List(storage)
    }

    public with_capacity(capacity Int) Self = {
        let cap = if capacity < 1 then 1 else capacity
        let source = [T]alloc_memory(cap)
        let storage = ref [T]ListStorage(source, 0, cap)
        [T]List(storage)
    }

    public count(self) Int = self.storage.len

    private ensure_unique(self ref) Void = {
        if ref_count(self.storage) > 1 then {
            let old = self.storage
            let new_cap = old.cap
            let new_source = [T]alloc_memory(new_cap)
            let mut i = 0
            while i < old.len then {
                let v = deptr offset_ptr(old.source, i)
                init_memory(offset_ptr(new_source, i), v)
                i += 1
            }
            let new_storage = ref [T]ListStorage(new_source, old.len, new_cap)
            self.storage = new_storage
        }
    }

    private ensure_capacity(self ref, min_capacity Int) Void = {
         if min_capacity > self.storage.cap then {
             let mut new_cap = self.storage.cap * 2
             if new_cap < min_capacity then { new_cap = min_capacity; }
             let new_source = [T]alloc_memory(new_cap)
             let old_len = self.storage.len
             if ref_count(self.storage) == 1 then {
                 let old_source = self.storage.source
                 move_memory(new_source, old_source, old_len)
                 dealloc_memory(old_source)
                 self.storage.source = new_source
                 self.storage.cap = new_cap
             } else {
                 let mut i = 0
                 while i < old_len then {
                    let v = deptr offset_ptr(self.storage.source, i)
                    init_memory(offset_ptr(new_source, i), v)
                    i += 1
                 }
                 let new_storage = ref [T]ListStorage(new_source, old_len, new_cap)
                 self.storage = new_storage
             }
         } else {
             self.ensure_unique()
         }
    }

    public push(self ref, value T) Void = {
        self.ensure_capacity(self.storage.len + 1)
        init_memory(offset_ptr(self.storage.source, self.storage.len), value)
        self.storage.len = self.storage.len + 1
    }

    // Using if is pattern matching
    public pop(self ref) [T]Option = {
        if self.storage.len == 0 then { return [T]Option.None(); }
        self.ensure_unique()
        self.storage.len = self.storage.len - 1
        let value = take_memory(offset_ptr(self.storage.source, self.storage.len))
        [T]Option.Some(value)
    }

    public insert(self ref, index Int, value T) Void = {
        if index < 0 or index > self.storage.len then { panic("List insert index out of bounds"); }
        self.ensure_capacity(self.storage.len + 1)
        // Shift elements to the right
        let mut i = self.storage.len
        while i > index then {
            let src = offset_ptr(self.storage.source, i - 1)
            let dst = offset_ptr(self.storage.source, i)
            init_memory(dst, take_memory(src))
            i = i - 1
        }
        init_memory(offset_ptr(self.storage.source, index), value)
        self.storage.len = self.storage.len + 1
    }

    public remove(self ref, index Int) T = {
        if index < 0 or index >= self.storage.len then { panic("List remove index out of bounds"); }
        self.ensure_unique()
        let value = take_memory(offset_ptr(self.storage.source, index))
        // Shift elements to the left
        let mut i = index
        while i < self.storage.len - 1 then {
            let src = offset_ptr(self.storage.source, i + 1)
            let dst = offset_ptr(self.storage.source, i)
            init_memory(dst, take_memory(src))
            i = i + 1
        }
        self.storage.len = self.storage.len - 1
        value
    }

    public get(self, index Int) [T]Option = {
        if index < 0 or index >= self.storage.len then { return [T]Option.None(); }
        [T]Option.Some(deptr offset_ptr(self.storage.source, index))
    }

    public set(self ref, index Int, value T) [T]Option = {
        if index < 0 or index >= self.storage.len then { return [T]Option.None(); }
        self.ensure_unique()
        let slot = offset_ptr(self.storage.source, index)
        let old = deptr slot
        deptr slot = value
        [T]Option.Some(old)
    }

    public front(self) [T]Option = self.get(0)

    public back(self) [T]Option = {
        if self.storage.len == 0 then { return [T]Option.None(); }
        self.get(self.storage.len - 1)
    }

    public is_empty(self) Bool = self.storage.len == 0

    public clear(self ref) Void = {
        self.ensure_unique()
        let mut i = 0
        while i < self.storage.len then {
            deinit_memory(offset_ptr(self.storage.source, i))
            i += 1
        }
        self.storage.len = 0
    }

    public iterator(self) [T]ListIterator = [T]ListIterator(self.storage, 0)

    public at(self, index Int) T = {
        if index < 0 or index >= self.storage.len then { panic("List index out of bounds"); }
        deptr offset_ptr(self.storage.source, index)
    }

    public update_at(self ref, index Int, value T) Void = {
        if index < 0 or index >= self.storage.len then { panic("List index out of bounds"); }
        self.ensure_unique()
        deptr offset_ptr(self.storage.source, index) = value;
    }

    private make_slice(self, start Int, len Int) [T]List = {
        if start < 0 or len < 0 or start + len > self.storage.len then {
            panic("List slice out of bounds")
        }
        let mut result = [T]List.with_capacity(len)
        let mut i = 0
        while i < len then {
            result.push(deptr offset_ptr(self.storage.source, start + i))
            i += 1
        }
        result
    }

    public slice(self, range [Int]Range) [T]List = when range is {
        .ClosedRange(start, end) then self.make_slice(start, end - start + 1),
        .ClosedOpenRange(start, end) then self.make_slice(start, end - start),
        .OpenClosedRange(start, end) then self.make_slice(start + 1, end - start),
        .OpenRange(start, end) then self.make_slice(start + 1, end - start - 1),
        .FromRange(start) then self.make_slice(start, self.storage.len - start),
        .FromOpenRange(start) then self.make_slice(start + 1, self.storage.len - start - 1),
        .ToRange(end) then self.make_slice(0, end + 1),
        .ToOpenRange(end) then self.make_slice(0, end),
        .FullRange then self.make_slice(0, self.storage.len),
    }
}

given[T Equality] [T]List {
    public contains(self, value T) Bool = {
        let mut i = 0
        while i < self.storage.len then {
            if deptr offset_ptr(self.storage.source, i) == value then {
                return true
            }
            i += 1
        }
        false
    }
}

// ============================================================================
// List Iterator - Using new pattern matching
// ============================================================================

given[T Any] [T]ListIterator {
    public next(self ref) [T]Option = {
        if self.index >= self.storage.len then { return [T]Option.None(); }
        let value = deptr offset_ptr(self.storage.source, self.index)
        self.index = self.index + 1
        [T]Option.Some(value)
    }
}

// ============================================================================
// List ToString Implementation
// ============================================================================

given [T ToString] [T]List {
    public to_string(self) String = {
        let mut result = String.empty()
        result.push_string("[")
        let mut i = 0
        while i < self.count() then {
            if i > 0 then { result.push_string(", "); }
            result.push_string(self[i].to_string())
            i += 1
        }
        result.push_string("]")
        result
    }
}


// ============================================================================
// List Eager Operations
// ============================================================================

given[T Any] [T]List {
    // Filter - returns new list with elements matching predicate
    public filter(self, fn [T, Bool]Func) [T]List = {
        let mut result = [T]List.new()
        let mut i = 0
        while i < self.storage.len then {
            let v = deptr offset_ptr(self.storage.source, i)
            if fn(v) then { result.push(v); }
            i += 1
        }
        result
    }
    
    // Map - returns new list with transformed elements
    public [U Any]map(self, fn [T, U]Func) [U]List = {
        let mut result = [U]List.with_capacity(self.storage.len)
        let mut i = 0
        while i < self.storage.len then {
            let v = deptr offset_ptr(self.storage.source, i)
            result.push(fn(v))
            i += 1
        }
        result
    }
}

// ============================================================================
// List Sorting - sort_by with key function
// ============================================================================

given[T Any] [T]List {
    // Sort in-place using a key extraction function
    // key extracts an ordering-comparable value from each element
    public [K Ordering]sort_by(self ref, key [T, K]Func) Void = {
        if self.storage.len <= 1 then { return; }
        self.ensure_unique()
        self.merge_sort_by_key(key, 0, self.storage.len)
    }

    // Merge sort implementation with key function
    private [K Ordering]merge_sort_by_key(self ref, key [T, K]Func, start Int, end Int) Void = {
        let len = end - start
        if len <= 1 then { return; }
        
        let mid = start + len / 2
        self.merge_sort_by_key(key, start, mid)
        self.merge_sort_by_key(key, mid, end)
        self.merge_by_key(key, start, mid, end)
    }

    // Merge two sorted subarrays using key function
    private [K Ordering]merge_by_key(self ref, key [T, K]Func, start Int, mid Int, end Int) Void = {
        let left_len = mid - start
        let mut temp = [T]List.with_capacity(left_len)
        
        // Copy left half to temp
        let mut i = 0
        while i < left_len then {
            temp.push(deptr offset_ptr(self.storage.source, start + i))
            i += 1
        }
        
        let mut left_idx = 0
        let mut right_idx = mid
        let mut dest_idx = start
        
        // Merge back
        while left_idx < left_len and right_idx < end then {
            let left_val = deptr offset_ptr(temp.storage.source, left_idx)
            let right_val = deptr offset_ptr(self.storage.source, right_idx)
            
            // Use <= to ensure stability (prefer left on equal)
            if key(left_val) <= key(right_val) then {
                deptr offset_ptr(self.storage.source, dest_idx) = left_val;
                left_idx += 1
            } else {
                deptr offset_ptr(self.storage.source, dest_idx) = right_val;
                right_idx += 1
            }
            dest_idx += 1
        }
        
        // Copy remaining left elements
        while left_idx < left_len then {
            let val = deptr offset_ptr(temp.storage.source, left_idx)
            deptr offset_ptr(self.storage.source, dest_idx) = val;
            left_idx += 1
            dest_idx += 1
        }
    }
}


// ============================================================================
// List Sorting - sort based on Ordering trait
// ============================================================================

given[T Ordering] [T]List {
    // Sort in-place in ascending order using Ordering trait
    public sort(self ref) Void = {
        if self.storage.len <= 1 then { return; }
        self.ensure_unique()
        self.merge_sort_comparable(0, self.storage.len)
    }
    
    // Merge sort implementation using Ordering
    private merge_sort_comparable(self ref, start Int, end Int) Void = {
        let len = end - start
        if len <= 1 then { return; }
        
        let mid = start + len / 2
        self.merge_sort_comparable(start, mid)
        self.merge_sort_comparable(mid, end)
        self.merge_comparable(start, mid, end)
    }
    
    // Merge two sorted subarrays using Ordering
    private merge_comparable(self ref, start Int, mid Int, end Int) Void = {
        let left_len = mid - start
        let mut temp = [T]List.with_capacity(left_len)
        
        // Copy left half to temp
        let mut i = 0
        while i < left_len then {
            temp.push(deptr offset_ptr(self.storage.source, start + i))
            i += 1
        }
        
        let mut left_idx = 0
        let mut right_idx = mid
        let mut dest_idx = start
        
        // Merge back
        while left_idx < left_len and right_idx < end then {
            let left_val = deptr offset_ptr(temp.storage.source, left_idx)
            let right_val = deptr offset_ptr(self.storage.source, right_idx)
            
            // Use <= to ensure stability (prefer left on equal)
            if left_val <= right_val then {
                deptr offset_ptr(self.storage.source, dest_idx) = left_val;
                left_idx += 1
            } else {
                deptr offset_ptr(self.storage.source, dest_idx) = right_val;
                right_idx += 1
            }
            dest_idx += 1
        }
        
        // Copy remaining left elements
        while left_idx < left_len then {
            let val = deptr offset_ptr(temp.storage.source, left_idx)
            deptr offset_ptr(self.storage.source, dest_idx) = val;
            left_idx += 1
            dest_idx += 1
        }
    }
}
