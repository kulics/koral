// ============================================================================
// Koral Standard Library - Set Type
// ============================================================================
// NOTE: This file is merged into core.koral, so all previous types are already available.
// ============================================================================

// ============================================================================
// Set Storage and Type Definition
// ============================================================================
public type [T Hashable]SetBucket {
    Empty(),
    Occupied(value T),
    Deleted(),
}

protected type [T Hashable]SetStorage(
    mut buckets [T]SetBucket ptr,
    mut count UInt,
    mut capacity UInt,
)

given[T Hashable] [T]SetStorage {
    __drop(self ref) = {
        let mut i UInt = 0
        while i < self.capacity then {
            deinit_memory(self.buckets + i)
            i += 1
        }
        dealloc_memory(self.buckets)
    }
}

public type [T Hashable]Set(protected mut storage [T]SetStorage ref)

public type [T Hashable]SetIterator(protected storage [T]SetStorage ref, mut index UInt)

// ============================================================================
// Set Methods
// ============================================================================
given[T Hashable] [T]Set {
    public new() Self = {
        let capacity UInt = 16
        let buckets = [[T]SetBucket]alloc_memory(capacity)
        let mut i UInt = 0
        while i < capacity then {
            init_memory(buckets + i, [T]SetBucket.Empty())
            i += 1
        }
        let storage = ref [T]SetStorage(buckets, 0, capacity)
        return [T]Set(storage)
    }

    public with_capacity(capacity UInt) Self = {
        // Hash tables need extra space for efficiency (load factor ~0.5)
        let cap = if capacity < 4 then 4 else capacity * 2
        let buckets = [[T]SetBucket]alloc_memory(cap)
        let mut i UInt = 0
        while i < cap then {
            init_memory(buckets + i, [T]SetBucket.Empty())
            i += 1
        }
        let storage = ref [T]SetStorage(buckets, 0, cap)
        return [T]Set(storage)
    }

    public count(self) UInt = self.storage.count

    private ensure_unique(self ref) Void = {
        if ref_count(self.storage) > 1 then {
            let old = self.storage
            let new_buckets = [[T]SetBucket]alloc_memory(old.capacity)
            let mut i UInt = 0
            while i < old.capacity then {
                let bucket = deptr (old.buckets + i)
                init_memory(new_buckets + i, bucket)
                i += 1
            }
            let new_storage = ref [T]SetStorage(new_buckets, old.count, old.capacity)
            self.storage = new_storage
        }
    }

    // Using when for bucket handling
    private find_slot(self ref, value T) [UInt]Option = {
        let h = value.hash()
        let mut idx = h % self.storage.capacity
        let mut first_deleted = [UInt]Option.None()
        let mut probes UInt = 0
        while probes < self.storage.capacity then {
            let bucket = deptr (self.storage.buckets + idx)
            when bucket in {
                .Empty then {
                    when first_deleted in {
                        .Some(_) then {
                            return first_deleted
                        },
                        .None then {
                            return [UInt]Option.Some(idx)
                        },
                    }
                },
                .Deleted then {
                    when first_deleted in {
                        .None then {
                            first_deleted = [UInt]Option.Some(idx)
                        },
                        _ then {},
                    }
                },
                .Occupied(v) then {
                    if v == value then {
                        return [UInt]Option.Some(idx)
                    }
                },
            }
            idx = (idx + 1) % self.storage.capacity
            probes += 1
        }
        return first_deleted
    }

    private rehash(self ref) Void = {
        let old_cap = self.storage.capacity
        let old_buckets = self.storage.buckets
        let new_cap = old_cap * 2
        let new_buckets = [[T]SetBucket]alloc_memory(new_cap)
        let mut i UInt = 0
        while i < new_cap then {
            init_memory(new_buckets + i, [T]SetBucket.Empty())
            i += 1
        }
        self.storage.buckets = new_buckets
        self.storage.capacity = new_cap
        self.storage.count = 0
        i = 0
        while i < old_cap then {
            let bucket = take_memory(old_buckets + i)
            when bucket in {
                .Occupied(v) then {
                    self.insert(v);
                },
                _ then {},
            }
            i += 1
        }
        dealloc_memory(old_buckets)
    }

    // Returns true if value was new, false if already present
    public insert(self ref, value T) Bool = {
        self.ensure_unique()
        if self.storage.count * 2 >= self.storage.capacity then {
            self.rehash();
        }
        when self.find_slot(value) in {
            .None then {
                panic("Set insert failed");
                return false
            },
            .Some(idx) then {
                let bucket = deptr (self.storage.buckets + idx)
                when bucket in {
                    .Occupied(_) then {
                        return false
                    },
                    .Empty or .Deleted then {
                        deptr (self.storage.buckets + idx) = [T]SetBucket.Occupied(value)
                        self.storage.count = self.storage.count + 1
                        return true
                    },
                }
            },
        }
    }

    public insert_all(self ref, other [T]Set) Void = {
        let mut it = other.iterator()
        while it.next() is .Some(v) then {
            self.insert(v);
        }
    }

    public contains(self, value T) Bool = {
        when self.find_slot(value) in {
            .None then {
                return false
            },
            .Some(idx) then {
                let bucket = deptr (self.storage.buckets + idx)
                return when bucket in {
                    .Occupied(_) then true,
                    _ then false,
                }
            },
        }
    }

    public remove(self ref, value T) Bool = {
        self.ensure_unique()
        when self.find_slot(value) in {
            .None then {
                return false
            },
            .Some(idx) then {
                let bucket = deptr (self.storage.buckets + idx)
                return when bucket in {
                    .Occupied(_) then {
                        deptr (self.storage.buckets + idx) = [T]SetBucket.Deleted()
                        self.storage.count = self.storage.count - 1
                        return true
                    },
                    _ then false,
                }
            },
        }
    }

    public is_empty(self) Bool = self.storage.count == 0

    public clear(self ref) Void = {
        self.ensure_unique()
        let mut i UInt = 0
        while i < self.storage.capacity then {
            deptr (self.storage.buckets + i) = [T]SetBucket.Empty()
            i += 1
        }
        self.storage.count = 0
    }

    // Using while is pattern matching for iterator loops
    public union(self, other [T]Set) [T]Set = {
        let mut result = [T]Set.new()
        let mut it = self.iterator()
        while it.next() is .Some(v) then {
            result.insert(v);
        }
        let mut it2 = other.iterator()
        while it2.next() is .Some(v) then {
            result.insert(v);
        }
        return result
    }

    public intersection(self, other [T]Set) [T]Set = {
        let mut result = [T]Set.new()
        let mut it = self.iterator()
        while it.next() is .Some(v) then {
            if other.contains(v) then {
                result.insert(v);
            }
        }
        return result
    }

    public difference(self, other [T]Set) [T]Set = {
        let mut result = [T]Set.new()
        let mut it = self.iterator()
        while it.next() is .Some(v) then {
            if not other.contains(v) then {
                result.insert(v);
            }
        }
        return result
    }

    public symmetric_difference(self, other [T]Set) [T]Set = {
        let mut result = [T]Set.new()

        let mut it = self.iterator()
        while it.next() is .Some(v) then {
            if not other.contains(v) then {
                result.insert(v);
            }
        }

        let mut it2 = other.iterator()
        while it2.next() is .Some(v) then {
            if not self.contains(v) then {
                result.insert(v);
            }
        }

        return result
    }
}

given[T Hashable] [T]Set [T, [T]SetIterator]Iterable {
    public iterator(self) [T]SetIterator = [T]SetIterator(self.storage, 0)
}

// ============================================================================
// Set Iterator
// ============================================================================
given[T Hashable] [T]SetIterator [T]Iterator {
    public next(self ref) [T]Option = {
        while self.index < self.storage.capacity then {
            let bucket = deptr (self.storage.buckets + self.index)
            self.index = self.index + 1
            when bucket in {
                .Occupied(v) then {
                    return [T]Option.Some(v)
                },
                _ then {},
            }
        }
        return [T]Option.None()
    }
}

// ============================================================================
// Set Eager Operations
// ============================================================================
given[T Hashable] [T]Set {
    // Filter - returns new set with elements matching predicate
    public filter(self, fn [T, Bool]Func) [T]Set = {
        let mut result = [T]Set.new()
        let mut it = self.iterator()
        while it.next() is .Some(v) then {
            if fn(v) then {
                result.insert(v);
            }
        }
        return result
    }

    // Map - returns new set with transformed elements (U must be Hashable)
    public [U Hashable]map(self, fn [T, U]Func) [U]Set = {
        let mut result = [U]Set.new()
        let mut it = self.iterator()
        while it.next() is .Some(v) then {
            result.insert(fn(v));
        }
        return result
    }
}
