// ============================================================================
// std.os - Directory Operations
// ============================================================================
// Provides: DirEntry type, WalkAction enum, directory manipulation functions
// Access via: using std.os
// ============================================================================

// ============================================================================
// FFI Declarations
// ============================================================================

// Opaque types for directory operations
foreign type CDirHandle
foreign type CDirEntry

// Directory I/O
foreign let __koral_opendir(path UInt8 ptr) CDirHandle ptr
foreign let __koral_readdir(dir CDirHandle ptr) CDirEntry ptr
foreign let __koral_closedir(dir CDirHandle ptr) Int32
foreign let __koral_dirent_name(entry CDirEntry ptr) UInt8 ptr
foreign let __koral_dirent_type(entry CDirEntry ptr) Int32

// Directory manipulation
foreign let __koral_mkdir(path UInt8 ptr, mode UInt32) Int32
foreign let __koral_rmdir(path UInt8 ptr) Int32
foreign let __koral_mkdtemp(template UInt8 ptr) UInt8 ptr

// ============================================================================
// Helpers
// ============================================================================

/// Convert a dirent type code to FileType
private let dir_entry_type(entry CDirEntry ptr) FileType = {
    let t = __koral_dirent_type(entry)
    when t in {
        0 then {
            return FileType.RegularFile()
        },
        1 then {
            return FileType.Directory()
        },
        2 then {
            return FileType.Symlink()
        },
        _ then {
            return FileType.Other()
        },
    }
}


// ============================================================================
// DirEntry Type
// ============================================================================

/// Directory entry with type information
public type DirEntry(
    private _name String,
    private _path Path,
    private _file_type FileType,
)

given DirEntry {
    /// File/directory name
    public name(self) String = self._name

    /// Full path
    public path(self) Path = self._path

    /// File type
    public file_type(self) FileType = self._file_type

    public is_file(self) Bool = self._file_type.is_file()
    public is_dir(self) Bool = self._file_type.is_dir()
    public is_symlink(self) Bool = self._file_type.is_symlink()

    /// Get full file metadata (triggers stat system call)
    public info(self) [FileInfo]Result = read_file_info(self._path)

    public to_string(self) String = {
        let mut s = String.new()
        s.push_string("DirEntry(")
        s.push_string(self._name)
        s.push_string(", ")
        s.push_string(self._file_type.to_string())
        s.push_string(")")
        return s
    }
}

// ============================================================================
// WalkAction Enum
// ============================================================================

/// Walk control enum for directory traversal
public type WalkAction {
    Continue(),        // Continue traversal
    SkipDir(),         // Skip children of current directory entry
    Stop(),            // Stop traversal normally
    Error(err Error ref),     // Propagate business error, stop traversal
}


// ============================================================================
// Directory Operations
// ============================================================================

/// Create single directory (parent must exist)
public let create_dir(path Path) [Void]Result = {
    let s = path.to_string()
    return if __koral_mkdir(s.storage.data, 493) == 0 then
        [Void]Result.Ok({})
    else
        [Void]Result.Error(ref last_error_message())
}

/// Create directory recursively (creates all missing parent directories)
public let create_dir_all(path Path) [Void]Result = {
    let path_str = path.to_string()
    let normalized = path_str.replace_all("\\", "/")
    let parts = normalized.split("/")
    let mut current = String.new()
    let mut seeded = false

    if normalized.starts_with("//") then {
        current.push_string("//")
        seeded = true
    } else if normalized.starts_with("/") then {
        current.push('/')
        seeded = true
    }

    for part in parts then {
        if part.is_empty() then {
            continue
        }
        // Windows drive prefix (e.g., "C:") - treat as seeded root.
        if not seeded and part.count() == 2 and part[1] == ':' then {
            current.push_string(part)
            seeded = true
            continue
        }
        if not seeded and current.is_empty() then {
            current.push_string(part)
        } else {
            if not current.ends_with("/") then {
                current.push('/')
            }
            current.push_string(part)
        }
        seeded = true

        if not path_exists(Path.new(current)) then {
            if __koral_mkdir(current.storage.data, 493) <> 0 then {
                return [Void]Result.Error(ref last_error_message())
            }
        }
    }
    return [Void]Result.Ok({})
}

/// Remove empty directory
public let remove_dir(path Path) [Void]Result = {
    let s = path.to_string()
    return if __koral_rmdir(s.storage.data) == 0 then
        [Void]Result.Ok({})
    else
        [Void]Result.Error(ref last_error_message())
}

/// Remove directory recursively (removes all contents first)
public let remove_dir_all(path Path) [Void]Result = {
    when read_dir(path) in {
        .Ok(entries) then {
            for entry in entries then {
                let full_path = entry.path()
                if entry.is_dir() then {
                    when remove_dir_all(full_path) in {
                        .Error(e) then {
                            return [Void]Result.Error(e)
                        },
                        .Ok(_) then {},
                    }
                } else {
                    if __koral_remove(full_path.to_string().storage.data) <> 0 then {
                        return [Void]Result.Error(ref last_error_message())
                    }
                }
            }
            return remove_dir(path)
        },
        .Error(e) then {
            return [Void]Result.Error(e)
        },
    }
}


/// Read directory entries (returns DirEntry list with name, path, and file type)
public let read_dir(path Path) [[DirEntry]List]Result = {
    let s = path.to_string()
    let dir = __koral_opendir(s.storage.data)
    if dir == [CDirHandle]null_ptr() then {
        return [[DirEntry]List]Result.Error(ref last_error_message())
    }

    let mut entries = [DirEntry]List.new()

    while true then {
        let entry = __koral_readdir(dir)
        if entry == [CDirEntry]null_ptr() then {
            break
        }

        let name = String.from_cstring(__koral_dirent_name(entry))
        if name == "." or name == ".." then {
            continue
        }
        let full_path = path.join(name)
        let ft = dir_entry_type(entry)
        entries.push(DirEntry(name, full_path, ft))
    }

    __koral_closedir(dir)
    return [[DirEntry]List]Result.Ok(entries)
}


// ============================================================================
// walk_dir — Depth-first recursive directory traversal
// ============================================================================

/// Traverse a directory tree depth-first, calling visitor for each entry.
/// The visitor receives a DirEntry and returns a WalkAction to control traversal.
public let walk_dir(path Path, visitor [DirEntry, WalkAction]Func) [Void]Result = {
    let s = path.to_string()
    let handle = __koral_opendir(s.storage.data)
    if handle == [CDirHandle]null_ptr() then {
        return [Void]Result.Error(ref last_error_message())
    }
    let action = walk_dir_handle(path, handle, visitor)
    __koral_closedir(handle)
    when action in {
        .Error(err) then {
            return [Void]Result.Error(err)
        },
        _ then {
            return [Void]Result.Ok({})
        },
    }
}

/// Internal recursive helper for walk_dir.
/// Iterates entries in the given directory handle, calling visitor for each.
/// Recurses into subdirectories when visitor returns Continue.
private let walk_dir_handle(
    dir_path Path,
    handle CDirHandle ptr,
    visitor [DirEntry, WalkAction]Func,
) WalkAction = {
    while true then {
        let entry = __koral_readdir(handle)
        if entry == [CDirEntry]null_ptr() then { break }
        let name = String.from_cstring(__koral_dirent_name(entry))
        if name == "." or name == ".." then { continue }
        let full_path = dir_path.join(name)
        let ft = dir_entry_type(entry)
        let dir_entry = DirEntry(name, full_path, ft)
        let action = visitor(dir_entry)
        when action in {
            .Stop then {
                return WalkAction.Stop()
            },
            .Error(err) then {
                return WalkAction.Error(err)
            },
            .SkipDir then {
                // Skip children of current directory entry, continue with siblings
            },
            .Continue then {
                if ft.is_dir() then {
                    let sub_handle = __koral_opendir(full_path.to_string().storage.data)
                    if sub_handle <> [CDirHandle]null_ptr() then {
                        let sub_action = walk_dir_handle(full_path, sub_handle, visitor)
                        __koral_closedir(sub_handle)
                        when sub_action in {
                            .Continue then {},
                            .Stop then {
                                return WalkAction.Stop()
                            },
                            .Error(err) then {
                                return WalkAction.Error(err)
                            },
                            .SkipDir then {},
                        }
                    }
                }
            },
        }
    }
    return WalkAction.Continue()
}


// ============================================================================
// create_temp_dir — Create a temporary directory
// ============================================================================

/// Create a temporary directory.
/// When dir is empty path, uses the system temp directory.
/// Returns the full path of the created temporary directory.
public let create_temp_dir(dir Path, prefix String) [Path]Result = {
    let base = if dir.is_empty() then temp_dir() else dir
    let base_str = base.to_string()
    let mut template = String.new()
    template.push_string(base_str)
    if not base_str.ends_with("/") and not base_str.ends_with("\\") then {
        template.push('/')
    }
    template.push_string(prefix)
    template.push_string("XXXXXX")
    // __koral_mkdtemp modifies the template in-place, replacing XXXXXX with random chars
    let result = __koral_mkdtemp(template.storage.data)
    if result == [UInt8]null_ptr() then {
        return [Path]Result.Error(ref last_error_message())
    }
    return [Path]Result.Ok(Path.new(String.from_cstring(result)))
}
