// ============================================================================
// std.os - Convenience File System Functions
// ============================================================================
// Provides: read_file, write_file, append_file (byte-oriented),
//           read_text_file, write_text_file, append_text_file (text-oriented),
//           copy_file, remove_file, rename_path,
//           open_file, create_file, read_file_info, etc.
// All I/O uses fd-based File (no C stdio dependency).
// Access via: using std.os
// ============================================================================

// ============================================================================
// FFI Declarations
// ============================================================================

// File system operations
foreign let __koral_remove(path UInt8 ptr) Int32
foreign let __koral_rename(old UInt8 ptr, new UInt8 ptr) Int32

// Disk query functions
foreign let __koral_path_exists(path UInt8 ptr) Int32
foreign let __koral_is_file(path UInt8 ptr) Int32
foreign let __koral_is_dir(path UInt8 ptr) Int32
foreign let __koral_is_symlink(path UInt8 ptr) Int32
foreign let __koral_realpath(path UInt8 ptr, buf UInt8 ptr, size UInt) Int32

// File metadata (stat)
foreign type KoralStatResult(
    size Int64,
    file_type Int32,
    permissions UInt32,
    modified_secs Int64,
    modified_nanos Int64,
    accessed_secs Int64,
    accessed_nanos Int64,
    created_secs Int64,
    created_nanos Int64,
)
foreign let __koral_stat(path UInt8 ptr, out KoralStatResult ptr) Int32
foreign let __koral_lstat(path UInt8 ptr, out KoralStatResult ptr) Int32

// File open (unbuffered I/O)
foreign let __koral_open(path UInt8 ptr, open_mode Int32, perm UInt32) Int32

// File system operations
foreign let __koral_chmod(path UInt8 ptr, mode UInt32) Int32
foreign let __koral_link(src UInt8 ptr, dst UInt8 ptr) Int32
foreign let __koral_symlink(src UInt8 ptr, dst UInt8 ptr) Int32
foreign let __koral_readlink(path UInt8 ptr, buf UInt8 ptr, buf_size UInt) Int32
foreign let __koral_truncate(path UInt8 ptr, size Int64) Int32
foreign let __koral_mkstemp(template UInt8 ptr) Int32

// ============================================================================
// Byte-Oriented File Operations
// ============================================================================

/// Read file content as a byte list (binary)
public let read_file(path Path) [[UInt8]List]Result = {
    return when open_file(path, OpenMode.Read()) in {
        .Ok(f) then {
            let mut out = [UInt8]List.new()
            let mut chunk = make_bytes(4096)
            while true then {
                when f.read(ref chunk, ....) in {
                    .Ok(n) then {
                        if n == 0 then {
                            return [[UInt8]List]Result.Ok(out)
                        }
                        out.push_all(chunk, 0..<n)
                    },
                    .Error(e) then {
                        return [[UInt8]List]Result.Error(e)
                    },
                }
            }
            yield [[UInt8]List]Result.Ok(out)
        },
        .Error(e) then {
            return [[UInt8]List]Result.Error(e)
        },
    }
}

/// Write a byte list to file (binary, overwrite)
public let write_file(path Path, bytes [UInt8]List) [Void]Result = {
    return when open_file(path, OpenMode.Write()) in {
        .Ok(f) then {
            let mut start UInt = 0
            let end = bytes.count()
            while start < end then {
                when f.write(bytes, start..<end) in {
                    .Ok(n) then {
                        if n == 0 then {
                            return [Void]Result.Error(ref IoError.WriteZero())
                        }
                        start += n
                    },
                    .Error(e) then {
                        return [Void]Result.Error(e)
                    },
                }
            }
            yield [Void]Result.Ok({})
        },
        .Error(e) then {
            return [Void]Result.Error(e)
        },
    }
}

/// Append a byte list to file (binary)
public let append_file(path Path, bytes [UInt8]List) [Void]Result = {
    return when open_file(path, OpenMode.Append()) in {
        .Ok(f) then {
            let mut start UInt = 0
            let end = bytes.count()
            while start < end then {
                when f.write(bytes, start..<end) in {
                    .Ok(n) then {
                        if n == 0 then {
                            return [Void]Result.Error(ref IoError.WriteZero())
                        }
                        start += n
                    },
                    .Error(e) then {
                        return [Void]Result.Error(e)
                    },
                }
            }
            yield [Void]Result.Ok({})
        },
        .Error(e) then {
            return [Void]Result.Error(e)
        },
    }
}


// ============================================================================
// Text-Oriented File Operations
// ============================================================================

/// Read file content as a string (UTF-8 text)
public let read_text_file(path Path) [String]Result = {
    return when read_file(path) in {
        .Ok(bytes) then {
            yield [String]Result.Ok(String.from_bytes(bytes))
        },
        .Error(e) then [String]Result.Error(e),
    }
}

/// Write a string to file (UTF-8 text, overwrite)
public let write_text_file(path Path, content String) [Void]Result = {
    return write_file(path, content.to_bytes())
}

/// Append a string to file (UTF-8 text)
public let append_text_file(path Path, content String) [Void]Result = {
    return append_file(path, content.to_bytes())
}

// ============================================================================
// File Operations
// ============================================================================

/// Copy file (reads source as bytes, writes to destination)
public let copy_file(src Path, dst Path) [Void]Result =
    when read_file(src) in {
        .Ok(bytes) then write_file(dst, bytes),
        .Error(e) then [Void]Result.Error(e),
    }

/// Remove (delete) a file
public let remove_file(path Path) [Void]Result = {
    let s = path.to_string()
    return if __koral_remove(s.storage.data) == 0 then
        [Void]Result.Ok({})
    else
        [Void]Result.Error(ref last_error_message())
}

/// Rename or move a file/directory
public let rename_path(src Path, dst Path) [Void]Result = {
    let src_s = src.to_string()
    let dst_s = dst.to_string()
    return if __koral_rename(src_s.storage.data, dst_s.storage.data) == 0 then
        [Void]Result.Ok({})
    else
        [Void]Result.Error(ref last_error_message())
}

// ============================================================================
// Disk Query Functions
// ============================================================================

/// Check if path exists on disk
public let path_exists(path Path) Bool = {
    let s = path.to_string()
    return __koral_path_exists(s.storage.data) <> 0
}

/// Check if path is a regular file
public let is_file(path Path) Bool = {
    let s = path.to_string()
    return __koral_is_file(s.storage.data) <> 0
}

/// Check if path is a directory
public let is_dir(path Path) Bool = {
    let s = path.to_string()
    return __koral_is_dir(s.storage.data) <> 0
}

/// Check if path is a symbolic link
public let is_symlink(path Path) Bool = {
    let s = path.to_string()
    return __koral_is_symlink(s.storage.data) <> 0
}

/// Convert to absolute path (does not resolve symlinks)
public let absolute_path(path Path) [Path]Result = {
    if path.is_absolute() then {
        return [Path]Result.Ok(path)
    }
    when current_dir() in {
        .Ok(cwd) then {
            return [Path]Result.Ok(cwd.join(path.to_string()))
        },
        .Error(e) then {
            return [Path]Result.Error(e)
        },
    }
}

/// Canonicalize path (resolves symlinks and relative components)
public let canonicalize_path(path Path) [Path]Result = {
    let s = path.to_string()
    let buf = [UInt8]alloc_memory(4096)
    defer dealloc_memory(buf)
    let result = __koral_realpath(s.storage.data, buf, 4096)
    if result <> 0 then {
        return [Path]Result.Error(ref last_error_message())
    }
    let resolved = String.from_cstring(buf)
    return [Path]Result.Ok(Path.new(resolved))
}


// ============================================================================
// File Open / Create
// ============================================================================

/// Open a file and return a File handle (unbuffered, directly wraps fd).
public let open_file(path Path, mode OpenMode) [File]Result = {
    let normalized = path.normalize()
    let s = normalized.to_string()
    let mut open_mode Int32 = 0
    let mut perm UInt32 = 0
    when mode in {
        .Read then { open_mode = 0; perm = 0 },
        .Write then { open_mode = 1; perm = 420 },
        .Create then { open_mode = 2; perm = 420 },
        .Append then { open_mode = 3; perm = 420 },
        .ReadWrite then { open_mode = 4; perm = 0 },
    }
    let fd = __koral_open(s.storage.data, open_mode, perm)
    if fd < 0 then {
        return [File]Result.Error(ref last_error_message())
    }
    return [File]Result.Ok(File(ref FileStorage(fd, normalized)))
}

/// Create a new file (fails if file already exists).
public let create_file(path Path) [File]Result = open_file(path, .Create())

// ============================================================================
// File Metadata Queries
// ============================================================================

/// Query file/directory metadata information (follows symlinks).
public let read_file_info(path Path) [FileInfo]Result = {
    let s = path.normalize().to_string()
    let mut stat_buf = KoralStatResult(0, 0, 0, 0, 0, 0, 0, 0, 0)
    let result = __koral_stat(s.storage.data, ptr stat_buf)
    if result <> 0 then {
        return [FileInfo]Result.Error(ref last_error_message())
    }
    let ft = when stat_buf.file_type in {
        0 then FileType.RegularFile(),
        1 then FileType.Directory(),
        2 then FileType.Symlink(),
        _ then FileType.Other(),
    }
    return [FileInfo]Result.Ok(FileInfo(
        (UInt64)stat_buf.size,
        ft,
        Permission.from_mode(stat_buf.permissions),
        Duration(stat_buf.modified_secs, stat_buf.modified_nanos),
        Duration(stat_buf.accessed_secs, stat_buf.accessed_nanos),
        Duration(stat_buf.created_secs, stat_buf.created_nanos)
    ))
}

/// Query symlink metadata (does NOT follow symlinks).
public let read_symlink_info(path Path) [FileInfo]Result = {
    let s = path.normalize().to_string()
    let mut stat_buf = KoralStatResult(0, 0, 0, 0, 0, 0, 0, 0, 0)
    let result = __koral_lstat(s.storage.data, ptr stat_buf)
    if result <> 0 then {
        return [FileInfo]Result.Error(ref last_error_message())
    }
    let ft = when stat_buf.file_type in {
        0 then FileType.RegularFile(),
        1 then FileType.Directory(),
        2 then FileType.Symlink(),
        _ then FileType.Other(),
    }
    return [FileInfo]Result.Ok(FileInfo(
        (UInt64)stat_buf.size,
        ft,
        Permission.from_mode(stat_buf.permissions),
        Duration(stat_buf.modified_secs, stat_buf.modified_nanos),
        Duration(stat_buf.accessed_secs, stat_buf.accessed_nanos),
        Duration(stat_buf.created_secs, stat_buf.created_nanos)
    ))
}

// ============================================================================
// Permission, Link, and Truncate Operations
// ============================================================================

/// Set file permissions
public let set_permissions(path Path, perm Permission) [Void]Result = {
    let s = path.normalize().to_string()
    let result = __koral_chmod(s.storage.data, perm.mode())
    if result <> 0 then {
        return [Void]Result.Error(ref last_error_message())
    }
    return [Void]Result.Ok({})
}

/// Create a hard link (dst points to same inode as src)
public let create_hard_link(src Path, dst Path) [Void]Result = {
    let norm_src = src.normalize().to_string()
    let norm_dst = dst.normalize().to_string()
    let result = __koral_link(norm_src.storage.data, norm_dst.storage.data)
    if result <> 0 then {
        return [Void]Result.Error(ref last_error_message())
    }
    return [Void]Result.Ok({})
}

/// Create a symbolic link (dst is a symlink pointing to src)
public let create_symlink(src Path, dst Path) [Void]Result = {
    let norm_src = src.normalize().to_string()
    let norm_dst = dst.normalize().to_string()
    let result = __koral_symlink(norm_src.storage.data, norm_dst.storage.data)
    if result <> 0 then {
        return [Void]Result.Error(ref last_error_message())
    }
    return [Void]Result.Ok({})
}

/// Read the target path of a symbolic link
public let read_symlink(path Path) [Path]Result = {
    let s = path.normalize().to_string()
    let buf = [UInt8]alloc_memory(4096)
    defer dealloc_memory(buf)
    let result = __koral_readlink(s.storage.data, buf, 4096)
    if result < 0 then {
        return [Path]Result.Error(ref last_error_message())
    }
    let target = String.from_utf8_ptr_unchecked(buf, (UInt)result)
    return [Path]Result.Ok(Path.new(target))
}

/// Truncate a file to the specified size
public let truncate_file(path Path, size UInt64) [Void]Result = {
    let s = path.normalize().to_string()
    let result = __koral_truncate(s.storage.data, (Int64)size)
    if result <> 0 then {
        return [Void]Result.Error(ref last_error_message())
    }
    return [Void]Result.Ok({})
}

// ============================================================================
// Temporary File Creation
// ============================================================================

/// Create a temporary file.
/// When dir is empty, uses the system temp directory.
/// Returns an open File handle (use file.path() to get the path).
public let create_temp_file(dir Path, prefix String) [File]Result = {
    let base = if dir.is_empty() then temp_dir() else dir
    let base_str = base.to_string()
    let mut template = String.new()
    template.push_string(base_str)
    if not base_str.ends_with("/") and not base_str.ends_with("\\") then {
        template.push('/')
    }
    template.push_string(prefix)
    template.push_string("XXXXXX")
    let fd = __koral_mkstemp(template.storage.data)
    if fd < 0 then {
        return [File]Result.Error(ref last_error_message())
    }
    let file_path = String.from_cstring(template.storage.data)
    return [File]Result.Ok(File(ref FileStorage(fd, Path.new(file_path))))
}
