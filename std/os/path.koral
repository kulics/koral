// ============================================================================
// std.os - Path Operations
// ============================================================================
// Provides: Pure string path manipulation functions (no disk access)
// Access via: using std.os
// ============================================================================

// ============================================================================
// FFI Declarations
// ============================================================================

foreign let __koral_normalize_path(path UInt8 ptr, buf UInt8 ptr, size UInt) Int
foreign let __koral_path_separator() UInt8
foreign let __koral_path_list_separator() UInt8

// ============================================================================
// Path Type
// ============================================================================

public type Path(private _path String)

given Path {
    /// 从字符串构造 Path 实例
    public new(s String) Path = Path(s)

    /// Eq trait：基于内部字符串比较
    public equals(self, other Path) Bool = self._path == other._path

    /// Hashable trait：基于内部字符串哈希
    public hash(self) UInt = self._path.hash()

    /// ToString trait：返回内部路径字符串
    public to_string(self) String = self._path

    /// 判断路径是否为空
    public is_empty(self) Bool = self._path.is_empty()

    /// 判断是否为绝对路径
    public is_absolute(self) Bool = {
        if self._path.is_empty() then {
            return false
        }
        if self._path.starts_with("/") or self._path.starts_with("\\") then {
            return true
        }
        if self._path.count() >= 3 then {
            let c0 = self._path[0]
            let c1 = self._path[1]
            let c2 = self._path[2]
            let is_letter = (c0 >= 65 and c0 <= 90) or (c0 >= 97 and c0 <= 122)
            if is_letter and c1 == ':' and (c2 == '/' or c2 == '\\') then {
                return true
            }
        }
        return false
    }

    /// 拼接路径组件，返回新 Path
    public join(self, name String) Path = {
        if self._path.is_empty() then {
            return Path(name)
        }
        if name.is_empty() then {
            return self
        }
        if Path.new(name).is_absolute() then {
            return Path(name)
        }
        let mut result = String.new()
        result.push_string(self._path)
        let sep = path_separator()
        if not self._path.ends_with("/") and not self._path.ends_with("\\") then {
            result.push_string(sep)
        }
        result.push_string(name)
        return Path(result)
    }

    /// 返回父目录路径
    public dir_name(self) [Path]Option = {
        if self._path.is_empty() then {
            return [Path]Option.None()
        }
        let normalized = self._path.replace_all("\\", "/")
        when normalized.find_last("/") is {
            .Some(idx) then {
                return if idx == 0 then [Path]Option.Some(Path("/"))
                else [Path]Option.Some(Path(normalized.slice(0..<idx)))
            },
            .None then {
                return [Path]Option.None()
            },
        }
    }

    /// 返回最后一个路径组件名称
    public base_name(self) [String]Option = {
        if self._path.is_empty() then {
            return [String]Option.None()
        }
        let normalized = self._path.replace_all("\\", "/")
        let mut p = normalized
        while p.ends_with("/") and p.count() > 1 then {
            p = p.slice(0..<(p.count() - 1))
        }
        when p.find_last("/") is {
            .Some(idx) then {
                return [String]Option.Some(p.slice((idx + 1)...))
            },
            .None then {
                return [String]Option.Some(p)
            },
        }
    }

    /// 返回文件扩展名（不含点号）
    public ext_name(self) [String]Option =
        when self.base_name() is {
            .Some(name) then when name.find_last(".") is {
                .Some(idx) then if idx == 0 then [String]Option.None()
                else [String]Option.Some(name.slice((idx + 1)...)),
                .None then [String]Option.None(),
            },
            .None then [String]Option.None(),
        }

    /// 返回替换了扩展名的新 Path
    public with_ext_name(self, ext String) Path = {
        when self.base_name() is {
            .Some(bname) then {
                let new_base = when bname.find_last(".") is {
                    .Some(idx) then if idx == 0 then bname + "." + ext
                        else bname.slice(0..<idx) + "." + ext,
                    .None then bname + "." + ext,
                }
                return self.with_base_name(new_base)
            },
            .None then {
                return self
            },
        }
    }

    /// 返回替换了最后一个组件名称的新 Path
    public with_base_name(self, name String) Path =
        when self.dir_name() is {
            .Some(dir) then dir.join(name),
            .None then Path(name),
        }

    /// 规范化路径（解析 . 和 .. 组件）
    public normalize(self) Path = {
        let buf_size = self._path.count() + 1
        let buf = [UInt8]alloc_memory(buf_size)
        defer dealloc_memory(buf)
        let len = __koral_normalize_path(self._path.storage.data, buf, buf_size)
        let result = String.from_bytes_unchecked(buf, (UInt)len)
        return Path(result)
    }

    /// 将路径拆分为组件列表
    public components(self) [String]List = {
        let mut parts = [String]List.new()
        let normalized = self._path.replace_all("\\", "/")
        for part = normalized.split("/") then {
            if not part.is_empty() then {
                parts.push(part)
            }
        }
        return parts
    }

    /// 计算相对于 base 的相对路径
    public relative_to(self, base Path) [Path]Result = {
        if self._path.is_empty() then {
            return [Path]Result.Error(ref "target path is empty")
        }
        if base._path.is_empty() then {
            return [Path]Result.Error(ref "base path is empty")
        }

        let norm_self = self.normalize()
        let norm_base = base.normalize()

        if norm_self._path == norm_base._path then {
            return [Path]Result.Ok(Path("."))
        }

        let self_parts = norm_self.components()
        let base_parts = norm_base.components()

        let mut common UInt = 0
        let self_len = self_parts.count()
        let base_len = base_parts.count()
        let min_len = if self_len < base_len then self_len else base_len

        while common < min_len and self_parts.at(common) == base_parts.at(common) then {
            common += 1
        }

        let mut result = String.new()
        let mut i = common
        while i < base_len then {
            if not result.is_empty() then {
                result.push('/')
            }
            result.push_string("..")
            i += 1
        }

        let mut j = common
        while j < self_len then {
            if not result.is_empty() then {
                result.push('/')
            }
            result.push_string(self_parts.at(j))
            j += 1
        }

        if result.is_empty() then {
            return [Path]Result.Ok(Path("."))
        } else {
            return [Path]Result.Ok(Path(result))
        }
    }
}

// ============================================================================
// Module-Level Functions
// ============================================================================

/// Get platform path separator ("/" on Unix, "\" on Windows)
public let path_separator() String = {
    let sep = __koral_path_separator()
    let mut s = String.new()
    s.push(sep)
    return s
}

/// Get platform path list separator (":" on Unix, ";" on Windows)
public let path_list_separator() String = {
    let sep = __koral_path_list_separator()
    let mut s = String.new()
    s.push(sep)
    return s
}


// ============================================================================
// Helper
// ============================================================================

/// Split a normalized path (using "/" separator) into a list of components.
/// Filters out empty parts from consecutive separators.
private let split_path_components(path String) [String]List = {
    let mut parts = [String]List.new()
    let normalized = path.replace_all("\\", "/")
    for part = normalized.split("/") then {
        if not part.is_empty() then {
            parts.push(part)
        }
    }
    return parts
}

/// Glob pattern matching: check if `name` matches `pattern`.
/// Supports `*` (match any sequence), `?` (match single char), `[abc]` (character class).
/// Pure Koral implementation.
public let glob_match(pattern String, name String) Bool =
    glob_match_recursive(pattern, 0, name, 0)

/// Recursive helper for glob matching.
private let glob_match_recursive(pattern String, pi UInt, name String, ni UInt) Bool = {
    let plen = pattern.count()
    let nlen = name.count()

    let mut p = pi
    let mut n = ni

    while p < plen then {
        let pc = pattern[p]

        if pc == '*' then {
            // Skip consecutive stars
            while p < plen and pattern[p] == '*' then {
                p += 1
            }
            // Star at end matches everything
            if p == plen then {
                return true
            }
            // Try matching rest of pattern against each suffix of name
            while n <= nlen then {
                if glob_match_recursive(pattern, p, name, n) then {
                    return true
                }
                n += 1
            }
            return false
        } else if pc == '?' then {
            // Must match exactly one character
            if n >= nlen then {
                return false
            }
            p += 1
            n += 1
        } else if pc == '[' then {
            // Character class
            if n >= nlen then {
                return false
            }
            let nc = name[n]
            p += 1 // skip '['

            let mut matched = false
            let mut first = true
            let mut negate = false

            // Check for negation
            if p < plen and (pattern[p] == '!' or pattern[p] == '^') then {
                negate = true
                p += 1
            }

            while p < plen and (first or pattern[p] <> ']') then {
                first = false
                let range_start = pattern[p]
                p += 1

                // Check for range: [a-z]
                if p + 1 < plen and pattern[p] == '-' and pattern[p + 1] <> ']' then {
                    let range_end = pattern[p + 1]
                    p += 2
                    if nc >= range_start and nc <= range_end then {
                        matched = true
                    }
                } else {
                    if nc == range_start then {
                        matched = true
                    }
                }
            }

            // Skip closing ']'
            if p < plen and pattern[p] == ']' then {
                p += 1
            }

            if negate then {
                matched = not matched
            }

            if not matched then {
                return false
            }
            n += 1
        } else {
            // Literal character match
            if n >= nlen or name[n] <> pc then {
                return false
            }
            p += 1
            n += 1
        }
    }

    // Pattern consumed; name must also be consumed
    return n == nlen
}

// TODO: glob() requires FFI callback support which is not yet available.
// The __koral_glob FFI declaration needs a function pointer type that is
// compatible with foreign function declarations.
// public let glob(pattern String) [[String]List]Result = { ... }