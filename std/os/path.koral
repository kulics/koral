// ============================================================================
// std.os - Path Operations
// ============================================================================
// Provides: Pure string path manipulation functions (no disk access)
// Access via: using std.os
// ============================================================================

// ============================================================================
// FFI Declarations
// ============================================================================

foreign let __koral_normalize_path(path UInt8 ptr, buf UInt8 ptr, size UInt) Int
foreign let __koral_path_separator() UInt8
foreign let __koral_path_list_separator() UInt8

// ============================================================================
// Path Type
// ============================================================================

public type Path(private _path String)

given Path {
    /// 从字符串构造 Path 实例
    public new(s String) Path = Path(s)

    /// Eq trait：基于内部字符串比较
    public equals(self, other Path) Bool = self._path == other._path

    /// Hashable trait：基于内部字符串哈希
    public hash(self) UInt = self._path.hash()

    /// ToString trait：返回内部路径字符串
    public to_string(self) String = self._path

    /// 判断路径是否为空
    public is_empty(self) Bool = self._path.is_empty()

    /// 判断是否为绝对路径
    public is_absolute(self) Bool = {
        if self._path.is_empty() then {
            return false
        }
        if self._path.starts_with("/") or self._path.starts_with("\\") then {
            return true
        }
        if self._path.count() >= 3 then {
            let c0 = self._path[0]
            let c1 = self._path[1]
            let c2 = self._path[2]
            let is_letter = (c0 >= 65 and c0 <= 90) or (c0 >= 97 and c0 <= 122)
            if is_letter and c1 == ':' and (c2 == '/' or c2 == '\\') then {
                return true
            }
        }
        return false
    }

    /// 拼接路径组件，返回新 Path
    public join(self, name String) Path = {
        if self._path.is_empty() then {
            return Path(name)
        }
        if name.is_empty() then {
            return self
        }
        if Path.new(name).is_absolute() then {
            return Path(name)
        }
        let mut result = String.new()
        result.push_string(self._path)
        let sep = path_separator()
        if not self._path.ends_with("/") and not self._path.ends_with("\\") then {
            result.push_string(sep)
        }
        result.push_string(name)
        return Path(result)
    }

    /// 返回父目录路径
    public dir_name(self) Path = {
        if self._path.is_empty() then {
            return Path(".")
        }
        let mut p = self._path.replace_all("\\", "/")
        if is_all_separators(p) then {
            return Path("/")
        }
        while p.ends_with("/") and p.count() > 1 then {
            p = p.substring(0..<(p.count() - 1))
        }
        when p.find_last("/") is {
            .Some(idx) then {
                if idx == 0 then {
                    return Path("/")
                }
                if idx == 2 and p.count() >= 2 and p[1] == ':' then {
                    return Path(p.substring(0..<(idx + 1)))
                }
                return Path(p.substring(0..<idx))
            },
            .None then {
                return Path(".")
            },
        }
    }

    /// 返回最后一个路径组件名称
    public base_name(self) String = {
        if self._path.is_empty() then {
            return "."
        }
        let mut p = self._path.replace_all("\\", "/")
        if is_all_separators(p) then {
            return "/"
        }
        while p.ends_with("/") and p.count() > 1 then {
            p = p.substring(0..<(p.count() - 1))
        }
        when p.find_last("/") is {
            .Some(idx) then {
                if idx + 1 >= p.count() then {
                    return "/"
                }
                return p.substring((idx + 1)...)
            },
            .None then {
                return p
            },
        }
    }

    /// 返回文件扩展名（包含点号，如 ".txt"；无扩展名返回空字符串）
    public ext_name(self) String = {
        let name = self.base_name()
        if name == "." or name == ".." or name == "/" then {
            return ""
        }
        when name.find_last(".") is {
            .Some(idx) then {
                if idx == 0 then {
                    return ""
                }
                return name.substring(idx...)
            },
            .None then {
                return ""
            },
        }
    }

    /// 返回替换了扩展名的新 Path
    public with_ext_name(self, ext String) Path = {
        let bname = self.base_name()
        let old_ext = self.ext_name()
        let stem = if old_ext.is_empty() then bname
            else bname.substring(0..<(bname.count() - old_ext.count()))
        let normalized_ext = if ext.is_empty() then ""
            else if ext.starts_with(".") then ext
            else "." + ext
        return self.with_base_name(stem + normalized_ext)
    }

    /// 返回替换了最后一个组件名称的新 Path
    public with_base_name(self, name String) Path =
        if self.dir_name().to_string() == "." then Path(name)
        else self.dir_name().join(name)

    /// 规范化路径（解析 . 和 .. 组件）
    public normalize(self) Path = {
        let buf_size = self._path.count() + 1
        let buf = [UInt8]alloc_memory(buf_size)
        defer dealloc_memory(buf)
        let len = __koral_normalize_path(self._path.storage.data, buf, buf_size)
        let result = String.from_utf8_ptr_unchecked(buf, (UInt)len)
        return Path(result)
    }

    /// 将路径拆分为组件列表
    public components(self) [String]List = {
        let mut parts = [String]List.new()
        let normalized = self._path.replace_all("\\", "/")
        for part = normalized.split("/") then {
            if not part.is_empty() then {
                parts.push(part)
            }
        }
        return parts
    }

    /// 计算相对于 base 的相对路径
    public relative_to(self, base Path) [Path]Result = {
        if self._path.is_empty() then {
            return [Path]Result.Error(ref "target path is empty")
        }
        if base._path.is_empty() then {
            return [Path]Result.Error(ref "base path is empty")
        }

        let norm_self = self.normalize()
        let norm_base = base.normalize()

        if norm_self._path == norm_base._path then {
            return [Path]Result.Ok(Path("."))
        }

        let self_parts = norm_self.components()
        let base_parts = norm_base.components()

        let mut common UInt = 0
        let self_len = self_parts.count()
        let base_len = base_parts.count()
        let min_len = if self_len < base_len then self_len else base_len

        while common < min_len and self_parts.at(common) == base_parts.at(common) then {
            common += 1
        }

        let mut result = String.new()
        let mut i = common
        while i < base_len then {
            if not result.is_empty() then {
                result.push('/')
            }
            result.push_string("..")
            i += 1
        }

        let mut j = common
        while j < self_len then {
            if not result.is_empty() then {
                result.push('/')
            }
            result.push_string(self_parts.at(j))
            j += 1
        }

        if result.is_empty() then {
            return [Path]Result.Ok(Path("."))
        } else {
            return [Path]Result.Ok(Path(result))
        }
    }
}

// ============================================================================
// Module-Level Functions
// ============================================================================

/// Get platform path separator ("/" on Unix, "\" on Windows)
public let path_separator() String = {
    let sep = __koral_path_separator()
    let mut s = String.new()
    s.push(sep)
    return s
}

/// Get platform path list separator (":" on Unix, ";" on Windows)
public let path_list_separator() String = {
    let sep = __koral_path_list_separator()
    let mut s = String.new()
    s.push(sep)
    return s
}


// ============================================================================
// Helper
// ============================================================================

/// Split a normalized path (using "/" separator) into a list of components.
/// Filters out empty parts from consecutive separators.
private let split_path_components(path String) [String]List = {
    let mut parts = [String]List.new()
    let normalized = path.replace_all("\\", "/")
    for part = normalized.split("/") then {
        if not part.is_empty() then {
            parts.push(part)
        }
    }
    return parts
}

private let is_all_separators(path String) Bool = {
    if path.is_empty() then {
        return false
    }
    let mut i UInt = 0
    while i < path.count() then {
        let c = path[i]
        if c <> '/' and c <> '\\' then {
            return false
        }
        i += 1
    }
    return true
}

