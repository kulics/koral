// ============================================================================
// std.os - Path Operations
// ============================================================================
// Provides: Pure string path manipulation functions (no disk access)
// Access via: using std.os
// ============================================================================

// ============================================================================
// FFI Declarations
// ============================================================================

foreign let koral_normalize_path(path UInt8 ptr, buf UInt8 ptr, size UInt) Int
foreign let koral_path_separator() UInt8
foreign let koral_path_list_separator() UInt8
foreign let koral_errno_ptr() Int32 ptr
foreign let koral_strerror(errnum Int32) UInt8 ptr

// ============================================================================
// Path Functions
// ============================================================================

/// Check if path is absolute
public let is_absolute(path String) Bool = {
    if path.is_empty() then {
        return false
    }
    if path.starts_with("/") or path.starts_with("\\") then {
        return true
    }

    if path.count() >= 3 then {
        let c0 = path[0]
        let c1 = path[1]
        let c2 = path[2]
        let is_letter = (c0 >= 65 and c0 <= 90) or (c0 >= 97 and c0 <= 122)
        if is_letter and c1 == ':' and (c2 == '/' or c2 == '\\') then {
            return true
        }
    }
    false
}

/// Join two paths
public let join_path(base String, name String) String = {
    if base.is_empty() then {
        return name
    }
    if name.is_empty() then {
        return base
    }
    if is_absolute(name) then {
        return name
    }

    let mut result = String.new()
    result.push_string(base)
    let sep = path_separator()
    if not base.ends_with("/") and not base.ends_with("\\") then {
        result.push_string(sep)
    }
    result.push_string(name)
    result
}

/// Get base name (last component of path)
public let base_name(path String) [String]Option = {
    if path.is_empty() then {
        return [String]Option.None()
    }
    let normalized = path.replace_all("\\", "/")

    let mut p = normalized
    while p.ends_with("/") and p.count() > 1 then {
        p = p.slice(0..<(p.count() - 1))
    }

    when p.find_last_index("/") is {
        .Some(idx) then [String]Option.Some(p.slice((idx + 1)...)),
        .None then [String]Option.Some(p),
    }
}

/// Get directory name (parent component of path)
public let dir_name(path String) [String]Option = {
    if path.is_empty() then {
        return [String]Option.None()
    }
    let normalized = path.replace_all("\\", "/")

    when normalized.find_last_index("/") is {
        .Some(idx) then {
            if idx == 0 then {
                [String]Option.Some("/")
            } else {
                [String]Option.Some(normalized.slice(0..<idx))
            }
        },
        .None then [String]Option.None(),
    }
}

/// Get extension name (without the dot)
public let ext_name(path String) [String]Option = {
    when base_name(path) is {
        .Some(name) then {
            when name.find_last_index(".") is {
                .Some(idx) then {
                    if idx == 0 then {
                        [String]Option.None()
                    } else {
                        [String]Option.Some(name.slice((idx + 1)...))
                    }
                },
                .None then [String]Option.None(),
            }
        },
        .None then [String]Option.None(),
    }
}

/// Get platform path separator ("/" on Unix, "\" on Windows)
public let path_separator() String = {
    let sep = koral_path_separator()
    let mut s = String.new()
    s.push(sep)
    s
}

/// Normalize path to current platform
public let normalize_path(path String) String = {
    let buf_size = path.count() + 1
    let buf = [UInt8]alloc_memory(buf_size)
    let len = koral_normalize_path(path.storage.data, buf, buf_size)
    let result = String.from_bytes_unchecked(buf, (UInt)len)
    dealloc_memory(buf)
    result
}

/// Get platform path list separator (":" on Unix, ";" on Windows)
public let path_list_separator() String = {
    let sep = koral_path_list_separator()
    let mut s = String.new()
    s.push(sep)
    s
}


// ============================================================================
// Helper
// ============================================================================

private let get_last_error() String = {
    let err = deptr koral_errno_ptr()
    let msg = koral_strerror(err)
    String.from_cstring(msg)
}

/// Split a normalized path (using "/" separator) into a list of components.
/// Filters out empty parts from consecutive separators.
private let split_path_components(path String) [String]List = {
    let mut parts = [String]List.new()
    let normalized = path.replace_all("\\", "/")
    for part = normalized.split("/") then {
        if not part.is_empty() then {
            parts.push(part)
        }
    }
    parts
}

// ============================================================================
// New Path Functions
// ============================================================================

/// Compute the relative path from `from` to `to` (pure Koral, no FFI).
/// Both paths are normalized first. Returns Error if either path is empty.
public let relative_path(from String, to String) [String]Result = {
    if from.is_empty() then {
        return [String]Result.Error(ref "from path is empty")
    }
    if to.is_empty() then {
        return [String]Result.Error(ref "to path is empty")
    }

    let norm_from = normalize_path(from)
    let norm_to = normalize_path(to)

    // If they are the same, relative path is "."
    if norm_from == norm_to then {
        return [String]Result.Ok(".")
    }

    let from_parts = split_path_components(norm_from)
    let to_parts = split_path_components(norm_to)

    // Find common prefix length
    let mut common UInt = 0
    let from_len = from_parts.count()
    let to_len = to_parts.count()
    let min_len = if from_len < to_len then { from_len } else { to_len }

    while common < min_len and from_parts.at(common) == to_parts.at(common) then {
        common += 1
    }

    // Build relative path: ".." for each remaining component in from,
    // then append remaining components of to
    let mut result = String.new()
    let mut i = common
    while i < from_len then {
        if not result.is_empty() then {
            result.push('/')
        }
        result.push_string("..")
        i += 1
    }

    let mut j = common
    while j < to_len then {
        if not result.is_empty() then {
            result.push('/')
        }
        result.push_string(to_parts.at(j))
        j += 1
    }

    if result.is_empty() then {
        [String]Result.Ok(".")
    } else {
        [String]Result.Ok(result)
    }
}

/// Glob pattern matching: check if `name` matches `pattern`.
/// Supports `*` (match any sequence), `?` (match single char), `[abc]` (character class).
/// Pure Koral implementation.
public let glob_match(pattern String, name String) Bool = {
    glob_match_recursive(pattern, 0, name, 0)
}

/// Recursive helper for glob matching.
private let glob_match_recursive(pattern String, pi UInt, name String, ni UInt) Bool = {
    let plen = pattern.count()
    let nlen = name.count()

    let mut p = pi
    let mut n = ni

    while p < plen then {
        let pc = pattern[p]

        if pc == '*' then {
            // Skip consecutive stars
            while p < plen and pattern[p] == '*' then {
                p += 1
            }
            // Star at end matches everything
            if p == plen then {
                return true
            }
            // Try matching rest of pattern against each suffix of name
            while n <= nlen then {
                if glob_match_recursive(pattern, p, name, n) then {
                    return true
                }
                n += 1
            }
            return false
        } else if pc == '?' then {
            // Must match exactly one character
            if n >= nlen then {
                return false
            }
            p += 1
            n += 1
        } else if pc == '[' then {
            // Character class
            if n >= nlen then {
                return false
            }
            let nc = name[n]
            p += 1 // skip '['

            let mut matched = false
            let mut first = true
            let mut negate = false

            // Check for negation
            if p < plen and (pattern[p] == '!' or pattern[p] == '^') then {
                negate = true
                p += 1
            }

            while p < plen and (first or pattern[p] <> ']') then {
                first = false
                let range_start = pattern[p]
                p += 1

                // Check for range: [a-z]
                if p + 1 < plen and pattern[p] == '-' and pattern[p + 1] <> ']' then {
                    let range_end = pattern[p + 1]
                    p += 2
                    if nc >= range_start and nc <= range_end then {
                        matched = true
                    }
                } else {
                    if nc == range_start then {
                        matched = true
                    }
                }
            }

            // Skip closing ']'
            if p < plen and pattern[p] == ']' then {
                p += 1
            }

            if negate then {
                matched = not matched
            }

            if not matched then {
                return false
            }
            n += 1
        } else {
            // Literal character match
            if n >= nlen or name[n] <> pc then {
                return false
            }
            p += 1
            n += 1
        }
    }

    // Pattern consumed; name must also be consumed
    n == nlen
}

// TODO: glob() requires FFI callback support which is not yet available.
// The koral_glob FFI declaration needs a function pointer type that is
// compatible with foreign function declarations.
// public let glob(pattern String) [[String]List]Result = { ... }