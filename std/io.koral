// ============================================================================
// Koral Standard Library - IO Functions
// ============================================================================
// NOTE: This file is merged into core.koral, so all previous types are already available.
// ============================================================================

// ============================================================================
// Panic and Assertion
// ============================================================================

// High-level panic function (uses String)
public let panic(message String) Never = {
    // Write "Panic: " prefix
    let prefix = "Panic: "
    fwrite(prefix.storage.data, 1, prefix.storage.len, koral_stderr());
    // Write message
    fwrite(message.storage.data, 1, message.storage.len, koral_stderr());
    // Write newline
    let newline = "\n"
    fwrite(newline.storage.data, 1, newline.storage.len, koral_stderr());
    // Flush stderr
    fflush(koral_stderr());
    // Abort the program (generates SIGABRT, allows core dump for debugging)
    abort()
}

public let assert(condition Bool, message String) Void = {
    if not condition then { panic(message) }
}

// ============================================================================
// Standard IO Functions
// ============================================================================

// Print value to stdout (no newline, auto flush)
public let [T ToString]print(value T) Void = {
    let s = value.to_string()
    fwrite(s.storage.data, 1, s.storage.len, koral_stdout());
    fflush(koral_stdout())
}

// Print value to stdout (with newline, auto flush)
public let [T ToString]print_line(value T) Void = {
    let s = value.to_string()
    fwrite(s.storage.data, 1, s.storage.len, koral_stdout());
    let newline = "\n"
    fwrite(newline.storage.data, 1, newline.storage.len, koral_stdout());
    fflush(koral_stdout())
}


// Print value to stderr (no newline, auto flush)
public let [T ToString]print_error(value T) Void = {
    let s = value.to_string()
    fwrite(s.storage.data, 1, s.storage.len, koral_stderr());
    fflush(koral_stderr())
}

// Print value to stderr (with newline, auto flush)
public let [T ToString]print_error_line(value T) Void = {
    let s = value.to_string()
    fwrite(s.storage.data, 1, s.storage.len, koral_stderr());
    let newline = "\n"
    fwrite(newline.storage.data, 1, newline.storage.len, koral_stderr());
    fflush(koral_stderr())
}

// Read a line from stdin - Using new pattern matching
public let read_line() [String]Option = {
    let mut result = String.empty()
    
    while true then {
        let ch = fgetc(koral_stdin())
        
        // EOF - Using comparison pattern
        if ch is < 0 then {
            if result.is_empty() then {
                return [String]Option.None()
            }
            break
        }
        
        // Newline - end of line
        if ch == 10 then {  // '\n' = 10
            break
        }
        
        // Skip carriage return (for Windows line endings)
        if ch == 13 then {  // '\r' = 13
            continue
        }
        
        // Add character to result
        result.push((UInt8)ch)
    }
    
    [String]Option.Some(result)
}
