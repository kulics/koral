// ============================================================================
// std.net - UdpSocket Type
// ============================================================================
// Provides: UdpSocket
// Access via: using std.net
// ============================================================================

// ============================================================================
// UdpSocketStorage Type (internal)
// ============================================================================

/// Internal storage holding the socket file descriptor.
/// Responsible for closing the fd via drop when the last reference is released.
private type UdpSocketStorage(fd Int64)

given UdpSocketStorage {
    /// Automatically close the socket when UdpSocketStorage is dropped.
    __drop(self ref) Void = {
        if self.fd >= 0 then {
            __koral_socket_close(self.fd)
        }
    }
}

// ============================================================================
// UdpSocket Type
// ============================================================================

/// UDP socket type.
/// Internally holds a UdpSocketStorage ref, shared via reference counting.
/// The socket is automatically closed when the last reference is released.
/// Supports both connectionless (send_to/recv_from) and connected (send/recv) modes.
public type UdpSocket(private storage UdpSocketStorage ref)

// ============================================================================
// UdpSocket Methods
// ============================================================================
given UdpSocket {
    /// Bind to a socket address string.
    /// Parses the string via SocketAddr.from_string, then delegates to bind_addr.
    public bind(addr String) [UdpSocket]Result = {
        let parse_result = SocketAddr.parse(addr)
        when parse_result is {
            .Error(_) then {
                return [UdpSocket]Result.Error(ref "invalid socket address")
            },
            .Ok(sa) then {
                return UdpSocket.bind_addr(sa)
            },
        }
    }

    /// Bind to a SocketAddr.
    /// Flow: create socket (SOCK_DGRAM) â†’ bind
    /// On any failure, closes the fd and returns Error.
    public bind_addr(addr SocketAddr) [UdpSocket]Result = {
        // Determine address family from SocketAddr
        let domain Int32 = if addr.is_ipv4() then __koral_const_AF_INET() else __koral_const_AF_INET6()
        let sock_type Int32 = __koral_const_SOCK_DGRAM()
        let protocol Int32 = 0

        // Create socket
        let fd = __koral_socket_create(domain, sock_type, protocol)
        if fd < 0 then {
            return [UdpSocket]Result.Error(ref last_error_message())
        }

        // Bind to address
        let addr_bytes = addr.to_sockaddr_bytes()
        let addr_len = (UInt32)addr_bytes.count()
        let bind_result = __koral_socket_bind(fd, addr_bytes.storage.source, addr_len)
        if bind_result <> 0 then {
            __koral_socket_close(fd)
            return [UdpSocket]Result.Error(ref last_error_message())
        }

        let storage = ref UdpSocketStorage(fd)
        return [UdpSocket]Result.Ok(UdpSocket(storage))
    }

    // ========================================================================
    // Connectionless mode: send_to / recv_from
    // ========================================================================

    /// Send a datagram to the specified address.
    /// Returns the number of bytes sent.
    public send_to(self, buf io.Buffer, addr SocketAddr) [UInt]Result = {
        let to_send = buf.readable()
        if to_send == 0 then { return [UInt]Result.Ok(0) }
        let addr_bytes = addr.to_sockaddr_bytes()
        let addr_len = (UInt32)addr_bytes.count()
        let n = __koral_socket_sendto(self.storage.fd, buf.read_ptr(), (UInt64)to_send, (Int32)0, addr_bytes.storage.source, addr_len)
        if n < 0 then { return [UInt]Result.Error(ref last_error_message()) }
        buf.advance_read((UInt)n)
        return [UInt]Result.Ok((UInt)n)
    }

    /// Receive a datagram and return the number of bytes read and the sender's address.
    public recv_from(self, buf io.Buffer) [[UInt, SocketAddr]Pair]Result = {
        let available = buf.writable()
        if available == 0 then {
            return [[UInt, SocketAddr]Pair]Result.Ok([UInt, SocketAddr]Pair(0, SocketAddr.from_ipv4(Ipv4Addr.unspecified(), (UInt16)0)))
        }

        // Allocate a 128-byte buffer for the sender address
        let addr_buf = [UInt8]alloc_memory(128)
        let mut i UInt = 0
        while i < 128 then {
            init_memory(addr_buf + i, (UInt8)0)
            i += 1
        }
        let mut addr_len UInt32 = (UInt32)128

        let n = __koral_socket_recvfrom(self.storage.fd, buf.write_ptr(), (UInt64)available, (Int32)0, addr_buf, ptr addr_len)
        if n < 0 then {
            dealloc_memory(addr_buf)
            return [[UInt, SocketAddr]Pair]Result.Error(ref last_error_message())
        }

        buf.advance_write((UInt)n)

        // Parse the sockaddr bytes into a SocketAddr
        let actual_len = (UInt)addr_len
        let mut addr_list = [UInt8]List.with_capacity(actual_len)
        let mut j UInt = 0
        while j < actual_len then {
            addr_list.push(deptr (addr_buf + j))
            j += 1
        }
        dealloc_memory(addr_buf)

        let sa_result = SocketAddr.from_sockaddr_bytes(addr_list)
        when sa_result is {
            .Error(e) then {
                return [[UInt, SocketAddr]Pair]Result.Error(e)
            },
            .Ok(sender_addr) then {
                return [[UInt, SocketAddr]Pair]Result.Ok([UInt, SocketAddr]Pair((UInt)n, sender_addr))
            },
        }
    }

    // ========================================================================
    // Connected mode: connect / send / recv
    // ========================================================================

    /// Associate this socket with a remote address (connected mode).
    /// After calling connect, use send/recv instead of send_to/recv_from.
    public connect(self, addr SocketAddr) [Void]Result = {
        let addr_bytes = addr.to_sockaddr_bytes()
        let addr_len = (UInt32)addr_bytes.count()
        let result = __koral_socket_connect(self.storage.fd, addr_bytes.storage.source, addr_len)
        if result <> 0 then {
            return [Void]Result.Error(ref last_error_message())
        }
        return [Void]Result.Ok({})
    }

    /// Send data in connected mode.
    /// Returns the number of bytes sent.
    /// Returns Error if the socket is not connected.
    public send(self, buf io.Buffer) [UInt]Result = {
        let to_send = buf.readable()
        if to_send == 0 then { return [UInt]Result.Ok(0) }
        let n = __koral_socket_send(self.storage.fd, buf.read_ptr(), (UInt64)to_send, (Int32)0)
        if n < 0 then { return [UInt]Result.Error(ref last_error_message()) }
        buf.advance_read((UInt)n)
        return [UInt]Result.Ok((UInt)n)
    }

    /// Receive data in connected mode.
    /// Returns the number of bytes received.
    /// Returns Error if the socket is not connected.
    public recv(self, buf io.Buffer) [UInt]Result = {
        let available = buf.writable()
        if available == 0 then { return [UInt]Result.Ok(0) }
        let n = __koral_socket_recv(self.storage.fd, buf.write_ptr(), (UInt64)available, (Int32)0)
        if n < 0 then { return [UInt]Result.Error(ref last_error_message()) }
        buf.advance_write((UInt)n)
        return [UInt]Result.Ok((UInt)n)
    }

    // ========================================================================
    // Address query methods
    // ========================================================================

    /// Get the local address this socket is bound to.
    public local_addr(self) [SocketAddr]Result = {
        let addr_buf = [UInt8]alloc_memory(128)
        let mut i UInt = 0
        while i < 128 then {
            init_memory(addr_buf + i, (UInt8)0)
            i += 1
        }
        let mut addr_len UInt32 = (UInt32)128

        let result = __koral_socket_getsockname(self.storage.fd, addr_buf, ptr addr_len)
        if result <> 0 then {
            dealloc_memory(addr_buf)
            return [SocketAddr]Result.Error(ref last_error_message())
        }

        let actual_len = (UInt)addr_len
        let mut addr_list = [UInt8]List.with_capacity(actual_len)
        let mut j UInt = 0
        while j < actual_len then {
            addr_list.push(deptr (addr_buf + j))
            j += 1
        }
        dealloc_memory(addr_buf)

        return SocketAddr.from_sockaddr_bytes(addr_list)
    }

    /// Get the peer address of this socket (connected mode only).
    /// Returns Error if the socket is not connected.
    public peer_addr(self) [SocketAddr]Result = {
        let addr_buf = [UInt8]alloc_memory(128)
        let mut i UInt = 0
        while i < 128 then {
            init_memory(addr_buf + i, (UInt8)0)
            i += 1
        }
        let mut addr_len UInt32 = (UInt32)128

        let result = __koral_socket_getpeername(self.storage.fd, addr_buf, ptr addr_len)
        if result <> 0 then {
            dealloc_memory(addr_buf)
            return [SocketAddr]Result.Error(ref last_error_message())
        }

        let actual_len = (UInt)addr_len
        let mut addr_list = [UInt8]List.with_capacity(actual_len)
        let mut j UInt = 0
        while j < actual_len then {
            addr_list.push(deptr (addr_buf + j))
            j += 1
        }
        dealloc_memory(addr_buf)

        return SocketAddr.from_sockaddr_bytes(addr_list)
    }

    // ========================================================================
    // SO_BROADCAST option
    // ========================================================================

    /// Set SO_BROADCAST option.
    /// level=1 (SOL_SOCKET), optname=6 (SO_BROADCAST)
    public set_broadcast(self, broadcast Bool) [Void]Result = {
        let opt_buf = [UInt8]alloc_memory(4)
        let val UInt8 = if broadcast then (UInt8)1 else (UInt8)0
        init_memory(opt_buf + 0, val)
        init_memory(opt_buf + 1, (UInt8)0)
        init_memory(opt_buf + 2, (UInt8)0)
        init_memory(opt_buf + 3, (UInt8)0)
        let result = __koral_socket_setsockopt(self.storage.fd, __koral_const_SOL_SOCKET(), __koral_const_SO_BROADCAST(), opt_buf, (UInt32)4)
        dealloc_memory(opt_buf)
        if result <> 0 then {
            return [Void]Result.Error(ref last_error_message())
        }
        return [Void]Result.Ok({})
    }

    /// Get SO_BROADCAST option.
    /// level=1 (SOL_SOCKET), optname=6 (SO_BROADCAST)
    public broadcast(self) [Bool]Result = {
        let opt_buf = [UInt8]alloc_memory(4)
        init_memory(opt_buf + 0, (UInt8)0)
        init_memory(opt_buf + 1, (UInt8)0)
        init_memory(opt_buf + 2, (UInt8)0)
        init_memory(opt_buf + 3, (UInt8)0)
        let mut opt_len UInt32 = (UInt32)4
        let result = __koral_socket_getsockopt(self.storage.fd, __koral_const_SOL_SOCKET(), __koral_const_SO_BROADCAST(), opt_buf, ptr opt_len)
        if result <> 0 then {
            dealloc_memory(opt_buf)
            return [Bool]Result.Error(ref last_error_message())
        }
        let val = deptr opt_buf
        dealloc_memory(opt_buf)
        return [Bool]Result.Ok(val <> (UInt8)0)
    }

    // ========================================================================
    // Timeout options (SO_RCVTIMEO / SO_SNDTIMEO)
    // ========================================================================

    /// Set read timeout. None clears the timeout.
    /// SO_RCVTIMEO: level=1 (SOL_SOCKET), optname=20 (Linux)
    /// struct timeval: tv_sec (8 bytes, Int64) + tv_usec (8 bytes, Int64) = 16 bytes
    public set_read_timeout(self, timeout [Duration]Option) [Void]Result = {
        let tv_buf = [UInt8]alloc_memory(16)
        when timeout is {
            .None then {
                // Zero timeval clears the timeout
                let mut i UInt = 0
                while i < 16 then {
                    init_memory(tv_buf + i, (UInt8)0)
                    i += 1
                }
            },
            .Some(duration) then {
                UdpSocket.duration_to_timeval(duration, tv_buf)
            },
        }
        let result = __koral_socket_setsockopt(self.storage.fd, __koral_const_SOL_SOCKET(), __koral_const_SO_RCVTIMEO(), tv_buf, (UInt32)16)
        dealloc_memory(tv_buf)
        if result <> 0 then {
            return [Void]Result.Error(ref last_error_message())
        }
        return [Void]Result.Ok({})
    }

    /// Set write timeout. None clears the timeout.
    /// SO_SNDTIMEO: level=1 (SOL_SOCKET), optname=21 (Linux)
    public set_write_timeout(self, timeout [Duration]Option) [Void]Result = {
        let tv_buf = [UInt8]alloc_memory(16)
        when timeout is {
            .None then {
                let mut i UInt = 0
                while i < 16 then {
                    init_memory(tv_buf + i, (UInt8)0)
                    i += 1
                }
            },
            .Some(duration) then {
                UdpSocket.duration_to_timeval(duration, tv_buf)
            },
        }
        let result = __koral_socket_setsockopt(self.storage.fd, __koral_const_SOL_SOCKET(), __koral_const_SO_SNDTIMEO(), tv_buf, (UInt32)16)
        dealloc_memory(tv_buf)
        if result <> 0 then {
            return [Void]Result.Error(ref last_error_message())
        }
        return [Void]Result.Ok({})
    }

    /// Get read timeout. Returns None if no timeout is set.
    /// SO_RCVTIMEO: level=1 (SOL_SOCKET), optname=20 (Linux)
    public read_timeout(self) [[Duration]Option]Result = {
        let tv_buf = [UInt8]alloc_memory(16)
        let mut i UInt = 0
        while i < 16 then {
            init_memory(tv_buf + i, (UInt8)0)
            i += 1
        }
        let mut opt_len UInt32 = (UInt32)16
        let result = __koral_socket_getsockopt(self.storage.fd, __koral_const_SOL_SOCKET(), __koral_const_SO_RCVTIMEO(), tv_buf, ptr opt_len)
        if result <> 0 then {
            dealloc_memory(tv_buf)
            return [[Duration]Option]Result.Error(ref last_error_message())
        }
        let duration_opt = UdpSocket.timeval_to_duration(tv_buf)
        dealloc_memory(tv_buf)
        return [[Duration]Option]Result.Ok(duration_opt)
    }

    /// Get write timeout. Returns None if no timeout is set.
    /// SO_SNDTIMEO: level=1 (SOL_SOCKET), optname=21 (Linux)
    public write_timeout(self) [[Duration]Option]Result = {
        let tv_buf = [UInt8]alloc_memory(16)
        let mut i UInt = 0
        while i < 16 then {
            init_memory(tv_buf + i, (UInt8)0)
            i += 1
        }
        let mut opt_len UInt32 = (UInt32)16
        let result = __koral_socket_getsockopt(self.storage.fd, __koral_const_SOL_SOCKET(), __koral_const_SO_SNDTIMEO(), tv_buf, ptr opt_len)
        if result <> 0 then {
            dealloc_memory(tv_buf)
            return [[Duration]Option]Result.Error(ref last_error_message())
        }
        let duration_opt = UdpSocket.timeval_to_duration(tv_buf)
        dealloc_memory(tv_buf)
        return [[Duration]Option]Result.Ok(duration_opt)
    }

    // ========================================================================
    // Private helpers for timeval conversion
    // ========================================================================

    /// Convert a Duration to a struct timeval (16 bytes) in a raw buffer.
    /// timeval layout: tv_sec (Int64, 8 bytes LE) + tv_usec (Int64, 8 bytes LE)
    private duration_to_timeval(duration Duration, buf UInt8 ptr) Void = {
        let secs = duration.secs
        let usec = duration.nanos / 1000

        // Write tv_sec as little-endian Int64 (bytes 0..7)
        init_memory(buf + 0, (UInt8)(secs & 255))
        init_memory(buf + 1, (UInt8)((secs >> 8) & 255))
        init_memory(buf + 2, (UInt8)((secs >> 16) & 255))
        init_memory(buf + 3, (UInt8)((secs >> 24) & 255))
        init_memory(buf + 4, (UInt8)((secs >> 32) & 255))
        init_memory(buf + 5, (UInt8)((secs >> 40) & 255))
        init_memory(buf + 6, (UInt8)((secs >> 48) & 255))
        init_memory(buf + 7, (UInt8)((secs >> 56) & 255))

        // Write tv_usec as little-endian Int64 (bytes 8..15)
        init_memory(buf + 8, (UInt8)(usec & 255))
        init_memory(buf + 9, (UInt8)((usec >> 8) & 255))
        init_memory(buf + 10, (UInt8)((usec >> 16) & 255))
        init_memory(buf + 11, (UInt8)((usec >> 24) & 255))
        init_memory(buf + 12, (UInt8)((usec >> 32) & 255))
        init_memory(buf + 13, (UInt8)((usec >> 40) & 255))
        init_memory(buf + 14, (UInt8)((usec >> 48) & 255))
        init_memory(buf + 15, (UInt8)((usec >> 56) & 255))
    }

    /// Convert a struct timeval (16 bytes) from a raw buffer to a [Duration]Option.
    /// Returns None if both tv_sec and tv_usec are zero (no timeout set).
    private timeval_to_duration(buf UInt8 ptr) [Duration]Option = {
        // Read tv_sec as little-endian Int64 (bytes 0..7)
        let secs = (Int64)(UInt)deptr (buf + 0)
            + ((Int64)(UInt)deptr (buf + 1) << 8)
            + ((Int64)(UInt)deptr (buf + 2) << 16)
            + ((Int64)(UInt)deptr (buf + 3) << 24)
            + ((Int64)(UInt)deptr (buf + 4) << 32)
            + ((Int64)(UInt)deptr (buf + 5) << 40)
            + ((Int64)(UInt)deptr (buf + 6) << 48)
            + ((Int64)(UInt)deptr (buf + 7) << 56)

        // Read tv_usec as little-endian Int64 (bytes 8..15)
        let usec = (Int64)(UInt)deptr (buf + 8)
            + ((Int64)(UInt)deptr (buf + 9) << 8)
            + ((Int64)(UInt)deptr (buf + 10) << 16)
            + ((Int64)(UInt)deptr (buf + 11) << 24)
            + ((Int64)(UInt)deptr (buf + 12) << 32)
            + ((Int64)(UInt)deptr (buf + 13) << 40)
            + ((Int64)(UInt)deptr (buf + 14) << 48)
            + ((Int64)(UInt)deptr (buf + 15) << 56)

        // Zero timeval means no timeout
        if secs == 0 and usec == 0 then {
            return [Duration]Option.None()
        }

        let nanos = usec * 1000
        return [Duration]Option.Some(Duration(secs, nanos))
    }
}
