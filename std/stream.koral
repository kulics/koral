// ============================================================================
// Koral Standard Library - Stream API
// ============================================================================
// Provides lazy, chainable operations on iterators similar to Java Streams.
// ============================================================================

// ============================================================================
// Stream Type Definition
// ============================================================================

// Stream wraps an iterator and provides chainable operations
public type [T Any, R [T]Iterator]Stream(mut iter R)

// Global entry point - creates a Stream from any Iterable
public let [T Any, R [T]Iterator, C [T, R]Iterable]stream(c C) [T, R]Stream = 
    [T, R]Stream(c.iterator())

// ============================================================================
// Helper Types
// ============================================================================

// Indexed - produced by enumerate(), pairs index with value
public type [T Any]Indexed(index Int, value T)

// ============================================================================
// Intermediate Iterator Types
// ============================================================================

// FilterStreamIterator - filters elements based on predicate
public type [T Any, R [T]Iterator]FilterStreamIterator(
    mut iter R,
    predicate [T, Bool]Func
)

given [T Any, R [T]Iterator] [T, R]FilterStreamIterator {
    public next(self ref) [T]Option = {
        while self.iter.next() is .Some(v) then {
            if self.predicate(v) then {
                return [T]Option.Some(v)
            }
        }
        [T]Option.None()
    }
}

// MapStreamIterator - transforms elements using mapper function
public type [T Any, U Any, R [T]Iterator]MapStreamIterator(
    mut iter R,
    mapper [T, U]Func
)

given [T Any, U Any, R [T]Iterator] [T, U, R]MapStreamIterator {
    public next(self ref) [U]Option = {
        when self.iter.next() is {
            .Some(v) then [U]Option.Some(self.mapper(v)),
            .None then [U]Option.None(),
        }
    }
}

// FilterMapStreamIterator - filters and transforms in one operation
public type [T Any, U Any, R [T]Iterator]FilterMapStreamIterator(
    mut iter R,
    mapper [T, [U]Option]Func
)

given [T Any, U Any, R [T]Iterator] [T, U, R]FilterMapStreamIterator {
    public next(self ref) [U]Option = {
        while self.iter.next() is .Some(v) then {
            when self.mapper(v) is {
                .Some(u) then { return [U]Option.Some(u); },
                .None then {},
            }
        }
        [U]Option.None()
    }
}

// TakeStreamIterator - takes first n elements
public type [T Any, R [T]Iterator]TakeStreamIterator(
    mut iter R,
    mut remaining Int
)

given [T Any, R [T]Iterator] [T, R]TakeStreamIterator {
    public next(self ref) [T]Option = {
        if self.remaining <= 0 then { return [T]Option.None(); }
        self.remaining -= 1
        self.iter.next()
    }
}

// SkipStreamIterator - skips first n elements
public type [T Any, R [T]Iterator]SkipStreamIterator(
    mut iter R,
    mut to_skip Int
)

given [T Any, R [T]Iterator] [T, R]SkipStreamIterator {
    public next(self ref) [T]Option = {
        while self.to_skip > 0 then {
            when self.iter.next() is {
                .Some(_) then { self.to_skip -= 1; },
                .None then { return [T]Option.None(); },
            }
        }
        self.iter.next()
    }
}

// StepStreamIterator - takes every nth element
public type [T Any, R [T]Iterator]StepStreamIterator(
    mut iter R,
    step_size Int,
    mut first Bool
)

given [T Any, R [T]Iterator] [T, R]StepStreamIterator {
    public next(self ref) [T]Option = {
        if self.first then {
            self.first = false
            return self.iter.next()
        }
        // Skip step_size - 1 elements
        let mut i = 1
        while i < self.step_size then {
            when self.iter.next() is {
                .None then { return [T]Option.None(); },
                .Some(_) then { i += 1; },
            }
        }
        self.iter.next()
    }
}

// EnumerateStreamIterator - pairs each element with its index
public type [T Any, R [T]Iterator]EnumerateStreamIterator(
    mut iter R,
    mut index Int
)

given [T Any, R [T]Iterator] [T, R]EnumerateStreamIterator {
    public next(self ref) [[T]Indexed]Option = {
        when self.iter.next() is {
            .Some(v) then {
                let idx = self.index
                self.index += 1
                [[T]Indexed]Option.Some([T]Indexed(idx, v))
            },
            .None then [[T]Indexed]Option.None(),
        }
    }
}

// PeekStreamIterator - executes side effect without modifying elements
public type [T Any, R [T]Iterator]PeekStreamIterator(
    mut iter R,
    action [T, Void]Func
)

given [T Any, R [T]Iterator] [T, R]PeekStreamIterator {
    public next(self ref) [T]Option = {
        when self.iter.next() is {
            .Some(v) then {
                self.action(v);
                [T]Option.Some(v)
            },
            .None then [T]Option.None(),
        }
    }
}

// IntersperseStreamIterator - inserts separator between elements
public type [T Any, R [T]Iterator]IntersperseStreamIterator(
    mut iter R,
    separator T,
    mut next_is_separator Bool,
    mut pending [T]Option
)

given [T Any, R [T]Iterator] [T, R]IntersperseStreamIterator {
    public next(self ref) [T]Option = {
        // If we need to return separator
        if self.next_is_separator then {
            when self.pending is {
                .Some(_) then {
                    self.next_is_separator = false
                    return [T]Option.Some(self.separator)
                },
                .None then {},
            }
        }
        // Return pending value
        when self.pending is {
            .Some(v) then {
                self.pending = [T]Option.None()
                // Prefetch next element
                when self.iter.next() is {
                    .Some(next_v) then {
                        self.pending = [T]Option.Some(next_v)
                        self.next_is_separator = true
                    },
                    .None then {},
                }
                return [T]Option.Some(v)
            },
            .None then {
                // First call, get first element
                when self.iter.next() is {
                    .Some(v) then {
                        // Prefetch next
                        when self.iter.next() is {
                            .Some(next_v) then {
                                self.pending = [T]Option.Some(next_v)
                                self.next_is_separator = true
                            },
                            .None then {},
                        }
                        return [T]Option.Some(v)
                    },
                    .None then [T]Option.None(),
                }
            },
        }
    }
}

// TakeWhileStreamIterator - takes elements while predicate is true
public type [T Any, R [T]Iterator]TakeWhileStreamIterator(
    mut iter R,
    predicate [T, Bool]Func,
    mut done Bool
)

given [T Any, R [T]Iterator] [T, R]TakeWhileStreamIterator {
    public next(self ref) [T]Option = {
        if self.done then { return [T]Option.None(); }
        when self.iter.next() is {
            .Some(v) then {
                if self.predicate(v) then {
                    [T]Option.Some(v)
                } else {
                    self.done = true
                    [T]Option.None()
                }
            },
            .None then [T]Option.None(),
        }
    }
}

// SkipWhileStreamIterator - skips elements while predicate is true
public type [T Any, R [T]Iterator]SkipWhileStreamIterator(
    mut iter R,
    predicate [T, Bool]Func,
    mut skipping Bool
)

given [T Any, R [T]Iterator] [T, R]SkipWhileStreamIterator {
    public next(self ref) [T]Option = {
        if not self.skipping then {
            return self.iter.next()
        }
        while self.iter.next() is .Some(v) then {
            if not self.predicate(v) then {
                self.skipping = false
                return [T]Option.Some(v)
            }
        }
        [T]Option.None()
    }
}

// ChainStreamIterator - chains two iterators of the same element type
public type [T Any, R1 [T]Iterator, R2 [T]Iterator]ChainStreamIterator(
    mut first R1,
    mut second R2,
    mut use_second Bool
)

given [T Any, R1 [T]Iterator, R2 [T]Iterator] [T, R1, R2]ChainStreamIterator {
    public next(self ref) [T]Option = {
        if not self.use_second then {
            when self.first.next() is {
                .Some(v) then { return [T]Option.Some(v); },
                .None then { self.use_second = true; },
            }
        }
        self.second.next()
    }
}

// ZipStreamIterator - zips two iterators into pairs
public type [A Any, B Any, R1 [A]Iterator, R2 [B]Iterator]ZipStreamIterator(
    mut first R1,
    mut second R2
)

given [A Any, B Any, R1 [A]Iterator, R2 [B]Iterator] [A, B, R1, R2]ZipStreamIterator {
    public next(self ref) [[A, B]Pair]Option = {
        when self.first.next() is {
            .Some(a) then {
                when self.second.next() is {
                    .Some(b) then [[A, B]Pair]Option.Some([A, B]Pair(a, b)),
                    .None then [[A, B]Pair]Option.None(),
                }
            },
            .None then [[A, B]Pair]Option.None(),
        }
    }
}

// FlatMapStreamIterator - flattens nested iterators (fully lazy)
public type [T Any, U Any, R [T]Iterator, InnerR [U]Iterator]FlatMapStreamIterator(
    mut outer R,
    mapper [T, InnerR]Func,
    mut current_inner [InnerR]Option
)

given [T Any, U Any, R [T]Iterator, InnerR [U]Iterator] [T, U, R, InnerR]FlatMapStreamIterator {
    public next(self ref) [U]Option = {
        while true then {
            when self.current_inner is {
                .Some(inner) then {
                    // Copy out the inner iterator
                    let mut inner_copy = inner
                    when inner_copy.next() is {
                        .Some(v) then {
                            // Write modified iterator back
                            self.current_inner = [InnerR]Option.Some(inner_copy)
                            return [U]Option.Some(v)
                        },
                        .None then {
                            // Inner exhausted, clear it
                            self.current_inner = [InnerR]Option.None()
                        },
                    }
                },
                .None then {
                    // Get next from outer iterator
                    when self.outer.next() is {
                        .None then { return [U]Option.None(); },
                        .Some(outer_val) then {
                            self.current_inner = [InnerR]Option.Some(self.mapper(outer_val))
                        },
                    }
                },
            }
        }
        [U]Option.None()
    }
}


// ============================================================================
// Stream Intermediate Operations
// ============================================================================

given [T Any, R [T]Iterator] [T, R]Stream {
    // Filter - returns stream with elements matching predicate
    public filter(self, fn [T, Bool]Func) [T, [T, R]FilterStreamIterator]Stream =
        [T, [T, R]FilterStreamIterator]Stream([T, R]FilterStreamIterator(self.iter, fn))
    
    // Map - transforms each element
    public [U Any]map(self, fn [T, U]Func) [U, [T, U, R]MapStreamIterator]Stream =
        [U, [T, U, R]MapStreamIterator]Stream([T, U, R]MapStreamIterator(self.iter, fn))
    
    // FilterMap - filter and transform in one operation
    public [U Any]filter_map(self, fn [T, [U]Option]Func) [U, [T, U, R]FilterMapStreamIterator]Stream =
        [U, [T, U, R]FilterMapStreamIterator]Stream([T, U, R]FilterMapStreamIterator(self.iter, fn))
    
    // Take - take first n elements
    public take(self, n Int) [T, [T, R]TakeStreamIterator]Stream =
        [T, [T, R]TakeStreamIterator]Stream([T, R]TakeStreamIterator(self.iter, n))
    
    // Skip - skip first n elements
    public skip(self, n Int) [T, [T, R]SkipStreamIterator]Stream =
        [T, [T, R]SkipStreamIterator]Stream([T, R]SkipStreamIterator(self.iter, n))
    
    // StepBy - take every nth element
    public step_by(self, n Int) [T, [T, R]StepStreamIterator]Stream = {
        if n < 1 then { panic("step size must be at least 1"); }
        [T, [T, R]StepStreamIterator]Stream([T, R]StepStreamIterator(self.iter, n, true))
    }
    
    // Enumerate - pair each element with its index
    public enumerate(self) [[T]Indexed, [T, R]EnumerateStreamIterator]Stream =
        [[T]Indexed, [T, R]EnumerateStreamIterator]Stream([T, R]EnumerateStreamIterator(self.iter, 0))
    
    // Peek - execute side effect without modifying elements
    public peek(self, fn [T, Void]Func) [T, [T, R]PeekStreamIterator]Stream =
        [T, [T, R]PeekStreamIterator]Stream([T, R]PeekStreamIterator(self.iter, fn))
    
    // Intersperse - insert separator between elements
    public intersperse(self, v T) [T, [T, R]IntersperseStreamIterator]Stream =
        [T, [T, R]IntersperseStreamIterator]Stream([T, R]IntersperseStreamIterator(self.iter, v, false, [T]Option.None()))
    
    // TakeWhile - take elements while predicate is true
    public take_while(self, fn [T, Bool]Func) [T, [T, R]TakeWhileStreamIterator]Stream =
        [T, [T, R]TakeWhileStreamIterator]Stream([T, R]TakeWhileStreamIterator(self.iter, fn, false))
    
    // SkipWhile - skip elements while predicate is true
    public skip_while(self, fn [T, Bool]Func) [T, [T, R]SkipWhileStreamIterator]Stream =
        [T, [T, R]SkipWhileStreamIterator]Stream([T, R]SkipWhileStreamIterator(self.iter, fn, true))
    
    // Chain - chain with another iterator of the same element type
    public [R2 [T]Iterator]chain(self, other R2) [T, [T, R, R2]ChainStreamIterator]Stream =
        [T, [T, R, R2]ChainStreamIterator]Stream([T, R, R2]ChainStreamIterator(self.iter, other, false))
    
    // Zip - zip with another iterator into pairs
    public [U Any, R2 [U]Iterator]zip(self, other R2) [[T, U]Pair, [T, U, R, R2]ZipStreamIterator]Stream =
        [[T, U]Pair, [T, U, R, R2]ZipStreamIterator]Stream([T, U, R, R2]ZipStreamIterator(self.iter, other))
    
    // FlatMap - map each element to an iterator and flatten results
    public [U Any, InnerR [U]Iterator]flat_map(self, fn [T, InnerR]Func) [U, [T, U, R, InnerR]FlatMapStreamIterator]Stream =
        [U, [T, U, R, InnerR]FlatMapStreamIterator]Stream([T, U, R, InnerR]FlatMapStreamIterator(self.iter, fn, [InnerR]Option.None()))
}

// ============================================================================
// Stream Terminal Operations
// ============================================================================

given [T Any, R [T]Iterator] [T, R]Stream {
    // Fold - reduce with initial value
    public [U Any]fold(self, initial U, fn [U, T, U]Func) U = {
        let mut acc = initial
        let mut it = self.iter
        while it.next() is .Some(v) then {
            acc = fn(acc, v)
        }
        acc
    }
    
    // Reduce - reduce without initial value
    public reduce(self, fn [T, T, T]Func) [T]Option = {
        let mut it = self.iter
        when it.next() is {
            .None then [T]Option.None(),
            .Some(first) then {
                let mut acc = first
                while it.next() is .Some(v) then {
                    acc = fn(acc, v)
                }
                [T]Option.Some(acc)
            },
        }
    }
    
    // ToList - collect into List
    public to_list(self) [T]List = {
        let mut result = [T]List.new()
        let mut it = self.iter
        while it.next() is .Some(v) then {
            result.push(v)
        }
        result
    }
    
    // ForEach - execute side effect for each element
    public for_each(self, fn [T, Void]Func) Void = {
        let mut it = self.iter
        while it.next() is .Some(v) then {
            fn(v);
        }
    }
    
    // Count - count elements
    public count(self) Int = {
        let mut n = 0
        let mut it = self.iter
        while it.next() is .Some(_) then {
            n += 1
        }
        n
    }
    
    // First - get first element
    public first(self) [T]Option = self.iter.next()
    
    // Last - get last element
    public last(self) [T]Option = {
        let mut result = [T]Option.None()
        let mut it = self.iter
        while it.next() is .Some(v) then {
            result = [T]Option.Some(v)
        }
        result
    }
    
    // Get - get element at index
    public get(self, n Int) [T]Option = {
        if n < 0 then { return [T]Option.None(); }
        let mut it = self.iter
        let mut i = 0
        while it.next() is .Some(v) then {
            if i == n then { return [T]Option.Some(v); }
            i += 1
        }
        [T]Option.None()
    }
    
    // FindIndex - find index of first element matching predicate
    public find_index(self, fn [T, Bool]Func) [Int]Option = {
        let mut it = self.iter
        let mut i = 0
        while it.next() is .Some(v) then {
            if fn(v) then { return [Int]Option.Some(i); }
            i += 1
        }
        [Int]Option.None()
    }
    
    // FindMap - find first element that maps to Some
    public [U Any]find_map(self, fn [T, [U]Option]Func) [U]Option = {
        let mut it = self.iter
        while it.next() is .Some(v) then {
            when fn(v) is {
                .Some(u) then { return [U]Option.Some(u); },
                .None then {},
            }
        }
        [U]Option.None()
    }
    
    // AnyMatch - check if any element matches predicate
    public any_match(self, fn [T, Bool]Func) Bool = {
        let mut it = self.iter
        while it.next() is .Some(v) then {
            if fn(v) then { return true; }
        }
        false
    }
    
    // AllMatch - check if all elements match predicate
    public all_match(self, fn [T, Bool]Func) Bool = {
        let mut it = self.iter
        while it.next() is .Some(v) then {
            if not fn(v) then { return false; }
        }
        true
    }
    
    // NoneMatch - check if no element matches predicate
    public none_match(self, fn [T, Bool]Func) Bool = {
        let mut it = self.iter
        while it.next() is .Some(v) then {
            if fn(v) then { return false; }
        }
        true
    }
    
    // IsEmpty - check if stream has no elements
    public is_empty(self) Bool = self.iter.next().is_none()
    
    // MaxBy - find element with maximum key
    public [K Ord]max_by(self, fn [T, K]Func) [T]Option = {
        let mut it = self.iter
        when it.next() is {
            .None then [T]Option.None(),
            .Some(first) then {
                let mut result = first
                let mut result_key = fn(first)
                while it.next() is .Some(v) then {
                    let key = fn(v)
                    if key > result_key then {
                        result = v
                        result_key = key
                    }
                }
                [T]Option.Some(result)
            },
        }
    }
    
    // MinBy - find element with minimum key
    public [K Ord]min_by(self, fn [T, K]Func) [T]Option = {
        let mut it = self.iter
        when it.next() is {
            .None then [T]Option.None(),
            .Some(first) then {
                let mut result = first
                let mut result_key = fn(first)
                while it.next() is .Some(v) then {
                    let key = fn(v)
                    if key < result_key then {
                        result = v
                        result_key = key
                    }
                }
                [T]Option.Some(result)
            },
        }
    }
}

// ============================================================================
// Stream Terminal Operations with Eq constraint
// ============================================================================

given [T Eq, R [T]Iterator] [T, R]Stream {
    // Contains - check if stream contains a value
    public contains(self, value T) Bool = {
        let mut it = self.iter
        while it.next() is .Some(v) then {
            if v == value then { return true; }
        }
        false
    }
}

// ============================================================================
// Stream Terminal Operations with Ord constraint
// ============================================================================

given [T Ord, R [T]Iterator] [T, R]Stream {
    // Max - find maximum element
    public max(self) [T]Option = {
        let mut it = self.iter
        when it.next() is {
            .None then [T]Option.None(),
            .Some(first) then {
                let mut result = first
                while it.next() is .Some(v) then {
                    if v > result then { result = v; }
                }
                [T]Option.Some(result)
            },
        }
    }
    
    // Min - find minimum element
    public min(self) [T]Option = {
        let mut it = self.iter
        when it.next() is {
            .None then [T]Option.None(),
            .Some(first) then {
                let mut result = first
                while it.next() is .Some(v) then {
                    if v < result then { result = v; }
                }
                [T]Option.Some(result)
            },
        }
    }
}

// ============================================================================
// Stream Terminal Operations with Hashable constraint
// ============================================================================

given [T Hashable, R [T]Iterator] [T, R]Stream {
    // ToSet - collect into Set
    public to_set(self) [T]Set = {
        let mut result = [T]Set.new()
        let mut it = self.iter
        while it.next() is .Some(v) then {
            result.insert(v);
        }
        result
    }
}

// ============================================================================
// Stream Numeric Aggregations
// ============================================================================

given [T Add, R [T]Iterator] [T, R]Stream {
    // Sum - sums elements using Add.zero/add
    public sum(self) T = {
        let mut acc = T.zero()
        let mut it = self.iter
        while it.next() is .Some(v) then {
            acc = acc.add(v)
        }
        acc
    }
}

given [T Mul, R [T]Iterator] [T, R]Stream {
    // Product - multiplies elements using Mul.one/mul
    public product(self) T = {
        let mut acc = T.one()
        let mut it = self.iter
        while it.next() is .Some(v) then {
            acc = acc.mul(v)
        }
        acc
    }
}

given [T Add and Div, R [T]Iterator] [T, R]Stream {
    // Average - returns None for empty streams to avoid division by zero.
    public average(self) [T]Option = {
        let mut acc = T.zero()
        let mut count = 0
        let mut count_t = T.zero()
        let mut it = self.iter
        while it.next() is .Some(v) then {
            acc = acc.add(v)
            count += 1
            count_t = count_t.add(T.one())
        }
        if count == 0 then {
            [T]Option.None()
        } else {
            [T]Option.Some(acc.div(count_t))
        }
    }
}
