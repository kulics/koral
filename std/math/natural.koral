// ============================================================================
// std.math - Unsigned Integer (Natural) Module
// ============================================================================

// --- given UInt ---
given UInt {
    protected abs_impl(x Self) Self = x
    protected wrapping_abs_impl(x Self) Self = x

    protected pow_impl(base Self, exp UInt) Self = {
        let mut result UInt = 1
        let mut b = base
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result * b }
            b = b * b
            e = e / 2
        }
        return result
    }

    protected wrapping_pow_impl(base Self, exp UInt) Self = {
        let mut result UInt = 1
        let mut b = base
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        return result
    }

    protected gcd_impl(a Self, b Self) Self = {
        let mut x = a
        let mut y = b
        while y <> 0 then {
            let t = y
            y = x % y
            x = t
        }
        return x
    }

    protected lcm_impl(a Self, b Self) Self =
        if a == 0 or b == 0 then 0
        else (a / UInt.gcd_impl(a, b)) * b

    protected ilog2_impl(x Self) UInt = {
        if x == 0 then panic("ilog2: argument is zero")
        let mut result UInt = 0
        let mut n = x
        while n > 1 then {
            n = n / 2
            result = result + 1
        }
        return result
    }

    protected ilog10_impl(x Self) UInt = {
        if x == 0 then panic("ilog10: argument is zero")
        let mut result UInt = 0
        let mut n = x
        while n >= 10 then {
            n = n / 10
            result = result + 1
        }
        return result
    }
}

// --- given UInt8 ---
given UInt8 {
    protected abs_impl(x Self) Self = x
    protected wrapping_abs_impl(x Self) Self = x

    protected pow_impl(base Self, exp UInt) Self = {
        let mut result UInt8 = 1
        let mut b = base
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result * b }
            b = b * b
            e = e / 2
        }
        return result
    }

    protected wrapping_pow_impl(base Self, exp UInt) Self = {
        let mut result UInt8 = 1
        let mut b = base
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        return result
    }

    protected gcd_impl(a Self, b Self) Self = {
        let mut x = a
        let mut y = b
        while y <> 0 then {
            let t = y
            y = x % y
            x = t
        }
        return x
    }

    protected lcm_impl(a Self, b Self) Self =
        if a == 0 or b == 0 then 0
        else (a / UInt8.gcd_impl(a, b)) * b

    protected ilog2_impl(x Self) UInt = {
        if x == 0 then panic("ilog2: argument is zero")
        let mut result UInt = 0
        let mut n = x
        while n > 1 then {
            n = n / 2
            result = result + 1
        }
        return result
    }

    protected ilog10_impl(x Self) UInt = {
        if x == 0 then panic("ilog10: argument is zero")
        let mut result UInt = 0
        let mut n = x
        while n >= 10 then {
            n = n / 10
            result = result + 1
        }
        return result
    }
}


// --- given UInt16 ---
given UInt16 {
    protected abs_impl(x Self) Self = x
    protected wrapping_abs_impl(x Self) Self = x

    protected pow_impl(base Self, exp UInt) Self = {
        let mut result UInt16 = 1
        let mut b = base
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result * b }
            b = b * b
            e = e / 2
        }
        return result
    }

    protected wrapping_pow_impl(base Self, exp UInt) Self = {
        let mut result UInt16 = 1
        let mut b = base
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        return result
    }

    protected gcd_impl(a Self, b Self) Self = {
        let mut x = a
        let mut y = b
        while y <> 0 then {
            let t = y
            y = x % y
            x = t
        }
        return x
    }

    protected lcm_impl(a Self, b Self) Self =
        if a == 0 or b == 0 then 0
        else (a / UInt16.gcd_impl(a, b)) * b

    protected ilog2_impl(x Self) UInt = {
        if x == 0 then panic("ilog2: argument is zero")
        let mut result UInt = 0
        let mut n = x
        while n > 1 then {
            n = n / 2
            result = result + 1
        }
        return result
    }

    protected ilog10_impl(x Self) UInt = {
        if x == 0 then panic("ilog10: argument is zero")
        let mut result UInt = 0
        let mut n = x
        while n >= 10 then {
            n = n / 10
            result = result + 1
        }
        return result
    }
}


// --- given UInt32 ---
given UInt32 {
    protected abs_impl(x Self) Self = x
    protected wrapping_abs_impl(x Self) Self = x

    protected pow_impl(base Self, exp UInt) Self = {
        let mut result UInt32 = 1
        let mut b = base
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result * b }
            b = b * b
            e = e / 2
        }
        return result
    }

    protected wrapping_pow_impl(base Self, exp UInt) Self = {
        let mut result UInt32 = 1
        let mut b = base
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        return result
    }

    protected gcd_impl(a Self, b Self) Self = {
        let mut x = a
        let mut y = b
        while y <> 0 then {
            let t = y
            y = x % y
            x = t
        }
        return x
    }

    protected lcm_impl(a Self, b Self) Self =
        if a == 0 or b == 0 then 0
        else (a / UInt32.gcd_impl(a, b)) * b

    protected ilog2_impl(x Self) UInt = {
        if x == 0 then panic("ilog2: argument is zero")
        let mut result UInt = 0
        let mut n = x
        while n > 1 then {
            n = n / 2
            result = result + 1
        }
        return result
    }

    protected ilog10_impl(x Self) UInt = {
        if x == 0 then panic("ilog10: argument is zero")
        let mut result UInt = 0
        let mut n = x
        while n >= 10 then {
            n = n / 10
            result = result + 1
        }
        return result
    }
}


// --- given UInt64 ---
given UInt64 {
    protected abs_impl(x Self) Self = x
    protected wrapping_abs_impl(x Self) Self = x

    protected pow_impl(base Self, exp UInt) Self = {
        let mut result UInt64 = 1
        let mut b = base
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result * b }
            b = b * b
            e = e / 2
        }
        return result
    }

    protected wrapping_pow_impl(base Self, exp UInt) Self = {
        let mut result UInt64 = 1
        let mut b = base
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        return result
    }

    protected gcd_impl(a Self, b Self) Self = {
        let mut x = a
        let mut y = b
        while y <> 0 then {
            let t = y
            y = x % y
            x = t
        }
        return x
    }

    protected lcm_impl(a Self, b Self) Self =
        if a == 0 or b == 0 then 0
        else (a / UInt64.gcd_impl(a, b)) * b

    protected ilog2_impl(x Self) UInt = {
        if x == 0 then panic("ilog2: argument is zero")
        let mut result UInt = 0
        let mut n = x
        while n > 1 then {
            n = n / 2
            result = result + 1
        }
        return result
    }

    protected ilog10_impl(x Self) UInt = {
        if x == 0 then panic("ilog10: argument is zero")
        let mut result UInt = 0
        let mut n = x
        while n >= 10 then {
            n = n / 10
            result = result + 1
        }
        return result
    }
}
