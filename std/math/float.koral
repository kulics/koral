// ============================================================================
// std.math - Floating Point Module
// ============================================================================

// ============================================================================
// Float64 FFI Declarations
// ============================================================================
foreign let __koral_f64_sqrt(x Float64) Float64
foreign let __koral_f64_cbrt(x Float64) Float64
foreign let __koral_f64_pow(x Float64, y Float64) Float64
foreign let __koral_f64_hypot(x Float64, y Float64) Float64
foreign let __koral_f64_exp(x Float64) Float64
foreign let __koral_f64_exp2(x Float64) Float64
foreign let __koral_f64_expm1(x Float64) Float64
foreign let __koral_f64_log(x Float64) Float64
foreign let __koral_f64_log2(x Float64) Float64
foreign let __koral_f64_log10(x Float64) Float64
foreign let __koral_f64_log1p(x Float64) Float64
foreign let __koral_f64_sin(x Float64) Float64
foreign let __koral_f64_cos(x Float64) Float64
foreign let __koral_f64_tan(x Float64) Float64
foreign let __koral_f64_asin(x Float64) Float64
foreign let __koral_f64_acos(x Float64) Float64
foreign let __koral_f64_atan(x Float64) Float64
foreign let __koral_f64_atan2(y Float64, x Float64) Float64
foreign let __koral_f64_sinh(x Float64) Float64
foreign let __koral_f64_cosh(x Float64) Float64
foreign let __koral_f64_tanh(x Float64) Float64
foreign let __koral_f64_asinh(x Float64) Float64
foreign let __koral_f64_acosh(x Float64) Float64
foreign let __koral_f64_atanh(x Float64) Float64
foreign let __koral_f64_floor(x Float64) Float64
foreign let __koral_f64_ceil(x Float64) Float64
foreign let __koral_f64_round(x Float64) Float64
foreign let __koral_f64_trunc(x Float64) Float64
foreign let __koral_f64_fabs(x Float64) Float64
foreign let __koral_f64_copysign(x Float64, y Float64) Float64
foreign let __koral_f64_fmod(x Float64, y Float64) Float64
foreign let __koral_f64_fma(x Float64, y Float64, z Float64) Float64
foreign let __koral_f64_erf(x Float64) Float64
foreign let __koral_f64_erfc(x Float64) Float64
foreign let __koral_f64_tgamma(x Float64) Float64
foreign let __koral_f64_lgamma(x Float64) Float64

// ============================================================================
// Float32 FFI Declarations
// ============================================================================
foreign let __koral_f32_sqrt(x Float32) Float32
foreign let __koral_f32_cbrt(x Float32) Float32
foreign let __koral_f32_pow(x Float32, y Float32) Float32
foreign let __koral_f32_hypot(x Float32, y Float32) Float32
foreign let __koral_f32_exp(x Float32) Float32
foreign let __koral_f32_exp2(x Float32) Float32
foreign let __koral_f32_expm1(x Float32) Float32
foreign let __koral_f32_log(x Float32) Float32
foreign let __koral_f32_log2(x Float32) Float32
foreign let __koral_f32_log10(x Float32) Float32
foreign let __koral_f32_log1p(x Float32) Float32
foreign let __koral_f32_sin(x Float32) Float32
foreign let __koral_f32_cos(x Float32) Float32
foreign let __koral_f32_tan(x Float32) Float32
foreign let __koral_f32_asin(x Float32) Float32
foreign let __koral_f32_acos(x Float32) Float32
foreign let __koral_f32_atan(x Float32) Float32
foreign let __koral_f32_atan2(y Float32, x Float32) Float32
foreign let __koral_f32_sinh(x Float32) Float32
foreign let __koral_f32_cosh(x Float32) Float32
foreign let __koral_f32_tanh(x Float32) Float32
foreign let __koral_f32_asinh(x Float32) Float32
foreign let __koral_f32_acosh(x Float32) Float32
foreign let __koral_f32_atanh(x Float32) Float32
foreign let __koral_f32_floor(x Float32) Float32
foreign let __koral_f32_ceil(x Float32) Float32
foreign let __koral_f32_round(x Float32) Float32
foreign let __koral_f32_trunc(x Float32) Float32
foreign let __koral_f32_fabs(x Float32) Float32
foreign let __koral_f32_copysign(x Float32, y Float32) Float32
foreign let __koral_f32_fmod(x Float32, y Float32) Float32
foreign let __koral_f32_fma(x Float32, y Float32, z Float32) Float32
foreign let __koral_f32_erf(x Float32) Float32
foreign let __koral_f32_erfc(x Float32) Float32
foreign let __koral_f32_tgamma(x Float32) Float32
foreign let __koral_f32_lgamma(x Float32) Float32

// ============================================================================
// given Float64 Implementation
// ============================================================================
given Float64 {
    abs(self) Self = __koral_f64_fabs(self)

    sqrt(x Self) Self = __koral_f64_sqrt(x)
    cbrt(x Self) Self = __koral_f64_cbrt(x)
    pow(self, exp Self) Self = __koral_f64_pow(self, exp)
    hypot(x Self, y Self) Self = __koral_f64_hypot(x, y)
    exp(x Self) Self = __koral_f64_exp(x)
    exp2(x Self) Self = __koral_f64_exp2(x)
    exp_m1(x Self) Self = __koral_f64_expm1(x)
    ln(x Self) Self = __koral_f64_log(x)
    log2(x Self) Self = __koral_f64_log2(x)
    log10(x Self) Self = __koral_f64_log10(x)
    ln_1p(x Self) Self = __koral_f64_log1p(x)
    sin(x Self) Self = __koral_f64_sin(x)
    cos(x Self) Self = __koral_f64_cos(x)
    tan(x Self) Self = __koral_f64_tan(x)
    asin(x Self) Self = __koral_f64_asin(x)
    acos(x Self) Self = __koral_f64_acos(x)
    atan(x Self) Self = __koral_f64_atan(x)
    atan2(y Self, x Self) Self = __koral_f64_atan2(y, x)
    sinh(x Self) Self = __koral_f64_sinh(x)
    cosh(x Self) Self = __koral_f64_cosh(x)
    tanh(x Self) Self = __koral_f64_tanh(x)
    asinh(x Self) Self = __koral_f64_asinh(x)
    acosh(x Self) Self = __koral_f64_acosh(x)
    atanh(x Self) Self = __koral_f64_atanh(x)
    floor(self) Self = __koral_f64_floor(self)
    ceil(self) Self = __koral_f64_ceil(self)
    round(self) Self = __koral_f64_round(self)
    trunc(self) Self = __koral_f64_trunc(self)
    copysign(self, sign Self) Self = __koral_f64_copysign(self, sign)
    fmod(self, y Self) Self = __koral_f64_fmod(self, y)
    fma(x Self, mul Self, add Self) Self = __koral_f64_fma(x, mul, add)
    erf(x Self) Self = __koral_f64_erf(x)
    erfc(x Self) Self = __koral_f64_erfc(x)
    tgamma(x Self) Self = __koral_f64_tgamma(x)
    lgamma(x Self) Self = __koral_f64_lgamma(x)

    signum(self) Self =
        if self.is_nan() then Float64.nan()
        else if self > 0.0 then 1.0
        else if self < 0.0 then -1.0
        else 0.0

    fract(self) Self = self - __koral_f64_trunc(self)
    lerp(a Self, b Self, t Self) Self = a + t * (b - a)

    powi(self, exp Int) Self = {
        if exp < 0 then {
            return 1.0 / Float64.powi(self, -exp)
        }
        let mut result = 1.0
        let mut b = self
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result * b }
            b = b * b
            e = e / 2
        }
        return result
    }

    to_radians(self) Self = self * (Float64.pi() / 180.0)
    to_degrees(self) Self = self * (180.0 / Float64.pi())
    log(x Self, base Self) Self = __koral_f64_log(x) / __koral_f64_log(base)

    pi() Self = 3.14159265358979323846
    e() Self = 2.71828182845904523536
    tau() Self = 6.28318530717958647692
    ln2() Self = 0.693147180559945309417
    ln10() Self = 2.30258509299404568402
    sqrt2() Self = 1.41421356237309504880
}

// ============================================================================
// given Float32 Implementation
// ============================================================================
given Float32 {
    abs(self) Self = __koral_f32_fabs(self)

    sqrt(x Self) Self = __koral_f32_sqrt(x)
    cbrt(x Self) Self = __koral_f32_cbrt(x)
    pow(self, exp Self) Self = __koral_f32_pow(self, exp)
    hypot(x Self, y Self) Self = __koral_f32_hypot(x, y)
    exp(x Self) Self = __koral_f32_exp(x)
    exp2(x Self) Self = __koral_f32_exp2(x)
    exp_m1(x Self) Self = __koral_f32_expm1(x)
    ln(x Self) Self = __koral_f32_log(x)
    log2(x Self) Self = __koral_f32_log2(x)
    log10(x Self) Self = __koral_f32_log10(x)
    ln_1p(x Self) Self = __koral_f32_log1p(x)
    sin(x Self) Self = __koral_f32_sin(x)
    cos(x Self) Self = __koral_f32_cos(x)
    tan(x Self) Self = __koral_f32_tan(x)
    asin(x Self) Self = __koral_f32_asin(x)
    acos(x Self) Self = __koral_f32_acos(x)
    atan(x Self) Self = __koral_f32_atan(x)
    atan2(y Self, x Self) Self = __koral_f32_atan2(y, x)
    sinh(x Self) Self = __koral_f32_sinh(x)
    cosh(x Self) Self = __koral_f32_cosh(x)
    tanh(x Self) Self = __koral_f32_tanh(x)
    asinh(x Self) Self = __koral_f32_asinh(x)
    acosh(x Self) Self = __koral_f32_acosh(x)
    atanh(x Self) Self = __koral_f32_atanh(x)
    floor(self) Self = __koral_f32_floor(self)
    ceil(self) Self = __koral_f32_ceil(self)
    round(self) Self = __koral_f32_round(self)
    trunc(self) Self = __koral_f32_trunc(self)
    copysign(self, sign Self) Self = __koral_f32_copysign(self, sign)
    fmod(self, y Self) Self = __koral_f32_fmod(self, y)
    fma(x Self, mul Self, add Self) Self = __koral_f32_fma(x, mul, add)
    erf(x Self) Self = __koral_f32_erf(x)
    erfc(x Self) Self = __koral_f32_erfc(x)
    tgamma(x Self) Self = __koral_f32_tgamma(x)
    lgamma(x Self) Self = __koral_f32_lgamma(x)

    signum(self) Self =
        if self.is_nan() then Float32.nan()
        else if self > 0.0 then 1.0
        else if self < 0.0 then -1.0
        else 0.0

    fract(self) Self = self - __koral_f32_trunc(self)
    lerp(a Self, b Self, t Self) Self = a + t * (b - a)

    powi(self, exp Int) Self = {
        if exp < 0 then {
            return 1.0 / Float32.powi(self, -exp)
        }
        let mut result Float32 = 1.0
        let mut b = self
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result * b }
            b = b * b
            e = e / 2
        }
        return result
    }

    to_radians(self) Self = self * (Float32.pi() / 180.0)
    to_degrees(self) Self = self * (180.0 / Float32.pi())
    log(x Self, base Self) Self = __koral_f32_log(x) / __koral_f32_log(base)

    pi() Self = 3.14159274
    e() Self = 2.71828175
    tau() Self = 6.28318548
    ln2() Self = 0.693147182
    ln10() Self = 2.30258512
    sqrt2() Self = 1.41421354
}

// ============================================================================
// Binary Floating Point Generic Free Functions
// ============================================================================

// 幂与根
public let [T FloatingPoint]sqrt(x T) T = T.sqrt(x)
public let [T FloatingPoint]cbrt(x T) T = T.cbrt(x)
public let [T FloatingPoint]hypot(x T, y T) T = T.hypot(x, y)

// 指数与对数
public let [T FloatExpLog]exp(x T) T = T.exp(x)
public let [T FloatExpLog]exp2(x T) T = T.exp2(x)
public let [T FloatExpLog]exp_m1(x T) T = T.exp_m1(x)
public let [T FloatingPoint]ln(x T) T = T.ln(x)
public let [T FloatingPoint]log2(x T) T = T.log2(x)
public let [T FloatingPoint]log10(x T) T = T.log10(x)
public let [T FloatExpLog]ln_1p(x T) T = T.ln_1p(x)

// 三角函数
public let [T FloatTrigHyper]sin(x T) T = T.sin(x)
public let [T FloatTrigHyper]cos(x T) T = T.cos(x)
public let [T FloatTrigHyper]tan(x T) T = T.tan(x)
public let [T FloatTrigHyper]asin(x T) T = T.asin(x)
public let [T FloatTrigHyper]acos(x T) T = T.acos(x)
public let [T FloatTrigHyper]atan(x T) T = T.atan(x)
public let [T FloatTrigHyper]atan2(y T, x T) T = T.atan2(y, x)

// 双曲函数
public let [T FloatTrigHyper]sinh(x T) T = T.sinh(x)
public let [T FloatTrigHyper]cosh(x T) T = T.cosh(x)
public let [T FloatTrigHyper]tanh(x T) T = T.tanh(x)
public let [T FloatTrigHyper]asinh(x T) T = T.asinh(x)
public let [T FloatTrigHyper]acosh(x T) T = T.acosh(x)
public let [T FloatTrigHyper]atanh(x T) T = T.atanh(x)

// 取整与符号

// 融合乘加与线性插值
public let [T FloatSpecial]fma(x T, mul T, add T) T = T.fma(x, mul, add)
public let [T FloatingPoint]lerp(a T, b T, t T) T = a.add(t.mul(b.sub(a)))

// 特殊函数
public let [T FloatSpecial]erf(x T) T = T.erf(x)
public let [T FloatSpecial]erfc(x T) T = T.erfc(x)
public let [T FloatSpecial]tgamma(x T) T = T.tgamma(x)
public let [T FloatSpecial]lgamma(x T) T = T.lgamma(x)

// 任意底对数
public let [T FloatingPoint]log(x T, base T) T = ln(x).div(ln(base))
