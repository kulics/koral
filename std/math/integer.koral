// ============================================================================
// std.math - Signed Integer Module
// ============================================================================

// ============================================================================
// Shared Helpers
// ============================================================================

private let [T Mul]pow_nonwrap(base T, exp UInt, one T) T = {
    let mut result = one
    let mut b = base
    let mut e = exp
    while e > 0 then {
        if e % 2 == 1 then { result = result * b }
        b = b * b
        e = e / 2
    }
    return result
}

private let [T Rem and Ord]gcd_nonneg(a T, b T, zero T) T = {
    let mut x = a
    let mut y = b
    while y <> zero then {
        let t = y
        y = x % y
        x = t
    }
    return x
}

private let [T Div and Ord]ilog_nonneg(x T, zero T, radix T, name String) UInt = {
    if x == zero then panic(name)
    let mut result UInt = 0
    let mut n = x
    while n >= radix then {
        n = n / radix
        result = result + 1
    }
    return result
}

// --- given Int ---
given Int {
    abs(self) Self =
        if self == Int.min() then panic("integer overflow: abs of min value")
        else if self < 0 then -self
        else self

    wrapping_abs(self) Self =
        if self < 0 then self.wrapping_neg()
        else self

    pow(self, exp UInt) Self =
        pow_nonwrap(self, exp, (Int)1)

    wrapping_pow(self, exp UInt) Self = {
        let mut result = 1
        let mut b = self
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        return result
    }

    gcd(a Self, b Self) Self = {
        let x = if a < 0 then -a else a
        let y = if b < 0 then -b else b
        return gcd_nonneg(x, y, (Int)0)
    }

    lcm(a Self, b Self) Self = {
        if a == 0 or b == 0 then {
            return 0
        }
        let g = gcd_nonneg(
            if a < 0 then -a else a,
            if b < 0 then -b else b,
            (Int)0
        )
        let result = (a / g) * b
        return if result < 0 then -result else result
    }

    ilog2(x Self) UInt = {
        if x == 0 then panic("ilog2: argument is zero")
        let v = if x < 0 then -x else x
        return ilog_nonneg(v, (Int)0, (Int)2, "ilog2: argument is zero")
    }

    ilog10(x Self) UInt = {
        if x == 0 then panic("ilog10: argument is zero")
        let v = if x < 0 then -x else x
        return ilog_nonneg(v, (Int)0, (Int)10, "ilog10: argument is zero")
    }
}

// --- given Int8 ---
given Int8 {
    abs(self) Self =
        if self == Int8.min() then panic("integer overflow: abs of min value")
        else if self < 0 then -self
        else self

    wrapping_abs(self) Self =
        if self < 0 then self.wrapping_neg()
        else self

    pow(self, exp UInt) Self =
        pow_nonwrap(self, exp, (Int8)1)

    wrapping_pow(self, exp UInt) Self = {
        let mut result Int8 = 1
        let mut b = self
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        return result
    }

    gcd(a Self, b Self) Self = {
        let x = if a < 0 then -a else a
        let y = if b < 0 then -b else b
        return gcd_nonneg(x, y, (Int8)0)
    }

    lcm(a Self, b Self) Self = {
        if a == 0 or b == 0 then {
            return 0
        }
        let g = gcd_nonneg(
            if a < 0 then -a else a,
            if b < 0 then -b else b,
            (Int8)0
        )
        let result = (a / g) * b
        return if result < 0 then -result else result
    }

    ilog2(x Self) UInt = {
        if x == 0 then panic("ilog2: argument is zero")
        let v = if x < 0 then -x else x
        return ilog_nonneg(v, (Int8)0, (Int8)2, "ilog2: argument is zero")
    }

    ilog10(x Self) UInt = {
        if x == 0 then panic("ilog10: argument is zero")
        let v = if x < 0 then -x else x
        return ilog_nonneg(v, (Int8)0, (Int8)10, "ilog10: argument is zero")
    }
}

// --- given Int16 ---
given Int16 {
    abs(self) Self =
        if self == Int16.min() then panic("integer overflow: abs of min value")
        else if self < 0 then -self
        else self

    wrapping_abs(self) Self =
        if self < 0 then self.wrapping_neg()
        else self

    pow(self, exp UInt) Self =
        pow_nonwrap(self, exp, (Int16)1)

    wrapping_pow(self, exp UInt) Self = {
        let mut result Int16 = 1
        let mut b = self
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        return result
    }

    gcd(a Self, b Self) Self = {
        let x = if a < 0 then -a else a
        let y = if b < 0 then -b else b
        return gcd_nonneg(x, y, (Int16)0)
    }

    lcm(a Self, b Self) Self = {
        if a == 0 or b == 0 then {
            return 0
        }
        let g = gcd_nonneg(
            if a < 0 then -a else a,
            if b < 0 then -b else b,
            (Int16)0
        )
        let result = (a / g) * b
        return if result < 0 then -result else result
    }

    ilog2(x Self) UInt = {
        if x == 0 then panic("ilog2: argument is zero")
        let v = if x < 0 then -x else x
        return ilog_nonneg(v, (Int16)0, (Int16)2, "ilog2: argument is zero")
    }

    ilog10(x Self) UInt = {
        if x == 0 then panic("ilog10: argument is zero")
        let v = if x < 0 then -x else x
        return ilog_nonneg(v, (Int16)0, (Int16)10, "ilog10: argument is zero")
    }
}

// --- given Int32 ---
given Int32 {
    abs(self) Self =
        if self == Int32.min() then panic("integer overflow: abs of min value")
        else if self < 0 then -self
        else self

    wrapping_abs(self) Self =
        if self < 0 then self.wrapping_neg()
        else self

    pow(self, exp UInt) Self =
        pow_nonwrap(self, exp, (Int32)1)

    wrapping_pow(self, exp UInt) Self = {
        let mut result Int32 = 1
        let mut b = self
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        return result
    }

    gcd(a Self, b Self) Self = {
        let x = if a < 0 then -a else a
        let y = if b < 0 then -b else b
        return gcd_nonneg(x, y, (Int32)0)
    }

    lcm(a Self, b Self) Self = {
        if a == 0 or b == 0 then {
            return 0
        }
        let g = gcd_nonneg(
            if a < 0 then -a else a,
            if b < 0 then -b else b,
            (Int32)0
        )
        let result = (a / g) * b
        return if result < 0 then -result else result
    }

    ilog2(x Self) UInt = {
        if x == 0 then panic("ilog2: argument is zero")
        let v = if x < 0 then -x else x
        return ilog_nonneg(v, (Int32)0, (Int32)2, "ilog2: argument is zero")
    }

    ilog10(x Self) UInt = {
        if x == 0 then panic("ilog10: argument is zero")
        let v = if x < 0 then -x else x
        return ilog_nonneg(v, (Int32)0, (Int32)10, "ilog10: argument is zero")
    }
}

// --- given Int64 ---
given Int64 {
    abs(self) Self =
        if self == Int64.min() then panic("integer overflow: abs of min value")
        else if self < 0 then -self
        else self

    wrapping_abs(self) Self =
        if self < 0 then self.wrapping_neg()
        else self

    pow(self, exp UInt) Self =
        pow_nonwrap(self, exp, (Int64)1)

    wrapping_pow(self, exp UInt) Self = {
        let mut result Int64 = 1
        let mut b = self
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        return result
    }

    gcd(a Self, b Self) Self = {
        let x = if a < 0 then -a else a
        let y = if b < 0 then -b else b
        return gcd_nonneg(x, y, (Int64)0)
    }

    lcm(a Self, b Self) Self = {
        if a == 0 or b == 0 then {
            return 0
        }
        let g = gcd_nonneg(
            if a < 0 then -a else a,
            if b < 0 then -b else b,
            (Int64)0
        )
        let result = (a / g) * b
        return if result < 0 then -result else result
    }

    ilog2(x Self) UInt = {
        if x == 0 then panic("ilog2: argument is zero")
        let v = if x < 0 then -x else x
        return ilog_nonneg(v, (Int64)0, (Int64)2, "ilog2: argument is zero")
    }

    ilog10(x Self) UInt = {
        if x == 0 then panic("ilog10: argument is zero")
        let v = if x < 0 then -x else x
        return ilog_nonneg(v, (Int64)0, (Int64)10, "ilog10: argument is zero")
    }
}

private let [T Div and Mul and Rem and Ord]lcm_nonneg(a T, b T, zero T) T =
    if a == zero or b == zero then zero
    else (a / gcd_nonneg(a, b, zero)) * b

// --- given UInt ---
given UInt {
    abs(self) Self = self
    wrapping_abs(self) Self = self

    pow(self, exp UInt) Self =
        pow_nonwrap(self, exp, (UInt)1)

    wrapping_pow(self, exp UInt) Self = {
        let mut result UInt = 1
        let mut b = self
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        return result
    }

    gcd(a Self, b Self) Self = gcd_nonneg(a, b, (UInt)0)

    lcm(a Self, b Self) Self = lcm_nonneg(a, b, (UInt)0)

    ilog2(x Self) UInt =
        ilog_nonneg(x, (UInt)0, (UInt)2, "ilog2: argument is zero")

    ilog10(x Self) UInt =
        ilog_nonneg(x, (UInt)0, (UInt)10, "ilog10: argument is zero")
}

// --- given UInt8 ---
given UInt8 {
    abs(self) Self = self
    wrapping_abs(self) Self = self

    pow(self, exp UInt) Self =
        pow_nonwrap(self, exp, (UInt8)1)

    wrapping_pow(self, exp UInt) Self = {
        let mut result UInt8 = 1
        let mut b = self
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        return result
    }

    gcd(a Self, b Self) Self = gcd_nonneg(a, b, (UInt8)0)

    lcm(a Self, b Self) Self = lcm_nonneg(a, b, (UInt8)0)

    ilog2(x Self) UInt =
        ilog_nonneg(x, (UInt8)0, (UInt8)2, "ilog2: argument is zero")

    ilog10(x Self) UInt =
        ilog_nonneg(x, (UInt8)0, (UInt8)10, "ilog10: argument is zero")
}

// --- given UInt16 ---
given UInt16 {
    abs(self) Self = self
    wrapping_abs(self) Self = self

    pow(self, exp UInt) Self =
        pow_nonwrap(self, exp, (UInt16)1)

    wrapping_pow(self, exp UInt) Self = {
        let mut result UInt16 = 1
        let mut b = self
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        return result
    }

    gcd(a Self, b Self) Self = gcd_nonneg(a, b, (UInt16)0)

    lcm(a Self, b Self) Self = lcm_nonneg(a, b, (UInt16)0)

    ilog2(x Self) UInt =
        ilog_nonneg(x, (UInt16)0, (UInt16)2, "ilog2: argument is zero")

    ilog10(x Self) UInt =
        ilog_nonneg(x, (UInt16)0, (UInt16)10, "ilog10: argument is zero")
}

// --- given UInt32 ---
given UInt32 {
    abs(self) Self = self
    wrapping_abs(self) Self = self

    pow(self, exp UInt) Self =
        pow_nonwrap(self, exp, (UInt32)1)

    wrapping_pow(self, exp UInt) Self = {
        let mut result UInt32 = 1
        let mut b = self
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        return result
    }

    gcd(a Self, b Self) Self = gcd_nonneg(a, b, (UInt32)0)

    lcm(a Self, b Self) Self = lcm_nonneg(a, b, (UInt32)0)

    ilog2(x Self) UInt =
        ilog_nonneg(x, (UInt32)0, (UInt32)2, "ilog2: argument is zero")

    ilog10(x Self) UInt =
        ilog_nonneg(x, (UInt32)0, (UInt32)10, "ilog10: argument is zero")
}

// --- given UInt64 ---
given UInt64 {
    abs(self) Self = self
    wrapping_abs(self) Self = self

    pow(self, exp UInt) Self =
        pow_nonwrap(self, exp, (UInt64)1)

    wrapping_pow(self, exp UInt) Self = {
        let mut result UInt64 = 1
        let mut b = self
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        return result
    }

    gcd(a Self, b Self) Self = gcd_nonneg(a, b, (UInt64)0)

    lcm(a Self, b Self) Self = lcm_nonneg(a, b, (UInt64)0)

    ilog2(x Self) UInt =
        ilog_nonneg(x, (UInt64)0, (UInt64)2, "ilog2: argument is zero")

    ilog10(x Self) UInt =
        ilog_nonneg(x, (UInt64)0, (UInt64)10, "ilog10: argument is zero")
}

given Int Integer {
    wrapping_abs(self) Self =
        if self < 0 then self.wrapping_neg()
        else self

    pow(self, exp UInt) Self =
        pow_nonwrap(self, exp, (Int)1)

    wrapping_pow(self, exp UInt) Self = {
        let mut result = 1
        let mut b = self
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        return result
    }

    gcd(a Self, b Self) Self = {
        let x = if a < 0 then -a else a
        let y = if b < 0 then -b else b
        return gcd_nonneg(x, y, (Int)0)
    }

    lcm(a Self, b Self) Self = {
        if a == 0 or b == 0 then {
            return 0
        }
        let g = gcd_nonneg(
            if a < 0 then -a else a,
            if b < 0 then -b else b,
            (Int)0
        )
        let result = (a / g) * b
        return if result < 0 then -result else result
    }

    ilog2(x Self) UInt = {
        if x == 0 then panic("ilog2: argument is zero")
        let v = if x < 0 then -x else x
        return ilog_nonneg(v, (Int)0, (Int)2, "ilog2: argument is zero")
    }

    ilog10(x Self) UInt = {
        if x == 0 then panic("ilog10: argument is zero")
        let v = if x < 0 then -x else x
        return ilog_nonneg(v, (Int)0, (Int)10, "ilog10: argument is zero")
    }
}

given UInt Integer {
    wrapping_abs(self) Self = self

    pow(self, exp UInt) Self =
        pow_nonwrap(self, exp, (UInt)1)

    wrapping_pow(self, exp UInt) Self = {
        let mut result UInt = 1
        let mut b = self
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        return result
    }

    gcd(a Self, b Self) Self = gcd_nonneg(a, b, (UInt)0)

    lcm(a Self, b Self) Self = lcm_nonneg(a, b, (UInt)0)

    ilog2(x Self) UInt =
        ilog_nonneg(x, (UInt)0, (UInt)2, "ilog2: argument is zero")

    ilog10(x Self) UInt =
        ilog_nonneg(x, (UInt)0, (UInt)10, "ilog10: argument is zero")
}

// ============================================================================
// Integer Generic Free Functions
// ============================================================================
public let [T Integer]gcd(a T, b T) T = T.gcd(a, b)
public let [T Integer]lcm(a T, b T) T = T.lcm(a, b)
public let [T Integer]ilog2(x T) UInt = T.ilog2(x)
public let [T Integer]ilog10(x T) UInt = T.ilog10(x)
