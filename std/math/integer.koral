// ============================================================================
// std.math - Signed Integer Module
// ============================================================================

// --- given Int ---
given Int {
    protected abs_impl(x Self) Self = {
        if x == Int.min() then panic("integer overflow: abs of min value")
        else if x < 0 then -x
        else x
    }

    protected wrapping_abs_impl(x Self) Self = {
        if x < 0 then x.wrapping_neg()
        else x
    }

    protected pow_impl(base Self, exp UInt) Self = {
        let mut result = 1
        let mut b = base
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result * b }
            b = b * b
            e = e / 2
        }
        result
    }

    protected wrapping_pow_impl(base Self, exp UInt) Self = {
        let mut result = 1
        let mut b = base
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        result
    }

    protected gcd_impl(a Self, b Self) Self = {
        let mut x = if a < 0 then -a else a
        let mut y = if b < 0 then -b else b
        while y <> 0 then {
            let t = y
            y = x % y
            x = t
        }
        x
    }

    protected lcm_impl(a Self, b Self) Self = {
        if a == 0 or b == 0 then 0
        else {
            let g = Int.gcd_impl(a, b)
            let result = (a / g) * b
            if result < 0 then -result else result
        }
    }

    protected ilog2_impl(x Self) UInt = {
        if x == 0 then panic("ilog2: argument is zero")
        let v = if x < 0 then -x else x
        let mut result UInt = 0
        let mut n = v
        while n > 1 then {
            n = n / 2
            result = result + 1
        }
        result
    }

    protected ilog10_impl(x Self) UInt = {
        if x == 0 then panic("ilog10: argument is zero")
        let v = if x < 0 then -x else x
        let mut result UInt = 0
        let mut n = v
        while n >= 10 then {
            n = n / 10
            result = result + 1
        }
        result
    }
}

// --- given Int8 ---
given Int8 {
    protected abs_impl(x Self) Self = {
        if x == Int8.min() then panic("integer overflow: abs of min value")
        else if x < 0 then -x
        else x
    }

    protected wrapping_abs_impl(x Self) Self = {
        if x < 0 then x.wrapping_neg()
        else x
    }

    protected pow_impl(base Self, exp UInt) Self = {
        let mut result Int8 = 1
        let mut b = base
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result * b }
            b = b * b
            e = e / 2
        }
        result
    }

    protected wrapping_pow_impl(base Self, exp UInt) Self = {
        let mut result Int8 = 1
        let mut b = base
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        result
    }

    protected gcd_impl(a Self, b Self) Self = {
        let mut x = if a < 0 then -a else a
        let mut y = if b < 0 then -b else b
        while y <> 0 then {
            let t = y
            y = x % y
            x = t
        }
        x
    }

    protected lcm_impl(a Self, b Self) Self = {
        if a == 0 or b == 0 then 0
        else {
            let g = Int8.gcd_impl(a, b)
            let result = (a / g) * b
            if result < 0 then -result else result
        }
    }

    protected ilog2_impl(x Self) UInt = {
        if x == 0 then panic("ilog2: argument is zero")
        let v = if x < 0 then -x else x
        let mut result UInt = 0
        let mut n = v
        while n > 1 then {
            n = n / 2
            result = result + 1
        }
        result
    }

    protected ilog10_impl(x Self) UInt = {
        if x == 0 then panic("ilog10: argument is zero")
        let v = if x < 0 then -x else x
        let mut result UInt = 0
        let mut n = v
        while n >= 10 then {
            n = n / 10
            result = result + 1
        }
        result
    }
}

// --- given Int16 ---
given Int16 {
    protected abs_impl(x Self) Self = {
        if x == Int16.min() then panic("integer overflow: abs of min value")
        else if x < 0 then -x
        else x
    }

    protected wrapping_abs_impl(x Self) Self = {
        if x < 0 then x.wrapping_neg()
        else x
    }

    protected pow_impl(base Self, exp UInt) Self = {
        let mut result Int16 = 1
        let mut b = base
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result * b }
            b = b * b
            e = e / 2
        }
        result
    }

    protected wrapping_pow_impl(base Self, exp UInt) Self = {
        let mut result Int16 = 1
        let mut b = base
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        result
    }

    protected gcd_impl(a Self, b Self) Self = {
        let mut x = if a < 0 then -a else a
        let mut y = if b < 0 then -b else b
        while y <> 0 then {
            let t = y
            y = x % y
            x = t
        }
        x
    }

    protected lcm_impl(a Self, b Self) Self = {
        if a == 0 or b == 0 then 0
        else {
            let g = Int16.gcd_impl(a, b)
            let result = (a / g) * b
            if result < 0 then -result else result
        }
    }

    protected ilog2_impl(x Self) UInt = {
        if x == 0 then panic("ilog2: argument is zero")
        let v = if x < 0 then -x else x
        let mut result UInt = 0
        let mut n = v
        while n > 1 then {
            n = n / 2
            result = result + 1
        }
        result
    }

    protected ilog10_impl(x Self) UInt = {
        if x == 0 then panic("ilog10: argument is zero")
        let v = if x < 0 then -x else x
        let mut result UInt = 0
        let mut n = v
        while n >= 10 then {
            n = n / 10
            result = result + 1
        }
        result
    }
}

// --- given Int32 ---
given Int32 {
    protected abs_impl(x Self) Self = {
        if x == Int32.min() then panic("integer overflow: abs of min value")
        else if x < 0 then -x
        else x
    }

    protected wrapping_abs_impl(x Self) Self = {
        if x < 0 then x.wrapping_neg()
        else x
    }

    protected pow_impl(base Self, exp UInt) Self = {
        let mut result Int32 = 1
        let mut b = base
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result * b }
            b = b * b
            e = e / 2
        }
        result
    }

    protected wrapping_pow_impl(base Self, exp UInt) Self = {
        let mut result Int32 = 1
        let mut b = base
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        result
    }

    protected gcd_impl(a Self, b Self) Self = {
        let mut x = if a < 0 then -a else a
        let mut y = if b < 0 then -b else b
        while y <> 0 then {
            let t = y
            y = x % y
            x = t
        }
        x
    }

    protected lcm_impl(a Self, b Self) Self = {
        if a == 0 or b == 0 then 0
        else {
            let g = Int32.gcd_impl(a, b)
            let result = (a / g) * b
            if result < 0 then -result else result
        }
    }

    protected ilog2_impl(x Self) UInt = {
        if x == 0 then panic("ilog2: argument is zero")
        let v = if x < 0 then -x else x
        let mut result UInt = 0
        let mut n = v
        while n > 1 then {
            n = n / 2
            result = result + 1
        }
        result
    }

    protected ilog10_impl(x Self) UInt = {
        if x == 0 then panic("ilog10: argument is zero")
        let v = if x < 0 then -x else x
        let mut result UInt = 0
        let mut n = v
        while n >= 10 then {
            n = n / 10
            result = result + 1
        }
        result
    }
}

// --- given Int64 ---
given Int64 {
    protected abs_impl(x Self) Self = {
        if x == Int64.min() then panic("integer overflow: abs of min value")
        else if x < 0 then -x
        else x
    }

    protected wrapping_abs_impl(x Self) Self = {
        if x < 0 then x.wrapping_neg()
        else x
    }

    protected pow_impl(base Self, exp UInt) Self = {
        let mut result Int64 = 1
        let mut b = base
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result * b }
            b = b * b
            e = e / 2
        }
        result
    }

    protected wrapping_pow_impl(base Self, exp UInt) Self = {
        let mut result Int64 = 1
        let mut b = base
        let mut e = exp
        while e > 0 then {
            if e % 2 == 1 then { result = result.wrapping_mul(b) }
            b = b.wrapping_mul(b)
            e = e / 2
        }
        result
    }

    protected gcd_impl(a Self, b Self) Self = {
        let mut x = if a < 0 then -a else a
        let mut y = if b < 0 then -b else b
        while y <> 0 then {
            let t = y
            y = x % y
            x = t
        }
        x
    }

    protected lcm_impl(a Self, b Self) Self = {
        if a == 0 or b == 0 then 0
        else {
            let g = Int64.gcd_impl(a, b)
            let result = (a / g) * b
            if result < 0 then -result else result
        }
    }

    protected ilog2_impl(x Self) UInt = {
        if x == 0 then panic("ilog2: argument is zero")
        let v = if x < 0 then -x else x
        let mut result UInt = 0
        let mut n = v
        while n > 1 then {
            n = n / 2
            result = result + 1
        }
        result
    }

    protected ilog10_impl(x Self) UInt = {
        if x == 0 then panic("ilog10: argument is zero")
        let v = if x < 0 then -x else x
        let mut result UInt = 0
        let mut n = v
        while n >= 10 then {
            n = n / 10
            result = result + 1
        }
        result
    }
}

// ============================================================================
// Signed Integer Generic Free Functions
// ============================================================================
public let [T Integer]abs(x T) T = T.abs_impl(x)
public let [T Integer]wrapping_abs(x T) T = T.wrapping_abs_impl(x)
public let [T Integer]ipow(base T, exp UInt) T = T.pow_impl(base, exp)
public let [T Integer]wrapping_ipow(base T, exp UInt) T = T.wrapping_pow_impl(base, exp)
public let [T Integer]gcd(a T, b T) T = T.gcd_impl(a, b)
public let [T Integer]lcm(a T, b T) T = T.lcm_impl(a, b)
public let [T Integer]ilog2(x T) UInt = T.ilog2_impl(x)
public let [T Integer]ilog10(x T) UInt = T.ilog10_impl(x)
