// ============================================================================
// std.task - Timer
// ============================================================================
// Provides: TimerStorage (internal), Timer (handle)
// Access via: using std.task
// ============================================================================

using std.time.Duration
using std.time.MonoTime

// ============================================================================
// FFI Declarations
// ============================================================================
foreign let koral_timer_context_create() UInt8 ptr
foreign let koral_timer_context_cancel(ctx UInt8 ptr) Void
foreign let koral_timer_context_is_cancelled(ctx UInt8 ptr) Int32
foreign let koral_timer_context_destroy(ctx UInt8 ptr) Void
foreign let koral_timer_sleep(ctx UInt8 ptr, secs Int64, nanos Int64) Int32

// ============================================================================
// TimerStorage (internal)
// ============================================================================
private type TimerStorage(
    ctx UInt8 ptr,              // C timer context (atomic cancel flag + condvar)
    thread [Void]Thread,        // thread executing the timed task
    mut cancelled Bool,         // Koral-side cache
)

given TimerStorage {
    __drop(self ref) Void = {
        if not self.cancelled then {
            koral_timer_context_cancel(self.ctx)
            // don't wait the thread — auto-detach is sufficient
        }
        koral_timer_context_destroy(self.ctx)
    }
}

// ============================================================================
// Timer — Timer handle
// ============================================================================

/// Timer handle managing one-shot or periodic timed tasks.
/// Created via Timer.once/repeat/repeat_during/repeat_times/repeat_with.
/// cancel() cancels the timer, auto-cancels on drop.
public type Timer(private storage TimerStorage ref)

given Timer {
    // ============ Static Methods (create timers) ============

    /// One-shot delayed execution: wait delay then execute f once in a new thread.
    public once(delay Duration, f [Void]Func) Timer = {
        if delay < Duration.zero() then {
            panic("Timer.once: delay must not be negative")
        }
        let ctx = koral_timer_context_create()
        let timer_ctx = ctx
        let thread = [Void]run_task(() -> {
            let result = koral_timer_sleep(timer_ctx, delay.secs, delay.nanos)
            if result == 0 then {
                f()
            }
        })
        Timer(ref TimerStorage(ctx, thread, false))
    }

    /// Periodic execution: wait delay then execute f every interval, repeating indefinitely.
    /// Pass Duration.zero() for delay to start immediately.
    public repeat(delay Duration, interval Duration, f [Void]Func) Timer = {
        if delay < Duration.zero() then {
            panic("Timer.repeat: delay must not be negative")
        }
        if interval <= Duration.zero() then {
            panic("Timer.repeat: interval must be positive")
        }
        let ctx = koral_timer_context_create()
        let timer_ctx = ctx
        let thread = [Void]run_task(() -> {
            // Initial delay
            if delay.secs > 0 or delay.nanos > 0 then {
                let result = koral_timer_sleep(timer_ctx, delay.secs, delay.nanos)
                if result <> 0 then { return }
            }
            // Periodic execution
            while koral_timer_context_is_cancelled(timer_ctx) == 0 then {
                f()
                let result = koral_timer_sleep(timer_ctx, interval.secs, interval.nanos)
                if result <> 0 then { break }
            }
        })
        Timer(ref TimerStorage(ctx, thread, false))
    }

    /// Time-limited periodic execution: wait delay then execute f every interval
    /// for a total duration of total.
    public repeat_during(total Duration, delay Duration, interval Duration, f [Void]Func) Timer = {
        if total <= Duration.zero() then {
            panic("Timer.repeat_during: total must be positive")
        }
        if delay < Duration.zero() then {
            panic("Timer.repeat_during: delay must not be negative")
        }
        if interval <= Duration.zero() then {
            panic("Timer.repeat_during: interval must be positive")
        }
        let ctx = koral_timer_context_create()
        let timer_ctx = ctx
        let thread = [Void]run_task(() -> {
            // Initial delay
            if delay.secs > 0 or delay.nanos > 0 then {
                let result = koral_timer_sleep(timer_ctx, delay.secs, delay.nanos)
                if result <> 0 then { return }
            }
            // Time-limited periodic execution
            let start = MonoTime.now()
            while koral_timer_context_is_cancelled(timer_ctx) == 0 then {
                if start.elapsed() >= total then { break }
                f()
                let result = koral_timer_sleep(timer_ctx, interval.secs, interval.nanos)
                if result <> 0 then { break }
            }
        })
        Timer(ref TimerStorage(ctx, thread, false))
    }

    /// Count-limited periodic execution: wait delay then execute f every interval,
    /// exactly n times. n == 0 returns an already-completed Timer (no callback).
    public repeat_times(n UInt, delay Duration, interval Duration, f [Void]Func) Timer = {
        if delay < Duration.zero() then {
            panic("Timer.repeat_times: delay must not be negative")
        }
        if n > 0 and interval <= Duration.zero() then {
            panic("Timer.repeat_times: interval must be positive")
        }
        // n == 0: return an already-completed Timer (no-op)
        if n == 0 then {
            let ctx = koral_timer_context_create()
            let thread = [Void]run_task(() -> {})
            return Timer(ref TimerStorage(ctx, thread, false))
        }
        let ctx = koral_timer_context_create()
        let timer_ctx = ctx
        let thread = [Void]run_task(() -> {
            // Initial delay
            if delay.secs > 0 or delay.nanos > 0 then {
                let result = koral_timer_sleep(timer_ctx, delay.secs, delay.nanos)
                if result <> 0 then { return }
            }
            // Count-limited periodic execution
            let mut count UInt = 0
            while count < n and koral_timer_context_is_cancelled(timer_ctx) == 0 then {
                f()
                count = count + 1
                if count < n then {
                    let result = koral_timer_sleep(timer_ctx, interval.secs, interval.nanos)
                    if result <> 0 then { break }
                }
            }
        })
        Timer(ref TimerStorage(ctx, thread, false))
    }

    /// Closure-driven periodic execution: wait delay then execute f.
    /// f returns Some(duration) to wait then execute again, or None to stop.
    /// Suitable for exponential backoff, adaptive polling, etc.
    public repeat_with(delay Duration, f [[Duration]Option]Func) Timer = {
        if delay < Duration.zero() then {
            panic("Timer.repeat_with: delay must not be negative")
        }
        let ctx = koral_timer_context_create()
        let timer_ctx = ctx
        let thread = [Void]run_task(() -> {
            // Initial delay
            if delay.secs > 0 or delay.nanos > 0 then {
                let result = koral_timer_sleep(timer_ctx, delay.secs, delay.nanos)
                if result <> 0 then { return }
            }
            // Closure-driven loop
            while koral_timer_context_is_cancelled(timer_ctx) == 0 then {
                when f() is {
                    .Some(next_interval) then {
                        let result = koral_timer_sleep(timer_ctx, next_interval.secs, next_interval.nanos)
                        if result <> 0 then { break }
                    },
                    .None then { break },
                }
            }
        })
        Timer(ref TimerStorage(ctx, thread, false))
    }

    // ============ Instance Methods ============

    /// Cancel the timer (thread exits on next check).
    public cancel(self) Void = {
        if not self.storage.cancelled then {
            koral_timer_context_cancel(self.storage.ctx)
            self.storage.cancelled = true
        }
    }

    /// Block until the timer thread finishes.
    /// For one-shot timers: waits for callback completion.
    /// For time/count-limited timers: waits for natural completion.
    /// For infinite periodic timers: must cancel() first, otherwise blocks forever.
    public wait(self) Void = {
        self.storage.thread.wait().unwrap()
    }
}
