// ============================================================================
// Koral Standard Library - Arithmetic Traits and Implementations
// ============================================================================
// NOTE: This file is merged into core.koral.
// ============================================================================

public trait Add {
    add(self, other Self) Self
    zero() Self
}

public trait Sub Add {
    neg(self) Self
    sub(self, other Self) Self
}

public trait Mul {
    mul(self, other Self) Self
    one() Self
}

public trait Div Mul {
    div(self, other Self) Self
}

public trait Rem Div {
    rem(self, other Self) Self
}

public trait [Scalar Any]Scale {
    scale(self, k Scalar) Self
}

public trait [Scalar Any]InvScale [Scalar]Scale {
    unscale(self, k Scalar) Self
}

public trait [Vector Sub]Affine {
    add_vector(self, v Vector) Self
    sub_vector(self, v Vector) Self
    sub_point(self, other Self) Vector
}

// ============================================================================
// Primitive Wrapping Operations (intrinsic)
// ============================================================================
intrinsic given Int {
    public wrapping_add(self, other Int) Int
    public wrapping_sub(self, other Int) Int
    public wrapping_mul(self, other Int) Int
    public wrapping_div(self, other Int) Int
    public wrapping_rem(self, other Int) Int
    public wrapping_neg(self) Int
    public wrapping_shl(self, other Int) Int
    public wrapping_shr(self, other Int) Int
}

intrinsic given Int8 {
    public wrapping_add(self, other Int8) Int8
    public wrapping_sub(self, other Int8) Int8
    public wrapping_mul(self, other Int8) Int8
    public wrapping_div(self, other Int8) Int8
    public wrapping_rem(self, other Int8) Int8
    public wrapping_neg(self) Int8
    public wrapping_shl(self, other Int8) Int8
    public wrapping_shr(self, other Int8) Int8
}

intrinsic given Int16 {
    public wrapping_add(self, other Int16) Int16
    public wrapping_sub(self, other Int16) Int16
    public wrapping_mul(self, other Int16) Int16
    public wrapping_div(self, other Int16) Int16
    public wrapping_rem(self, other Int16) Int16
    public wrapping_neg(self) Int16
    public wrapping_shl(self, other Int16) Int16
    public wrapping_shr(self, other Int16) Int16
}

intrinsic given Int32 {
    public wrapping_add(self, other Int32) Int32
    public wrapping_sub(self, other Int32) Int32
    public wrapping_mul(self, other Int32) Int32
    public wrapping_div(self, other Int32) Int32
    public wrapping_rem(self, other Int32) Int32
    public wrapping_neg(self) Int32
    public wrapping_shl(self, other Int32) Int32
    public wrapping_shr(self, other Int32) Int32
}

intrinsic given Int64 {
    public wrapping_add(self, other Int64) Int64
    public wrapping_sub(self, other Int64) Int64
    public wrapping_mul(self, other Int64) Int64
    public wrapping_div(self, other Int64) Int64
    public wrapping_rem(self, other Int64) Int64
    public wrapping_neg(self) Int64
    public wrapping_shl(self, other Int64) Int64
    public wrapping_shr(self, other Int64) Int64
}

intrinsic given UInt {
    public wrapping_add(self, other UInt) UInt
    public wrapping_sub(self, other UInt) UInt
    public wrapping_mul(self, other UInt) UInt
    public wrapping_div(self, other UInt) UInt
    public wrapping_rem(self, other UInt) UInt
    public wrapping_neg(self) UInt
    public wrapping_shl(self, other UInt) UInt
    public wrapping_shr(self, other UInt) UInt
}

intrinsic given UInt8 {
    public wrapping_add(self, other UInt8) UInt8
    public wrapping_sub(self, other UInt8) UInt8
    public wrapping_mul(self, other UInt8) UInt8
    public wrapping_div(self, other UInt8) UInt8
    public wrapping_rem(self, other UInt8) UInt8
    public wrapping_neg(self) UInt8
    public wrapping_shl(self, other UInt8) UInt8
    public wrapping_shr(self, other UInt8) UInt8
}

intrinsic given UInt16 {
    public wrapping_add(self, other UInt16) UInt16
    public wrapping_sub(self, other UInt16) UInt16
    public wrapping_mul(self, other UInt16) UInt16
    public wrapping_div(self, other UInt16) UInt16
    public wrapping_rem(self, other UInt16) UInt16
    public wrapping_neg(self) UInt16
    public wrapping_shl(self, other UInt16) UInt16
    public wrapping_shr(self, other UInt16) UInt16
}

intrinsic given UInt32 {
    public wrapping_add(self, other UInt32) UInt32
    public wrapping_sub(self, other UInt32) UInt32
    public wrapping_mul(self, other UInt32) UInt32
    public wrapping_div(self, other UInt32) UInt32
    public wrapping_rem(self, other UInt32) UInt32
    public wrapping_neg(self) UInt32
    public wrapping_shl(self, other UInt32) UInt32
    public wrapping_shr(self, other UInt32) UInt32
}

intrinsic given UInt64 {
    public wrapping_add(self, other UInt64) UInt64
    public wrapping_sub(self, other UInt64) UInt64
    public wrapping_mul(self, other UInt64) UInt64
    public wrapping_div(self, other UInt64) UInt64
    public wrapping_rem(self, other UInt64) UInt64
    public wrapping_neg(self) UInt64
    public wrapping_shl(self, other UInt64) UInt64
    public wrapping_shr(self, other UInt64) UInt64
}

// ============================================================================
// Primitive Explicit Algebraic Conformances
// ============================================================================
given Int Add {
    public add(self, other Int) Int = self + other
    public zero() Int = 0
}
given Int Sub {
    public neg(self) Int = -self
    public sub(self, other Int) Int = self - other
}
given Int Mul {
    public mul(self, other Int) Int = self * other
    public one() Int = 1
}
given Int Div {
    public div(self, other Int) Int = self / other
}
given Int Rem {
    public rem(self, other Int) Int = self % other
}

given Int8 Add {
    public add(self, other Int8) Int8 = self + other
    public zero() Int8 = (Int8)0
}
given Int8 Sub {
    public neg(self) Int8 = -self
    public sub(self, other Int8) Int8 = self - other
}
given Int8 Mul {
    public mul(self, other Int8) Int8 = self * other
    public one() Int8 = (Int8)1
}
given Int8 Div {
    public div(self, other Int8) Int8 = self / other
}
given Int8 Rem {
    public rem(self, other Int8) Int8 = self % other
}

given Int16 Add {
    public add(self, other Int16) Int16 = self + other
    public zero() Int16 = (Int16)0
}
given Int16 Sub {
    public neg(self) Int16 = -self
    public sub(self, other Int16) Int16 = self - other
}
given Int16 Mul {
    public mul(self, other Int16) Int16 = self * other
    public one() Int16 = (Int16)1
}
given Int16 Div {
    public div(self, other Int16) Int16 = self / other
}
given Int16 Rem {
    public rem(self, other Int16) Int16 = self % other
}

given Int32 Add {
    public add(self, other Int32) Int32 = self + other
    public zero() Int32 = (Int32)0
}
given Int32 Sub {
    public neg(self) Int32 = -self
    public sub(self, other Int32) Int32 = self - other
}
given Int32 Mul {
    public mul(self, other Int32) Int32 = self * other
    public one() Int32 = (Int32)1
}
given Int32 Div {
    public div(self, other Int32) Int32 = self / other
}
given Int32 Rem {
    public rem(self, other Int32) Int32 = self % other
}

given Int64 Add {
    public add(self, other Int64) Int64 = self + other
    public zero() Int64 = (Int64)0
}
given Int64 Sub {
    public neg(self) Int64 = -self
    public sub(self, other Int64) Int64 = self - other
}
given Int64 Mul {
    public mul(self, other Int64) Int64 = self * other
    public one() Int64 = (Int64)1
}
given Int64 Div {
    public div(self, other Int64) Int64 = self / other
}
given Int64 Rem {
    public rem(self, other Int64) Int64 = self % other
}

given UInt Add {
    public add(self, other UInt) UInt = self + other
    public zero() UInt = (UInt)0
}
given UInt Sub {
    public neg(self) UInt = (UInt)0 - self
    public sub(self, other UInt) UInt = self - other
}
given UInt Mul {
    public mul(self, other UInt) UInt = self * other
    public one() UInt = (UInt)1
}
given UInt Div {
    public div(self, other UInt) UInt = self / other
}
given UInt Rem {
    public rem(self, other UInt) UInt = self % other
}

given UInt8 Add {
    public add(self, other UInt8) UInt8 = self + other
    public zero() UInt8 = (UInt8)0
}
given UInt8 Sub {
    public neg(self) UInt8 = (UInt8)0 - self
    public sub(self, other UInt8) UInt8 = self - other
}
given UInt8 Mul {
    public mul(self, other UInt8) UInt8 = self * other
    public one() UInt8 = (UInt8)1
}
given UInt8 Div {
    public div(self, other UInt8) UInt8 = self / other
}
given UInt8 Rem {
    public rem(self, other UInt8) UInt8 = self % other
}

given UInt16 Add {
    public add(self, other UInt16) UInt16 = self + other
    public zero() UInt16 = (UInt16)0
}
given UInt16 Sub {
    public neg(self) UInt16 = (UInt16)0 - self
    public sub(self, other UInt16) UInt16 = self - other
}
given UInt16 Mul {
    public mul(self, other UInt16) UInt16 = self * other
    public one() UInt16 = (UInt16)1
}
given UInt16 Div {
    public div(self, other UInt16) UInt16 = self / other
}
given UInt16 Rem {
    public rem(self, other UInt16) UInt16 = self % other
}

given UInt32 Add {
    public add(self, other UInt32) UInt32 = self + other
    public zero() UInt32 = (UInt32)0
}
given UInt32 Sub {
    public neg(self) UInt32 = (UInt32)0 - self
    public sub(self, other UInt32) UInt32 = self - other
}
given UInt32 Mul {
    public mul(self, other UInt32) UInt32 = self * other
    public one() UInt32 = (UInt32)1
}
given UInt32 Div {
    public div(self, other UInt32) UInt32 = self / other
}
given UInt32 Rem {
    public rem(self, other UInt32) UInt32 = self % other
}

given UInt64 Add {
    public add(self, other UInt64) UInt64 = self + other
    public zero() UInt64 = (UInt64)0
}
given UInt64 Sub {
    public neg(self) UInt64 = (UInt64)0 - self
    public sub(self, other UInt64) UInt64 = self - other
}
given UInt64 Mul {
    public mul(self, other UInt64) UInt64 = self * other
    public one() UInt64 = (UInt64)1
}
given UInt64 Div {
    public div(self, other UInt64) UInt64 = self / other
}
given UInt64 Rem {
    public rem(self, other UInt64) UInt64 = self % other
}

given Float32 Add {
    public add(self, other Float32) Float32 = self + other
    public zero() Float32 = 0.0
}
given Float32 Sub {
    public neg(self) Float32 = -self
    public sub(self, other Float32) Float32 = self - other
}
given Float32 Mul {
    public mul(self, other Float32) Float32 = self * other
    public one() Float32 = 1.0
}
given Float32 Div {
    public div(self, other Float32) Float32 = self / other
}

given Float64 Add {
    public add(self, other Float64) Float64 = self + other
    public zero() Float64 = 0.0
}
given Float64 Sub {
    public neg(self) Float64 = -self
    public sub(self, other Float64) Float64 = self - other
}
given Float64 Mul {
    public mul(self, other Float64) Float64 = self * other
    public one() Float64 = 1.0
}
given Float64 Div {
    public div(self, other Float64) Float64 = self / other
}

// ============================================================================
// Top-level std arithmetic implementations
// ============================================================================
given String Add {
    public zero() String = String.with_capacity(0)

    public add(self, other String) String = {
        if self.is_empty() then {
            return other
        }
        if other.is_empty() then {
            return self
        }
        self.push_string(other)
        return self
    }
}

given Duration Add {
    public zero() Duration = Duration(0, 0)

    public add(self, other Duration) Duration = {
        let total_nanos = self.nanos + other.nanos
        let extra_secs = total_nanos / 1_000_000_000
        let final_nanos = total_nanos % 1_000_000_000
        return Duration(self.secs + other.secs + extra_secs, final_nanos)
    }
}

given Duration Sub {
    public neg(self) Duration = {
        let mut total_nanos = -self.nanos
        let mut secs = -self.secs
        if total_nanos < 0 then {
            secs = secs - 1
            total_nanos = total_nanos + 1_000_000_000
        }
        return Duration(secs, total_nanos)
    }

    public sub(self, other Duration) Duration = {
        let mut total_nanos = self.nanos - other.nanos
        let mut secs_diff = self.secs - other.secs
        if total_nanos < 0 then {
            secs_diff = secs_diff - 1
            total_nanos = total_nanos + 1_000_000_000
        }
        return Duration(secs_diff, total_nanos)
    }
}

given Duration [Int]Scale {
    public scale(self, k Int) Duration = {
        let total_nanos = self.as_nanoseconds() * (Int64)k
        let secs = total_nanos / 1_000_000_000
        let nanos = total_nanos % 1_000_000_000
        return Duration(secs, nanos)
    }
}

given Duration [Int]InvScale {
    public unscale(self, k Int) Duration = {
        let total_nanos = self.as_nanoseconds() / (Int64)k
        let secs = total_nanos / 1_000_000_000
        let nanos = total_nanos % 1_000_000_000
        return Duration(secs, nanos)
    }
}
