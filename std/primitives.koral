// ============================================================================
// Koral Standard Library - Primitive Types
// ============================================================================

// SECTION 1: Primitive Types
public intrinsic type Bool
public intrinsic type Never
public intrinsic type Int
public intrinsic type Int8
public intrinsic type Int16
public intrinsic type Int32
public intrinsic type Int64
public intrinsic type UInt
public intrinsic type UInt8
public intrinsic type UInt16
public intrinsic type UInt32
public intrinsic type UInt64
public intrinsic type Float32
public intrinsic type Float64

// ============================================================================
// SECTION 2: Memory Management Primitives
// ============================================================================
public intrinsic let [T Any]ref_count(r T ref) Int

// Downgrades a strong reference to a weak reference.
// The weak reference does not prevent the object from being deallocated.
public intrinsic let [T Any]downgrade_ref(r T ref) T weakref

// Attempts to upgrade a weak reference to a strong reference.
// Returns Some(ref) if the object is still alive, None otherwise.
public intrinsic let [T Any]upgrade_ref(w T weakref) [T ref]Option

// Allocates uninitialized memory for `capacity` number of elements.
public intrinsic let [T Any]alloc_memory(capacity UInt) T ptr

// Deallocates the memory pointed to by `ptr`.
// PRECONDITION: The memory must be deinitialized.
public intrinsic let [T Any]dealloc_memory(p T ptr) Void

// Copies `count` elements from `source` to `dest`. Regions must NOT overlap.
public intrinsic let [T Any]copy_memory(dest T ptr, source T ptr, count UInt) Void

// Moves `count` elements from `source` to `dest`. Regions may overlap.
public intrinsic let [T Any]move_memory(dest T ptr, source T ptr, count UInt) Void

// ============================================================================
// SECTION 3: Pointer Operations
// ============================================================================

// Pointer operations (global functions)
public intrinsic let [T Any]init_memory(p T ptr, value T) Void
public intrinsic let [T Any]deinit_memory(p T ptr) Void
public intrinsic let [T Any]take_memory(p T ptr) T
public intrinsic let [T Any]null_ptr() T ptr

// Thread spawn intrinsic: creates a new OS thread executing the given closure.
// stack_size of 0 means default stack size.
// Returns 0 on success, non-zero on failure.
// The closure is passed by value to the C runtime which invokes and releases it.
public intrinsic let spawn_thread(out_handle UInt8 ptr ptr, out_tid UInt64 ptr, f [Void]Func, stack_size UInt64) Int32

intrinsic given[T Any] T ptr {
    // Compiler protocol: Eq
    equals(self, other T ptr) Bool
}

// ============================================================================
// SECTION 4: Primitive Eq (intrinsic)
// ============================================================================
intrinsic given Bool {
    equals(self, other Bool) Bool
}

intrinsic given Int {
    equals(self, other Int) Bool
}

intrinsic given Int8 {
    equals(self, other Int8) Bool
}

intrinsic given Int16 {
    equals(self, other Int16) Bool
}

intrinsic given Int32 {
    equals(self, other Int32) Bool
}

intrinsic given Int64 {
    equals(self, other Int64) Bool
}

intrinsic given UInt {
    equals(self, other UInt) Bool
}

intrinsic given UInt8 {
    equals(self, other UInt8) Bool
}

intrinsic given UInt16 {
    equals(self, other UInt16) Bool
}

intrinsic given UInt32 {
    equals(self, other UInt32) Bool
}

intrinsic given UInt64 {
    equals(self, other UInt64) Bool
}

intrinsic given Float32 {
    equals(self, other Float32) Bool
}

intrinsic given Float64 {
    equals(self, other Float64) Bool
}

// ============================================================================
// SECTION 5: Primitive Ord (intrinsic)
// ============================================================================
intrinsic given Bool {
    compare(self, other Bool) Int
}

intrinsic given Int {
    compare(self, other Int) Int
}

intrinsic given Int8 {
    compare(self, other Int8) Int
}

intrinsic given Int16 {
    compare(self, other Int16) Int
}

intrinsic given Int32 {
    compare(self, other Int32) Int
}

intrinsic given Int64 {
    compare(self, other Int64) Int
}

intrinsic given UInt {
    compare(self, other UInt) Int
}

intrinsic given UInt8 {
    compare(self, other UInt8) Int
}

intrinsic given UInt16 {
    compare(self, other UInt16) Int
}

intrinsic given UInt32 {
    compare(self, other UInt32) Int
}

intrinsic given UInt64 {
    compare(self, other UInt64) Int
}

intrinsic given Float32 {
    compare(self, other Float32) Int
}

intrinsic given Float64 {
    compare(self, other Float64) Int
}

// ============================================================================
// SECTION 6: Float Bit Manipulation (runtime)
// ============================================================================
foreign let koral_float32_to_bits(value Float32) UInt32
foreign let koral_float32_from_bits(bits UInt32) Float32
foreign let koral_float64_to_bits(value Float64) UInt64
foreign let koral_float64_from_bits(bits UInt64) Float64

given Float32 {
    public to_bits(self) UInt32 = koral_float32_to_bits(self)
    public from_bits(bits UInt32) Float32 = koral_float32_from_bits(bits)
}

given Float64 {
    public to_bits(self) UInt64 = koral_float64_to_bits(self)
    public from_bits(bits UInt64) Float64 = koral_float64_from_bits(bits)
}

// ============================================================================
// SECTION 8: Primitive Numeric Utilities
// ============================================================================
given Int {
    public max() Int = (Int)((~(UInt)0) >> 1)
    public min() Int = ~Int.max()
}

given Int8 {
    public max() Int8 = (Int8)((~(UInt8)0) >> 1)
    public min() Int8 = ~Int8.max()
}

given Int16 {
    public max() Int16 = (Int16)((~(UInt16)0) >> 1)
    public min() Int16 = ~Int16.max()
}

given Int32 {
    public max() Int32 = (Int32)((~(UInt32)0) >> 1)
    public min() Int32 = ~Int32.max()
}

given Int64 {
    public max() Int64 = (Int64)((~(UInt64)0) >> 1)
    public min() Int64 = ~Int64.max()
}

given UInt {
    public max() UInt = ~(UInt)0
    public min() UInt = 0
}

given UInt8 {
    public max() UInt8 = ~(UInt8)0
    public min() UInt8 = 0
}

given UInt16 {
    public max() UInt16 = ~(UInt16)0
    public min() UInt16 = 0
}

given UInt32 {
    public max() UInt32 = ~(UInt32)0
    public min() UInt32 = 0
}

given UInt64 {
    public max() UInt64 = ~(UInt64)0
    public min() UInt64 = 0
}

given Float32 {
    public inf() Float32 = Float32.from_bits(2139095040)
    public nan() Float32 = Float32.from_bits(2143289344)
    public min_normal() Float32 = Float32.from_bits(8388608)
    public min_denormal() Float32 = Float32.from_bits(1)
    public max() Float32 = Float32.from_bits(2139095039)
    public min() Float32 = Float32.from_bits(4286578687)

    public is_nan(self) Bool = {
        let bits = self.to_bits()
        let exp = (bits >> 23) & 255
        let mantissa = bits & 8388607
        exp == 255 and mantissa <> 0
    }

    public is_inf(self) Bool = {
        let bits = self.to_bits()
        let exp = (bits >> 23) & 255
        let mantissa = bits & 8388607
        exp == 255 and mantissa == 0
    }

    public is_normal(self) Bool = {
        let bits = self.to_bits()
        let exp = (bits >> 23) & 255
        exp > 0 and exp < 255
    }
}

given Float64 {
    public inf() Float64 = Float64.from_bits((UInt64)2047 << 52)
    public nan() Float64 = Float64.from_bits(((UInt64)2047 << 52) | ((UInt64)1 << 51))
    public min_normal() Float64 = Float64.from_bits((UInt64)1 << 52)
    public min_denormal() Float64 = Float64.from_bits(1)

    public max() Float64 = {
        let exp_bits UInt64 = (UInt64)2046 << 52
        let mantissa_bits UInt64 = ((UInt64)1 << 52) - 1
        Float64.from_bits(exp_bits | mantissa_bits)
    }

    public min() Float64 = {
        let sign_bit UInt64 = (UInt64)1 << 63
        let exp_bits UInt64 = (UInt64)2046 << 52
        let mantissa_bits UInt64 = ((UInt64)1 << 52) - 1
        Float64.from_bits(sign_bit | exp_bits | mantissa_bits)
    }

    public is_nan(self) Bool = {
        let bits = self.to_bits()
        let exp = (bits >> 52) & 2047
        let mantissa = bits & 4503599627370495
        exp == 2047 and mantissa <> 0
    }

    public is_inf(self) Bool = {
        let bits = self.to_bits()
        let exp = (bits >> 52) & 2047
        let mantissa = bits & 4503599627370495
        exp == 2047 and mantissa == 0
    }

    public is_normal(self) Bool = {
        let bits = self.to_bits()
        let exp = (bits >> 52) & 2047
        exp > 0 and exp < 2047
    }
}


// ============================================================================
// SECTION 9: Float Classification Functions (is_finite, is_sign_positive, is_sign_negative)
// ============================================================================
given Float64 {
    public is_finite(self) Bool = {
        let bits = self.to_bits()
        let exp = (bits >> 52) & 2047
        exp <> 2047
    }

    public is_sign_positive(self) Bool = {
        let bits = self.to_bits()
        (bits >> 63) == 0
    }

    public is_sign_negative(self) Bool = {
        let bits = self.to_bits()
        (bits >> 63) <> 0
    }
}

given Float32 {
    public is_finite(self) Bool = {
        let bits = self.to_bits()
        let exp = (bits >> 23) & 255
        exp <> 255
    }

    public is_sign_positive(self) Bool = {
        let bits = self.to_bits()
        (bits >> 31) == 0
    }

    public is_sign_negative(self) Bool = {
        let bits = self.to_bits()
        (bits >> 31) <> 0
    }
}


// ============================================================================
// SECTION 10: Integer Bit Manipulation Functions
// ============================================================================

// --- UInt (64-bit) ---
given UInt {
    public count_ones(self) UInt = {
        let mut n = self
        let mut count UInt = 0
        while n <> 0 then {
            count = count + (n & 1)
            n = n >> 1
        }
        count
    }

    public count_zeros(self) UInt = 64 - self.count_ones()

    public leading_zeros(self) UInt = {
        if self == 0 then 64
        else {
            let mut n = self
            let mut count UInt = 0
            let mut mask UInt = (UInt)1 << 63
            while (n & mask) == 0 then {
                count = count + 1
                mask = mask >> 1
            }
            count
        }
    }

    public trailing_zeros(self) UInt = {
        if self == 0 then 64
        else {
            let mut n = self
            let mut count UInt = 0
            while (n & 1) == 0 then {
                count = count + 1
                n = n >> 1
            }
            count
        }
    }

    public leading_ones(self) UInt = (~self).leading_zeros()
    public trailing_ones(self) UInt = (~self).trailing_zeros()

    public rotate_left(self, n UInt) Self = {
        let bits UInt = 64
        let shift = n % bits
        (self << shift) | (self >> (bits - shift))
    }

    public rotate_right(self, n UInt) Self = {
        let bits UInt = 64
        let shift = n % bits
        (self >> shift) | (self << (bits - shift))
    }

    public reverse_bits(self) Self = {
        let mut n = self
        let mut result UInt = 0
        let mut i UInt = 0
        while i < 64 then {
            result = (result << 1) | (n & 1)
            n = n >> 1
            i = i + 1
        }
        result
    }

    public swap_bytes(self) Self = {
        let b0 = (self & 255) << 56
        let b1 = ((self >> 8) & 255) << 48
        let b2 = ((self >> 16) & 255) << 40
        let b3 = ((self >> 24) & 255) << 32
        let b4 = ((self >> 32) & 255) << 24
        let b5 = ((self >> 40) & 255) << 16
        let b6 = ((self >> 48) & 255) << 8
        let b7 = (self >> 56) & 255
        b0 | b1 | b2 | b3 | b4 | b5 | b6 | b7
    }

    public is_power_of_two(self) Bool = self <> 0 and (self & (self - 1)) == 0

    public next_power_of_two(self) Self = {
        if self == 0 then 1
        else if self.is_power_of_two() then self
        else {
            let mut n = self - 1
            n = n | (n >> 1)
            n = n | (n >> 2)
            n = n | (n >> 4)
            n = n | (n >> 8)
            n = n | (n >> 16)
            n = n | (n >> 32)
            n + 1
        }
    }
}


// --- UInt64 (64-bit) ---
given UInt64 {
    public count_ones(self) UInt = {
        let mut n = self
        let mut count UInt = 0
        while n <> 0 then {
            count = count + (UInt)(n & 1)
            n = n >> 1
        }
        count
    }

    public count_zeros(self) UInt = 64 - self.count_ones()

    public leading_zeros(self) UInt = {
        if self == 0 then 64
        else {
            let mut n = self
            let mut count UInt = 0
            let mut mask UInt64 = (UInt64)1 << 63
            while (n & mask) == 0 then {
                count = count + 1
                mask = mask >> 1
            }
            count
        }
    }

    public trailing_zeros(self) UInt = {
        if self == 0 then 64
        else {
            let mut n = self
            let mut count UInt = 0
            while (n & 1) == 0 then {
                count = count + 1
                n = n >> 1
            }
            count
        }
    }

    public leading_ones(self) UInt = (~self).leading_zeros()
    public trailing_ones(self) UInt = (~self).trailing_zeros()

    public rotate_left(self, n UInt) Self = {
        let shift UInt64 = (UInt64)(n % 64)
        (self << shift) | (self >> (64 - shift))
    }

    public rotate_right(self, n UInt) Self = {
        let shift UInt64 = (UInt64)(n % 64)
        (self >> shift) | (self << (64 - shift))
    }

    public reverse_bits(self) Self = {
        let mut n = self
        let mut result UInt64 = 0
        let mut i UInt = 0
        while i < 64 then {
            result = (result << 1) | (n & 1)
            n = n >> 1
            i = i + 1
        }
        result
    }

    public swap_bytes(self) Self = {
        let b0 = (self & 255) << 56
        let b1 = ((self >> 8) & 255) << 48
        let b2 = ((self >> 16) & 255) << 40
        let b3 = ((self >> 24) & 255) << 32
        let b4 = ((self >> 32) & 255) << 24
        let b5 = ((self >> 40) & 255) << 16
        let b6 = ((self >> 48) & 255) << 8
        let b7 = (self >> 56) & 255
        b0 | b1 | b2 | b3 | b4 | b5 | b6 | b7
    }

    public is_power_of_two(self) Bool = self <> 0 and (self & (self - 1)) == 0

    public next_power_of_two(self) Self = {
        if self == 0 then 1
        else if self.is_power_of_two() then self
        else {
            let mut n = self - 1
            n = n | (n >> 1)
            n = n | (n >> 2)
            n = n | (n >> 4)
            n = n | (n >> 8)
            n = n | (n >> 16)
            n = n | (n >> 32)
            n + 1
        }
    }
}

// --- UInt32 (32-bit) ---
given UInt32 {
    public count_ones(self) UInt = {
        let mut n = self
        let mut count UInt = 0
        while n <> 0 then {
            count = count + (UInt)(n & 1)
            n = n >> 1
        }
        count
    }

    public count_zeros(self) UInt = 32 - self.count_ones()

    public leading_zeros(self) UInt = {
        if self == 0 then 32
        else {
            let mut n = self
            let mut count UInt = 0
            let mut mask UInt32 = (UInt32)1 << 31
            while (n & mask) == 0 then {
                count = count + 1
                mask = mask >> 1
            }
            count
        }
    }

    public trailing_zeros(self) UInt = {
        if self == 0 then 32
        else {
            let mut n = self
            let mut count UInt = 0
            while (n & 1) == 0 then {
                count = count + 1
                n = n >> 1
            }
            count
        }
    }

    public leading_ones(self) UInt = (~self).leading_zeros()
    public trailing_ones(self) UInt = (~self).trailing_zeros()

    public rotate_left(self, n UInt) Self = {
        let shift UInt32 = (UInt32)(n % 32)
        (self << shift) | (self >> (32 - shift))
    }

    public rotate_right(self, n UInt) Self = {
        let shift UInt32 = (UInt32)(n % 32)
        (self >> shift) | (self << (32 - shift))
    }

    public reverse_bits(self) Self = {
        let mut n = self
        let mut result UInt32 = 0
        let mut i UInt = 0
        while i < 32 then {
            result = (result << 1) | (n & 1)
            n = n >> 1
            i = i + 1
        }
        result
    }

    public swap_bytes(self) Self = {
        let b0 = (self & 255) << 24
        let b1 = ((self >> 8) & 255) << 16
        let b2 = ((self >> 16) & 255) << 8
        let b3 = (self >> 24) & 255
        b0 | b1 | b2 | b3
    }

    public is_power_of_two(self) Bool = self <> 0 and (self & (self - 1)) == 0

    public next_power_of_two(self) Self = {
        if self == 0 then 1
        else if self.is_power_of_two() then self
        else {
            let mut n = self - 1
            n = n | (n >> 1)
            n = n | (n >> 2)
            n = n | (n >> 4)
            n = n | (n >> 8)
            n = n | (n >> 16)
            n + 1
        }
    }
}


// --- UInt16 (16-bit) ---
given UInt16 {
    public count_ones(self) UInt = {
        let mut n = self
        let mut count UInt = 0
        while n <> 0 then {
            count = count + (UInt)(n & 1)
            n = n >> 1
        }
        count
    }

    public count_zeros(self) UInt = 16 - self.count_ones()

    public leading_zeros(self) UInt = {
        if self == 0 then 16
        else {
            let mut n = self
            let mut count UInt = 0
            let mut mask UInt16 = (UInt16)1 << 15
            while (n & mask) == 0 then {
                count = count + 1
                mask = mask >> 1
            }
            count
        }
    }

    public trailing_zeros(self) UInt = {
        if self == 0 then 16
        else {
            let mut n = self
            let mut count UInt = 0
            while (n & 1) == 0 then {
                count = count + 1
                n = n >> 1
            }
            count
        }
    }

    public leading_ones(self) UInt = (~self).leading_zeros()
    public trailing_ones(self) UInt = (~self).trailing_zeros()

    public rotate_left(self, n UInt) Self = {
        let shift UInt16 = (UInt16)(n % 16)
        (self << shift) | (self >> (16 - shift))
    }

    public rotate_right(self, n UInt) Self = {
        let shift UInt16 = (UInt16)(n % 16)
        (self >> shift) | (self << (16 - shift))
    }

    public reverse_bits(self) Self = {
        let mut n = self
        let mut result UInt16 = 0
        let mut i UInt = 0
        while i < 16 then {
            result = (result << 1) | (n & 1)
            n = n >> 1
            i = i + 1
        }
        result
    }

    public swap_bytes(self) Self = {
        let b0 = (self & 255) << 8
        let b1 = (self >> 8) & 255
        b0 | b1
    }

    public is_power_of_two(self) Bool = self <> 0 and (self & (self - 1)) == 0

    public next_power_of_two(self) Self = {
        if self == 0 then 1
        else if self.is_power_of_two() then self
        else {
            let mut n = self - 1
            n = n | (n >> 1)
            n = n | (n >> 2)
            n = n | (n >> 4)
            n = n | (n >> 8)
            n + 1
        }
    }
}

// --- UInt8 (8-bit) ---
given UInt8 {
    public count_ones(self) UInt = {
        let mut n = self
        let mut count UInt = 0
        while n <> 0 then {
            count = count + (UInt)(n & 1)
            n = n >> 1
        }
        count
    }

    public count_zeros(self) UInt = 8 - self.count_ones()

    public leading_zeros(self) UInt = {
        if self == 0 then 8
        else {
            let mut n = self
            let mut count UInt = 0
            let mut mask UInt8 = (UInt8)1 << 7
            while (n & mask) == 0 then {
                count = count + 1
                mask = mask >> 1
            }
            count
        }
    }

    public trailing_zeros(self) UInt = {
        if self == 0 then 8
        else {
            let mut n = self
            let mut count UInt = 0
            while (n & 1) == 0 then {
                count = count + 1
                n = n >> 1
            }
            count
        }
    }

    public leading_ones(self) UInt = (~self).leading_zeros()
    public trailing_ones(self) UInt = (~self).trailing_zeros()

    public rotate_left(self, n UInt) Self = {
        let shift UInt8 = (UInt8)(n % 8)
        (self << shift) | (self >> (8 - shift))
    }

    public rotate_right(self, n UInt) Self = {
        let shift UInt8 = (UInt8)(n % 8)
        (self >> shift) | (self << (8 - shift))
    }

    public reverse_bits(self) Self = {
        let mut n = self
        let mut result UInt8 = 0
        let mut i UInt = 0
        while i < 8 then {
            result = (result << 1) | (n & 1)
            n = n >> 1
            i = i + 1
        }
        result
    }

    public swap_bytes(self) Self = self

    public is_power_of_two(self) Bool = self <> 0 and (self & (self - 1)) == 0

    public next_power_of_two(self) Self = {
        if self == 0 then 1
        else if self.is_power_of_two() then self
        else {
            let mut n = self - 1
            n = n | (n >> 1)
            n = n | (n >> 2)
            n = n | (n >> 4)
            n + 1
        }
    }
}


// --- Int (64-bit, signed) ---
given Int {
    public count_ones(self) UInt = {
        let mut n = self
        let mut count UInt = 0
        let mut i UInt = 0
        while i < 64 then {
            count = count + (UInt)(n & 1)
            n = n >> 1
            i = i + 1
        }
        count
    }

    public count_zeros(self) UInt = 64 - self.count_ones()

    public leading_zeros(self) UInt = {
        if self == 0 then 64
        else {
            let mut n = self
            let mut count UInt = 0
            let mut mask Int = (Int)((UInt)1 << 63)
            while (n & mask) == 0 then {
                count = count + 1
                mask = (Int)((UInt)mask >> 1)
            }
            count
        }
    }

    public trailing_zeros(self) UInt = {
        if self == 0 then 64
        else {
            let mut n = self
            let mut count UInt = 0
            while (n & 1) == 0 then {
                count = count + 1
                n = n >> 1
            }
            count
        }
    }

    public leading_ones(self) UInt = (~self).leading_zeros()
    public trailing_ones(self) UInt = (~self).trailing_zeros()

    public rotate_left(self, n UInt) Self = {
        let bits UInt = 64
        let shift = n % bits
        let u = (UInt)self
        (Int)((u << shift) | (u >> (bits - shift)))
    }

    public rotate_right(self, n UInt) Self = {
        let bits UInt = 64
        let shift = n % bits
        let u = (UInt)self
        (Int)((u >> shift) | (u << (bits - shift)))
    }

    public reverse_bits(self) Self = {
        let mut n = (UInt)self
        let mut result UInt = 0
        let mut i UInt = 0
        while i < 64 then {
            result = (result << 1) | (n & 1)
            n = n >> 1
            i = i + 1
        }
        (Int)result
    }

    public swap_bytes(self) Self = {
        let u = (UInt)self
        let b0 = (u & 255) << 56
        let b1 = ((u >> 8) & 255) << 48
        let b2 = ((u >> 16) & 255) << 40
        let b3 = ((u >> 24) & 255) << 32
        let b4 = ((u >> 32) & 255) << 24
        let b5 = ((u >> 40) & 255) << 16
        let b6 = ((u >> 48) & 255) << 8
        let b7 = (u >> 56) & 255
        (Int)(b0 | b1 | b2 | b3 | b4 | b5 | b6 | b7)
    }
}

// --- Int64 (64-bit, signed) ---
given Int64 {
    public count_ones(self) UInt = {
        let mut n = self
        let mut count UInt = 0
        let mut i UInt = 0
        while i < 64 then {
            count = count + (UInt)(n & 1)
            n = n >> 1
            i = i + 1
        }
        count
    }

    public count_zeros(self) UInt = 64 - self.count_ones()

    public leading_zeros(self) UInt = {
        if self == 0 then 64
        else {
            let mut n = self
            let mut count UInt = 0
            let mut mask Int64 = (Int64)((UInt64)1 << 63)
            while (n & mask) == 0 then {
                count = count + 1
                mask = (Int64)((UInt64)mask >> 1)
            }
            count
        }
    }

    public trailing_zeros(self) UInt = {
        if self == 0 then 64
        else {
            let mut n = self
            let mut count UInt = 0
            while (n & 1) == 0 then {
                count = count + 1
                n = n >> 1
            }
            count
        }
    }

    public leading_ones(self) UInt = (~self).leading_zeros()
    public trailing_ones(self) UInt = (~self).trailing_zeros()

    public rotate_left(self, n UInt) Self = {
        let shift UInt64 = (UInt64)(n % 64)
        let u = (UInt64)self
        (Int64)((u << shift) | (u >> (64 - shift)))
    }

    public rotate_right(self, n UInt) Self = {
        let shift UInt64 = (UInt64)(n % 64)
        let u = (UInt64)self
        (Int64)((u >> shift) | (u << (64 - shift)))
    }

    public reverse_bits(self) Self = {
        let mut n = (UInt64)self
        let mut result UInt64 = 0
        let mut i UInt = 0
        while i < 64 then {
            result = (result << 1) | (n & 1)
            n = n >> 1
            i = i + 1
        }
        (Int64)result
    }

    public swap_bytes(self) Self = {
        let u = (UInt64)self
        let b0 = (u & 255) << 56
        let b1 = ((u >> 8) & 255) << 48
        let b2 = ((u >> 16) & 255) << 40
        let b3 = ((u >> 24) & 255) << 32
        let b4 = ((u >> 32) & 255) << 24
        let b5 = ((u >> 40) & 255) << 16
        let b6 = ((u >> 48) & 255) << 8
        let b7 = (u >> 56) & 255
        (Int64)(b0 | b1 | b2 | b3 | b4 | b5 | b6 | b7)
    }
}


// --- Int32 (32-bit, signed) ---
given Int32 {
    public count_ones(self) UInt = {
        let mut n = self
        let mut count UInt = 0
        let mut i UInt = 0
        while i < 32 then {
            count = count + (UInt)(n & 1)
            n = n >> 1
            i = i + 1
        }
        count
    }

    public count_zeros(self) UInt = 32 - self.count_ones()

    public leading_zeros(self) UInt = {
        if self == 0 then 32
        else {
            let mut n = self
            let mut count UInt = 0
            let mut mask Int32 = (Int32)((UInt32)1 << 31)
            while (n & mask) == 0 then {
                count = count + 1
                mask = (Int32)((UInt32)mask >> 1)
            }
            count
        }
    }

    public trailing_zeros(self) UInt = {
        if self == 0 then 32
        else {
            let mut n = self
            let mut count UInt = 0
            while (n & 1) == 0 then {
                count = count + 1
                n = n >> 1
            }
            count
        }
    }

    public leading_ones(self) UInt = (~self).leading_zeros()
    public trailing_ones(self) UInt = (~self).trailing_zeros()

    public rotate_left(self, n UInt) Self = {
        let shift UInt32 = (UInt32)(n % 32)
        let u = (UInt32)self
        (Int32)((u << shift) | (u >> (32 - shift)))
    }

    public rotate_right(self, n UInt) Self = {
        let shift UInt32 = (UInt32)(n % 32)
        let u = (UInt32)self
        (Int32)((u >> shift) | (u << (32 - shift)))
    }

    public reverse_bits(self) Self = {
        let mut n = (UInt32)self
        let mut result UInt32 = 0
        let mut i UInt = 0
        while i < 32 then {
            result = (result << 1) | (n & 1)
            n = n >> 1
            i = i + 1
        }
        (Int32)result
    }

    public swap_bytes(self) Self = {
        let u = (UInt32)self
        let b0 = (u & 255) << 24
        let b1 = ((u >> 8) & 255) << 16
        let b2 = ((u >> 16) & 255) << 8
        let b3 = (u >> 24) & 255
        (Int32)(b0 | b1 | b2 | b3)
    }
}

// --- Int16 (16-bit, signed) ---
given Int16 {
    public count_ones(self) UInt = {
        let mut n = self
        let mut count UInt = 0
        let mut i UInt = 0
        while i < 16 then {
            count = count + (UInt)(n & 1)
            n = n >> 1
            i = i + 1
        }
        count
    }

    public count_zeros(self) UInt = 16 - self.count_ones()

    public leading_zeros(self) UInt = {
        if self == 0 then 16
        else {
            let mut n = self
            let mut count UInt = 0
            let mut mask Int16 = (Int16)((UInt16)1 << 15)
            while (n & mask) == 0 then {
                count = count + 1
                mask = (Int16)((UInt16)mask >> 1)
            }
            count
        }
    }

    public trailing_zeros(self) UInt = {
        if self == 0 then 16
        else {
            let mut n = self
            let mut count UInt = 0
            while (n & 1) == 0 then {
                count = count + 1
                n = n >> 1
            }
            count
        }
    }

    public leading_ones(self) UInt = (~self).leading_zeros()
    public trailing_ones(self) UInt = (~self).trailing_zeros()

    public rotate_left(self, n UInt) Self = {
        let shift UInt16 = (UInt16)(n % 16)
        let u = (UInt16)self
        (Int16)((u << shift) | (u >> (16 - shift)))
    }

    public rotate_right(self, n UInt) Self = {
        let shift UInt16 = (UInt16)(n % 16)
        let u = (UInt16)self
        (Int16)((u >> shift) | (u << (16 - shift)))
    }

    public reverse_bits(self) Self = {
        let mut n = (UInt16)self
        let mut result UInt16 = 0
        let mut i UInt = 0
        while i < 16 then {
            result = (result << 1) | (n & 1)
            n = n >> 1
            i = i + 1
        }
        (Int16)result
    }

    public swap_bytes(self) Self = {
        let u = (UInt16)self
        let b0 = (u & 255) << 8
        let b1 = (u >> 8) & 255
        (Int16)(b0 | b1)
    }
}

// --- Int8 (8-bit, signed) ---
given Int8 {
    public count_ones(self) UInt = {
        let mut n = self
        let mut count UInt = 0
        let mut i UInt = 0
        while i < 8 then {
            count = count + (UInt)(n & 1)
            n = n >> 1
            i = i + 1
        }
        count
    }

    public count_zeros(self) UInt = 8 - self.count_ones()

    public leading_zeros(self) UInt = {
        if self == 0 then 8
        else {
            let mut n = self
            let mut count UInt = 0
            let mut mask Int8 = (Int8)((UInt8)1 << 7)
            while (n & mask) == 0 then {
                count = count + 1
                mask = (Int8)((UInt8)mask >> 1)
            }
            count
        }
    }

    public trailing_zeros(self) UInt = {
        if self == 0 then 8
        else {
            let mut n = self
            let mut count UInt = 0
            while (n & 1) == 0 then {
                count = count + 1
                n = n >> 1
            }
            count
        }
    }

    public leading_ones(self) UInt = (~self).leading_zeros()
    public trailing_ones(self) UInt = (~self).trailing_zeros()

    public rotate_left(self, n UInt) Self = {
        let shift UInt8 = (UInt8)(n % 8)
        let u = (UInt8)self
        (Int8)((u << shift) | (u >> (8 - shift)))
    }

    public rotate_right(self, n UInt) Self = {
        let shift UInt8 = (UInt8)(n % 8)
        let u = (UInt8)self
        (Int8)((u >> shift) | (u << (8 - shift)))
    }

    public reverse_bits(self) Self = {
        let mut n = (UInt8)self
        let mut result UInt8 = 0
        let mut i UInt = 0
        while i < 8 then {
            result = (result << 1) | (n & 1)
            n = n >> 1
            i = i + 1
        }
        (Int8)result
    }

    public swap_bytes(self) Self = self
}
