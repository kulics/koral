// ============================================================================
// Koral Standard Library - Primitive Types
// ============================================================================

// SECTION 1: Primitive Types
public intrinsic type Bool
public intrinsic type Never

public intrinsic type Int
public intrinsic type Int8
public intrinsic type Int16
public intrinsic type Int32
public intrinsic type Int64

public intrinsic type UInt
public intrinsic type UInt8
public intrinsic type UInt16
public intrinsic type UInt32
public intrinsic type UInt64

public intrinsic type Float32
public intrinsic type Float64


// ============================================================================
// SECTION 2: Memory Management Primitives
// ============================================================================

public intrinsic let [T Any]ref_count(r T ref) Int

// Allocates uninitialized memory for `capacity` number of elements.
public intrinsic let [T Any]alloc_memory(capacity Int) T ptr

// Deallocates the memory pointed to by `ptr`.
// PRECONDITION: The memory must be deinitialized.
public intrinsic let [T Any]dealloc_memory(p T ptr) Void

// Copies `count` elements from `source` to `dest`. Regions must NOT overlap.
public intrinsic let [T Any]copy_memory(dest T ptr, source T ptr, count Int) Void

// Moves `count` elements from `source` to `dest`. Regions may overlap.
public intrinsic let [T Any]move_memory(dest T ptr, source T ptr, count Int) Void

// ============================================================================
// SECTION 3: Pointer Operations
// ============================================================================

// Pointer operations (global functions)
public intrinsic let [T Any]init_memory(p T ptr, value T) Void
public intrinsic let [T Any]deinit_memory(p T ptr) Void
public intrinsic let [T Any]take_memory(p T ptr) T
public intrinsic let [T Any]offset_ptr(p T ptr, n Int) T ptr
public intrinsic let [T Any]null_ptr() T ptr

intrinsic given[T Any] T ptr {
    // Compiler protocol: Eq
    equals(self, other T ptr) Bool
}

// ============================================================================
// SECTION 4: Primitive Eq (intrinsic)
// ============================================================================

intrinsic given Bool { equals(self, other Bool) Bool }

intrinsic given Int { equals(self, other Int) Bool }
intrinsic given Int8 { equals(self, other Int8) Bool }
intrinsic given Int16 { equals(self, other Int16) Bool }
intrinsic given Int32 { equals(self, other Int32) Bool }
intrinsic given Int64 { equals(self, other Int64) Bool }

intrinsic given UInt { equals(self, other UInt) Bool }
intrinsic given UInt8 { equals(self, other UInt8) Bool }
intrinsic given UInt16 { equals(self, other UInt16) Bool }
intrinsic given UInt32 { equals(self, other UInt32) Bool }
intrinsic given UInt64 { equals(self, other UInt64) Bool }

intrinsic given Float32 { equals(self, other Float32) Bool }
intrinsic given Float64 { equals(self, other Float64) Bool }

// ============================================================================
// SECTION 5: Primitive Ord (intrinsic)
// ============================================================================

intrinsic given Bool { compare(self, other Bool) Int }

intrinsic given Int { compare(self, other Int) Int }
intrinsic given Int8 { compare(self, other Int8) Int }
intrinsic given Int16 { compare(self, other Int16) Int }
intrinsic given Int32 { compare(self, other Int32) Int }
intrinsic given Int64 { compare(self, other Int64) Int }

intrinsic given UInt { compare(self, other UInt) Int }
intrinsic given UInt8 { compare(self, other UInt8) Int }
intrinsic given UInt16 { compare(self, other UInt16) Int }
intrinsic given UInt32 { compare(self, other UInt32) Int }
intrinsic given UInt64 { compare(self, other UInt64) Int }

intrinsic given Float32 { compare(self, other Float32) Int }
intrinsic given Float64 { compare(self, other Float64) Int }

// ============================================================================
// SECTION 6: Float Bit Manipulation (runtime)
// ============================================================================

foreign let koral_float32_to_bits(value Float32) UInt32
foreign let koral_float32_from_bits(bits UInt32) Float32
foreign let koral_float64_to_bits(value Float64) UInt64
foreign let koral_float64_from_bits(bits UInt64) Float64

given Float32 {
    public to_bits(self) UInt32 = koral_float32_to_bits(self)
    public from_bits(bits UInt32) Float32 = koral_float32_from_bits(bits)
}

given Float64 {
    public to_bits(self) UInt64 = koral_float64_to_bits(self)
    public from_bits(bits UInt64) Float64 = koral_float64_from_bits(bits)
}

// ============================================================================
// SECTION 8: Primitive Numeric Utilities
// ============================================================================

given Int {
    public max() Int = (Int){ (~0u) >> 1 }
    public min() Int = ~Int.max()
}

given Int8 {
    public max() Int8 = (Int8){ (~0u8) >> 1 }
    public min() Int8 = ~Int8.max()
}

given Int16 {
    public max() Int16 = (Int16){ (~0u16) >> 1 }
    public min() Int16 = ~Int16.max()
}

given Int32 {
    public max() Int32 = (Int32){ (~0u32) >> 1 }
    public min() Int32 = ~Int32.max()
}

given Int64 {
    public max() Int64 = (Int64){ (~0u64) >> 1 }
    public min() Int64 = ~Int64.max()
}

given UInt {
    public max() UInt = ~0u
    public min() UInt = 0u
}

given UInt8 {
    public max() UInt8 = ~0u8
    public min() UInt8 = 0u8
}

given UInt16 {
    public max() UInt16 = ~0u16
    public min() UInt16 = 0u16
}

given UInt32 {
    public max() UInt32 = ~0u32
    public min() UInt32 = 0u32
}

given UInt64 {
    public max() UInt64 = ~0u64
    public min() UInt64 = 0u64
}

given Float32 {
    public inf() Float32 = Float32.from_bits(2139095040u32)
    public nan() Float32 = Float32.from_bits(2143289344u32)
    public min_normal() Float32 = Float32.from_bits(8388608u32)
    public min_denormal() Float32 = Float32.from_bits(1u32)
    public max() Float32 = Float32.from_bits(2139095039u32)
    public min() Float32 = Float32.from_bits(4286578687u32)
    
    public is_nan(self) Bool = {
        let bits = self.to_bits()
        let exp = { bits >> 23 } & 255u32
        let mantissa = bits & 8388607u32
        exp == 255u32 and mantissa <> 0u32
    }
    
    public is_inf(self) Bool = {
        let bits = self.to_bits()
        let exp = { bits >> 23 } & 255u32
        let mantissa = bits & 8388607u32
        exp == 255u32 and mantissa == 0u32
    }
    
    public is_normal(self) Bool = {
        let bits = self.to_bits()
        let exp = { bits >> 23 } & 255u32
        exp > 0u32 and exp < 255u32
    }
}

given Float64 {
    public inf() Float64 = Float64.from_bits(2047u64 << 52)
    public nan() Float64 = Float64.from_bits({ 2047u64 << 52 } | { 1u64 << 51 })
    public min_normal() Float64 = Float64.from_bits(1u64 << 52)
    public min_denormal() Float64 = Float64.from_bits(1u64)
    public max() Float64 = {
        let exp_bits UInt64 = 2046u64 << 52
        let mantissa_bits UInt64 = { 1u64 << 52 } - 1u64
        Float64.from_bits(exp_bits | mantissa_bits)
    }
    public min() Float64 = {
        let sign_bit UInt64 = 1u64 << 63
        let exp_bits UInt64 = 2046u64 << 52
        let mantissa_bits UInt64 = { 1u64 << 52 } - 1u64
        Float64.from_bits(sign_bit | exp_bits | mantissa_bits)
    }
    
    public is_nan(self) Bool = {
        let bits = self.to_bits()
        let exp = { bits >> 52 } & 2047u64
        let mantissa = bits & 4503599627370495u64
        exp == 2047u64 and mantissa <> 0u64
    }
    
    public is_inf(self) Bool = {
        let bits = self.to_bits()
        let exp = { bits >> 52 } & 2047u64
        let mantissa = bits & 4503599627370495u64
        exp == 2047u64 and mantissa == 0u64
    }
    
    public is_normal(self) Bool = {
        let bits = self.to_bits()
        let exp = { bits >> 52 } & 2047u64
        exp > 0u64 and exp < 2047u64
    }
}
