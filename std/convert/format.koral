// ============================================================================
// std.convert - Format Implementation
// ============================================================================
// Provides number-to-string formatting for all numeric types.
// Signed integers: Int, Int8, Int16, Int32, Int64
// Unsigned integers: UInt, UInt8, UInt16, UInt32, UInt64 (task 7.2)
// Floating point: Float32, Float64 (task 8.1, 8.2)
//
// Uses Python-style format spec mini-language via parse_format_spec.
// Invalid format specs or unsupported type characters will panic.
// ============================================================================

// ---------------------------------------------------------------------------
// Helper functions
// ---------------------------------------------------------------------------

// Convert a digit value (0..35) to its ASCII character.
private let digit_to_char(d UInt, uppercase Bool) UInt8 =
    if d < 10 then (UInt8)d + '0'
    else if uppercase then (UInt8)(d - 10) + 'A'
    else (UInt8)(d - 10) + 'a'

// Map a type character to its radix.
private let type_char_to_radix(tc UInt8) UInt =
    if tc == 'b' then (UInt)2
    else if tc == 'o' then (UInt)8
    else if tc == 'd' or tc == 0 then (UInt)10
    else if tc == 'x' or tc == 'X' then (UInt)16
    else panic("unsupported type char for integer")

// Return the radix prefix string for a type character.
private let radix_prefix(tc UInt8) String =
    if tc == 'b' then "0b"
    else if tc == 'o' then "0o"
    else if tc == 'x' then "0x"
    else if tc == 'X' then "0X"
    else ""

// Apply padding and alignment to a string according to the format spec.
private let apply_padding(s String, spec FormatSpec) String = {
    let len = s.count()
    if len >= spec.width then {
        return s
    }
    let fill = if spec.zero_pad then '0' else spec.fill
    let align = if spec.zero_pad then '>' else spec.align
    let pad_total = spec.width - len
    if align == '<' then {
        let mut result = s
        let mut i UInt = 0
        while i < pad_total then {
            result.push(fill)
            i += 1
        }
        return result
    } else if align == '^' then {
        let left_pad = pad_total / 2
        let right_pad = pad_total - left_pad
        let mut result = String.with_capacity(spec.width)
        let mut i UInt = 0
        while i < left_pad then {
            result.push(fill)
            i += 1
        }
        result.push_string(s)
        i = 0
        while i < right_pad then {
            result.push(fill)
            i += 1
        }
        return result
    } else {
        // '>' right-align (default)
        let mut result = String.with_capacity(spec.width)
        let mut i UInt = 0
        while i < pad_total then {
            result.push(fill)
            i += 1
        }
        result.push_string(s)
        return result
    }
}

// Insert grouping separators into a digit string every 3 digits.
private let insert_grouping(digits String, grouping UInt8) String = {
    if grouping == 0 or digits.count() <= 3 then {
        return digits
    }
    let sep = if grouping == ',' then "," else "_"
    let group_size UInt = 3
    let len = digits.count()
    let mut result = String.with_capacity(len + (len / group_size) * sep.count())
    let first_group = len % group_size
    if first_group > 0 then {
        let mut i UInt = 0
        while i < first_group then {
            result.push(digits.at(i))
            i += 1
        }
    }
    let mut pos = first_group
    while pos < len then {
        if pos > 0 then {
            result.push_string(sep)
        }
        let mut j UInt = 0
        while j < group_size and pos + j < len then {
            result.push(digits.at(pos + j))
            j += 1
        }
        pos += group_size
    }
    return result
}

// ---------------------------------------------------------------------------
// given Int { format }
// ---------------------------------------------------------------------------

given Int {
    public format(self, spec String) String = {
        let fmt = parse_format_spec(spec)

        // Validate type character for integer types
        let tc = fmt.type_char
        if tc <> 0 and tc <> 'b' and tc <> 'o' and tc <> 'd' and tc <> 'x' and tc <> 'X' then {
            panic("unsupported format type '" + tc.to_string() + "' for Int")
        }
        if fmt.precision >= 0 then {
            panic("precision not allowed for integer format")
        }

        let is_negative = self < 0
        let mut n = if is_negative then 0 - self else self
        let radix = type_char_to_radix(tc)
        let uppercase = tc == 'X'

        // Convert digits (in reverse order)
        let mut digits = String.new()
        if n == 0 then {
            digits.push('0')
        } else {
            while n > 0 then {
                let d = (UInt)(n % (Int)radix)
                digits.push(digit_to_char(d, uppercase))
                n = n / (Int)radix
            }
        }

        // Reverse the digits
        let mut reversed = String.with_capacity(digits.count())
        let mut i = digits.count()
        while i > 0 then {
            i -= 1
            reversed.push(digits.at(i))
        }

        // Insert grouping separators
        let grouped = insert_grouping(reversed, fmt.grouping)

        // Assemble final string: sign + prefix + digits
        let mut result = String.new()
        if is_negative then {
            result.push('-')
        } else if fmt.sign == '+' then {
            result.push('+')
        }
        if fmt.alt_form then {
            result.push_string(radix_prefix(tc))
        }
        result.push_string(grouped)

        // Apply padding and alignment
        return apply_padding(result, fmt)
    }
}

// ---------------------------------------------------------------------------
// given Int8 { format }
// ---------------------------------------------------------------------------

given Int8 {
    public format(self, spec String) String = ((Int)self).format(spec)
}

// ---------------------------------------------------------------------------
// given Int16 { format }
// ---------------------------------------------------------------------------

given Int16 {
    public format(self, spec String) String = ((Int)self).format(spec)
}

// ---------------------------------------------------------------------------
// given Int32 { format }
// ---------------------------------------------------------------------------

given Int32 {
    public format(self, spec String) String = ((Int)self).format(spec)
}

// ---------------------------------------------------------------------------
// given Int64 { format }
// ---------------------------------------------------------------------------

given Int64 {
    public format(self, spec String) String = ((Int)self).format(spec)
}

// ---------------------------------------------------------------------------
// given UInt { format }
// ---------------------------------------------------------------------------

given UInt {
    public format(self, spec String) String = {
        let fmt = parse_format_spec(spec)

        let tc = fmt.type_char
        if tc <> 0 and tc <> 'b' and tc <> 'o' and tc <> 'd' and tc <> 'x' and tc <> 'X' then {
            panic("unsupported format type '" + tc.to_string() + "' for UInt")
        }
        if fmt.precision >= 0 then {
            panic("precision not allowed for integer format")
        }

        let radix = type_char_to_radix(tc)
        let uppercase = tc == 'X'
        let mut n = self

        let mut digits = String.new()
        if n == 0 then {
            digits.push('0')
        } else {
            while n > 0 then {
                let d = n % radix
                digits.push(digit_to_char(d, uppercase))
                n = n / radix
            }
        }

        let mut reversed = String.with_capacity(digits.count())
        let mut i = digits.count()
        while i > 0 then {
            i -= 1
            reversed.push(digits.at(i))
        }

        let grouped = insert_grouping(reversed, fmt.grouping)

        let mut result = String.new()
        if fmt.sign == '+' then {
            result.push('+')
        }
        if fmt.alt_form then {
            result.push_string(radix_prefix(tc))
        }
        result.push_string(grouped)

        return apply_padding(result, fmt)
    }
}

// ---------------------------------------------------------------------------
// given UInt8 { format }
// ---------------------------------------------------------------------------

given UInt8 {
    public format(self, spec String) String = ((UInt)self).format(spec)
}

// ---------------------------------------------------------------------------
// given UInt16 { format }
// ---------------------------------------------------------------------------

given UInt16 {
    public format(self, spec String) String = ((UInt)self).format(spec)
}

// ---------------------------------------------------------------------------
// given UInt32 { format }
// ---------------------------------------------------------------------------

given UInt32 {
    public format(self, spec String) String = ((UInt)self).format(spec)
}

// ---------------------------------------------------------------------------
// given UInt64 { format }
// ---------------------------------------------------------------------------

given UInt64 {
    public format(self, spec String) String = ((UInt)self).format(spec)
}

// ---------------------------------------------------------------------------
// Floating-point formatting helper functions
// ---------------------------------------------------------------------------

// Fixed-point format (e.g., "3.141593")
private let format_fixed(f Float64, is_negative Bool, precision UInt, sign UInt8, grouping UInt8) String = {
    let int_part = (Int)f
    let frac_part = f - (Float64)int_part

    let mut result = String.new()
    if is_negative then {
        result.push('-')
    } else if sign == '+' then {
        result.push('+')
    }

    let int_str = int_part.to_string()
    let grouped = insert_grouping(int_str, grouping)
    result.push_string(grouped)

    if precision > 0 then {
        result.push('.')
        let mut frac = frac_part
        let mut digits UInt = 0
        while digits < precision then {
            frac = frac * 10.0
            let d = (Int)frac
            result.push((UInt8)d + '0')
            frac = frac - (Float64)d
            digits += 1
        }
    }

    return result
}

// Scientific notation format (e.g., "3.141593e+00")
private let format_scientific(f Float64, is_negative Bool, precision UInt, sign UInt8, uppercase Bool) String = {
    if f == 0.0 then {
        let mut result = String.new()
        if is_negative then { result.push('-') }
        else if sign == '+' then { result.push('+') }
        result.push_string("0.")
        let mut i UInt = 0
        while i < precision then {
            result.push('0')
            i += 1
        }
        result.push_string(if uppercase then "E+00" else "e+00")
        return result
    }

    let mut exp Int = 0
    let mut normalized = f
    if normalized >= 10.0 then {
        while normalized >= 10.0 then {
            normalized = normalized / 10.0
            exp += 1
        }
    } else if normalized < 1.0 then {
        while normalized < 1.0 then {
            normalized = normalized * 10.0
            exp -= 1
        }
    }

    let mut result = String.new()
    if is_negative then { result.push('-') }
    else if sign == '+' then { result.push('+') }

    let int_d = (Int)normalized
    result.push((UInt8)int_d + '0')
    if precision > 0 then {
        result.push('.')
        let mut frac = normalized - (Float64)int_d
        let mut digits UInt = 0
        while digits < precision then {
            frac = frac * 10.0
            let d = (Int)frac
            result.push((UInt8)d + '0')
            frac = frac - (Float64)d
            digits += 1
        }
    }

    result.push(if uppercase then 'E' else 'e')
    if exp >= 0 then { result.push('+') }
    else {
        result.push('-')
        exp = 0 - exp
    }
    if exp < 10 then { result.push('0') }
    result.push_string(exp.to_string())

    return result
}

// Auto format â€” selects fixed or scientific based on exponent (like %g)
private let format_auto(f Float64, is_negative Bool, precision UInt, sign UInt8, uppercase Bool, grouping UInt8) String = {
    if f == 0.0 then {
        return format_fixed(f, is_negative, precision, sign, grouping)
    }

    let mut exp Int = 0
    let mut temp = f
    if temp >= 10.0 then {
        while temp >= 10.0 then {
            temp = temp / 10.0
            exp += 1
        }
    } else if temp < 1.0 and temp > 0.0 then {
        while temp < 1.0 then {
            temp = temp * 10.0
            exp -= 1
        }
    }

    return if exp < (0 - 4) or exp >= (Int)precision then
        format_scientific(f, is_negative, precision, sign, uppercase)
    else
        format_fixed(f, is_negative, precision, sign, grouping)
}

// ---------------------------------------------------------------------------
// given Float64 { format }
// ---------------------------------------------------------------------------

given Float64 {
    public format(self, spec String) String = {
        let fmt = parse_format_spec(spec)

        let tc = fmt.type_char
        if tc <> 0 and tc <> 'f' and tc <> 'e' and tc <> 'E' and
           tc <> 'g' and tc <> 'G' and tc <> '%' then {
            panic("unsupported format type '" + tc.to_string() + "' for Float64")
        }

        // Special values
        if self.is_nan() then {
            return apply_padding("NaN", fmt)
        }
        let bits = self.to_bits()
        let is_negative = (bits >> 63) == (UInt64)1
        if self.is_inf() then {
            let s = if is_negative then "-Inf"
                    else if fmt.sign == '+' then "+Inf"
                    else "Inf"
            return apply_padding(s, fmt)
        }

        let f = if is_negative then 0.0 - self else self
        let precision = if fmt.precision >= 0 then (UInt)fmt.precision else 6

        // Percentage mode: multiply by 100
        let value = if tc == '%' then f * 100.0 else f

        let result = if tc == 'e' or tc == 'E' then
            format_scientific(value, is_negative, precision, fmt.sign, tc == 'E')
        else if tc == 'f' or tc == '%' then {
            let s = format_fixed(value, is_negative, precision, fmt.sign, fmt.grouping)
            yield if tc == '%' then s + "%" else s
        } else
            format_auto(value, is_negative, precision, fmt.sign, tc == 'G', fmt.grouping)

        return apply_padding(result, fmt)
    }
}

// ---------------------------------------------------------------------------
// given Float32 { format }
// ---------------------------------------------------------------------------

given Float32 {
    public format(self, spec String) String = ((Float64)self).format(spec)
}
