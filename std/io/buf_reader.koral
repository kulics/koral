// ============================================================================
// std.io - BufReader Type
// ============================================================================
// Generic buffered reader that wraps any Reader with an internal fixed buffer.
// Uses compile-time static dispatch (generics, not trait objects).
// ============================================================================

public type [R Reader]BufReader(
    private inner R,
    private buf [UInt8]List,
    private cap UInt,
    private mut start UInt,
    private mut end UInt,
)

given[R Reader] [R]BufReader {
    public new(r R) [R]BufReader = {
        let cap UInt = 4096
        return [R]BufReader(r, make_bytes(cap), cap, 0, 0)
    }

    public with_capacity(r R, cap Int) [R]BufReader = {
        if cap <= 0 then {
            panic("BufReader.with_capacity: non-positive capacity")
        }
        let ucap = (UInt)cap
        return [R]BufReader(r, make_bytes(ucap), ucap, 0, 0)
    }

    private fill_buf(self) [UInt]Result = {
        if self.start < self.end then {
            return [UInt]Result.Ok(self.end - self.start)
        }
        self.start = 0
        self.end = 0
        return when self.inner.read(ref self.buf, 0..<self.cap) in {
            .Ok(n) then {
                self.end = n
                yield [UInt]Result.Ok(n)
            },
            .Error(e) then [UInt]Result.Error(e),
        }
    }

    public read(self, dst [UInt8]List ref, range [UInt]Range) [UInt]Result = {
        let span = range.clamp(0, dst.count())
        let mut out_pos = span.first
        let out_end = span.second
        if out_end <= out_pos then {
            return [UInt]Result.Ok(0)
        }

        let dst_ptr = dst.borrow_mut_ptr()
        let src_ptr = self.buf.borrow_ptr()

        while out_pos < out_end then {
            when self.fill_buf() in {
                .Ok(avail) then {
                    if avail == 0 then {
                        return [UInt]Result.Ok(out_pos - span.first)
                    }
                    let remain_out = out_end - out_pos
                    let take = if avail < remain_out then avail else remain_out
                    copy_memory(dst_ptr + out_pos, src_ptr + self.start, take)
                    self.start += take
                    out_pos += take
                },
                .Error(e) then {
                    return [UInt]Result.Error(e)
                },
            }
        }

        return [UInt]Result.Ok(out_pos - span.first)
    }

    public read_byte(self) [[UInt8]Option]Result = {
        return when self.fill_buf() in {
            .Ok(n) then {
                if n == 0 then {
                    return [[UInt8]Option]Result.Ok([UInt8]Option.None())
                }
                let b = self.buf.at(self.start)
                self.start += 1
                return [[UInt8]Option]Result.Ok([UInt8]Option.Some(b))
            },
            .Error(e) then [[UInt8]Option]Result.Error(e),
        }
    }

    public read_until(self, delim UInt8, dst [UInt8]List ref, range [UInt]Range) [UInt]Result = {
        let span = range.clamp(0, dst.count())
        let mut out_pos = span.first
        let out_end = span.second
        if out_end <= out_pos then {
            return [UInt]Result.Ok(0)
        }

        let dst_ptr = dst.borrow_mut_ptr()
        let src_ptr = self.buf.borrow_ptr()

        while out_pos < out_end then {
            when self.fill_buf() in {
                .Ok(avail) then {
                    if avail == 0 then {
                        return [UInt]Result.Ok(out_pos - span.first)
                    }

                    let mut i UInt = 0
                    let mut found = false
                    let mut take UInt = avail
                    while i < avail then {
                        let b = deptr (src_ptr + self.start + i)
                        if b == delim then {
                            found = true
                            take = i + 1
                            break
                        }
                        i += 1
                    }

                    let remain_out = out_end - out_pos
                    if take > remain_out then {
                        take = remain_out
                    }

                    copy_memory(dst_ptr + out_pos, src_ptr + self.start, take)
                    self.start += take
                    out_pos += take

                    if found then {
                        return [UInt]Result.Ok(out_pos - span.first)
                    }
                },
                .Error(e) then {
                    return [UInt]Result.Error(e)
                },
            }
        }

        return [UInt]Result.Ok(out_pos - span.first)
    }

    public read_line(self) [[String]Option]Result = {
        let mut tmp = make_bytes(4096)
        when self.read_until((UInt8)10, ref tmp, ....) in {
            .Ok(n) then {
                if n == 0 then {
                    return [[String]Option]Result.Ok([String]Option.None())
                }
                let p = tmp.borrow_ptr()
                return [[String]Option]Result.Ok([String]Option.Some(String.from_utf8_ptr(p, n)))
            },
            .Error(e) then {
                return [[String]Option]Result.Error(e)
            },
        }
    }

    public skip(self, n UInt) [UInt]Result = {
        let mut remaining = n
        while remaining > 0 then {
            when self.fill_buf() in {
                .Ok(avail) then {
                    if avail == 0 then {
                        return [UInt]Result.Ok(n - remaining)
                    }
                    let to_skip = if remaining < avail then remaining else avail
                    self.start += to_skip
                    remaining -= to_skip
                },
                .Error(e) then {
                    return [UInt]Result.Error(e)
                },
            }
        }
        return [UInt]Result.Ok(n)
    }
}
