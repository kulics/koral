// ============================================================================
// std.io - BufWriter Type
// ============================================================================
// Generic buffered writer that wraps any Writer with an internal byte list.
// Uses compile-time static dispatch (generics, not trait objects).
// Write strategy: data goes into internal list; auto-flush when list is full.
// ============================================================================

private type [W Writer]BufWriterStorage(inner W, mut buf [UInt8]List, cap UInt)

public type [W Writer]BufWriter(private storage [W]BufWriterStorage ref)

given[W Writer] [W]BufWriter {
    // --- Static constructors ---

    public new(w W) [W]BufWriter =
        [W]BufWriter(ref [W]BufWriterStorage(w, [UInt8]List.with_capacity(4096), 4096))

    public with_capacity(w W, cap Int) [W]BufWriter = {
        if cap <= 0 then {
            panic("BufWriter.with_capacity: negative capacity")
        }
        let ucap = (UInt)cap
        return [W]BufWriter(ref [W]BufWriterStorage(w, [UInt8]List.with_capacity(ucap), ucap))
    }

    // --- Instance methods ---

    public write_byte(self, b UInt8) [Void]Result = {
        if self.storage.buf.count() >= self.storage.cap then {
            let flush_result = self.flush()
            when flush_result in {
                .Ok(_) then {},
                .Error(e) then {
                    return [Void]Result.Error(e)
                },
            }
        }
        self.storage.buf.push(b)
        return [Void]Result.Ok({})
    }

    public write_string(self, s String) [Void]Result = {
        let bytes = s.to_bytes()
        let result = self.write(bytes, ....)
        when result in {
            .Ok(_) then {
                return [Void]Result.Ok({})
            },
            .Error(e) then {
                return [Void]Result.Error(e)
            },
        }
    }

    public write_line(self, s String) [Void]Result = {
        let result = self.write_string(s)
        when result in {
            .Ok(_) then {
                return self.write_byte(10)
            },
            .Error(e) then {
                return [Void]Result.Error(e)
            },
        }
    }

    public write_rune(self, r Rune) [UInt]Result = {
        let cp = r.to_uint32()
        // 1-byte ASCII
        if cp < 128 then {
            let wr = self.write_byte((UInt8)cp)
            when wr in {
                .Ok(_) then {
                    return [UInt]Result.Ok(1)
                },
                .Error(e) then {
                    return [UInt]Result.Error(e)
                },
            }
        }
        // 2-byte
        if cp < 2048 then {
            let r1 = self.write_byte((UInt8)(cp >> 6) | 192)
            when r1 in {
                .Ok(_) then {},
                .Error(e) then {
                    return [UInt]Result.Error(e)
                },
            }
            let r2 = self.write_byte((UInt8)(cp & 63) | 128)
            when r2 in {
                .Ok(_) then {
                    return [UInt]Result.Ok(2)
                },
                .Error(e) then {
                    return [UInt]Result.Error(e)
                },
            }
        }
        // 3-byte
        if cp < 65536 then {
            let r1 = self.write_byte((UInt8)(cp >> 12) | 224)
            when r1 in {
                .Ok(_) then {},
                .Error(e) then {
                    return [UInt]Result.Error(e)
                },
            }
            let r2 = self.write_byte((UInt8)((cp >> 6) & 63) | 128)
            when r2 in {
                .Ok(_) then {},
                .Error(e) then {
                    return [UInt]Result.Error(e)
                },
            }
            let r3 = self.write_byte((UInt8)(cp & 63) | 128)
            when r3 in {
                .Ok(_) then {
                    return [UInt]Result.Ok(3)
                },
                .Error(e) then {
                    return [UInt]Result.Error(e)
                },
            }
        }
        // 4-byte
        let r1 = self.write_byte((UInt8)(cp >> 18) | 240)
        when r1 in {
            .Ok(_) then {},
            .Error(e) then {
                return [UInt]Result.Error(e)
            },
        }
        let r2 = self.write_byte((UInt8)((cp >> 12) & 63) | 128)
        when r2 in {
            .Ok(_) then {},
            .Error(e) then {
                return [UInt]Result.Error(e)
            },
        }
        let r3 = self.write_byte((UInt8)((cp >> 6) & 63) | 128)
        when r3 in {
            .Ok(_) then {},
            .Error(e) then {
                return [UInt]Result.Error(e)
            },
        }
        let r4 = self.write_byte((UInt8)(cp & 63) | 128)
        when r4 in {
            .Ok(_) then {
                return [UInt]Result.Ok(4)
            },
            .Error(e) then {
                return [UInt]Result.Error(e)
            },
        }
    }
}

given[W Writer] [W]BufWriter Writer {
    // Writes data from src[range] into internal buffer. Auto-flushes when full.
    public write(self, src [UInt8]List, range [UInt]Range) [UInt]Result = {
        let span = range.clamp(0, src.count())
        let start = span.first
        let end = span.second
        let available = end - start
        if available == 0 then {
            return [UInt]Result.Ok(0)
        }

        let remaining_cap = self.storage.cap - self.storage.buf.count()
        if available <= remaining_cap then {
            self.storage.buf.push_all(src, start..<end)
            return [UInt]Result.Ok(available)
        }

        if self.storage.buf.count() > 0 then {
            when self.flush() in {
                .Ok(_) then {},
                .Error(e) then {
                    return [UInt]Result.Error(e)
                },
            }
        }

        let new_remaining = self.storage.cap - self.storage.buf.count()
        if available <= new_remaining then {
            self.storage.buf.push_all(src, start..<end)
            return [UInt]Result.Ok(available)
        }

        let direct_result = write_all_bytes(self.storage.inner, src, start..<end)
        when direct_result in {
            .Ok(_) then {
                return [UInt]Result.Ok(available)
            },
            .Error(e) then {
                return [UInt]Result.Error(e)
            },
        }
    }

    // Flushes internal buffer to inner writer. On partial failure, preserves remaining bytes.
    public flush(self) [Void]Result = {
        let total = self.storage.buf.count()
        if total == 0 then {
            return [Void]Result.Ok({})
        }

        let mut start UInt = 0
        while start < total then {
            when self.storage.inner.write(self.storage.buf, start..<total) in {
                .Ok(n) then {
                    if n == 0 then {
                        return [Void]Result.Error(ref IoError.WriteZero())
                    }
                    start += n
                },
                .Error(e) then {
                    if start > 0 then {
                        let remain = self.storage.buf.sublist(start..<total)
                        self.storage.buf.clear()
                        self.storage.buf.push_all(remain, ....)
                    }
                    return [Void]Result.Error(e)
                },
            }
        }

        self.storage.buf.clear()
        return [Void]Result.Ok({})
    }
}

given[W Writer and Seeker] [W]BufWriter Seeker {
    public seek(self, pos SeekPos) [UInt64]Result = {
        when self.flush() in {
            .Ok(_) then {},
            .Error(e) then {
                return [UInt64]Result.Error(e)
            },
        }
        return self.storage.inner.seek(pos)
    }
}
