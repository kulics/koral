// ============================================================================
// std.io - Buffer Type
// ============================================================================
// Byte buffer type â€” the core data carrier for all IO operations.
// Uses raw UInt8 ptr for storage (no List overhead).
// Uses `storage ref` pattern for shared mutable semantics (NOT COW).
// Multiple Buffer values sharing the same storage see each other's mutations.
// ============================================================================

protected type BufferStorage(
    mut data     UInt8 ptr,
    mut length   UInt,
    mut capacity UInt,
    mut read_pos UInt
)

given BufferStorage {
    __drop(self ref) = {
        if self.capacity > 0 then {
            dealloc_memory(self.data)
        }
    }
}

public type Buffer(protected mut storage BufferStorage ref)

// ============================================================================
// Buffer Static Constructors and Instance Methods
// ============================================================================
given Buffer {
    // --- Static constructors ---

    public empty() Buffer = {
        let data = [UInt8]alloc_memory(0)
        let storage = ref BufferStorage(data, 0, 0, 0)
        return Buffer(storage)
    }

    public with_capacity(cap Int) Buffer = {
        if cap < 0 then {
            panic("Buffer.with_capacity: negative capacity")
        }
        let ucap = (UInt)cap
        let data = [UInt8]alloc_memory(ucap)
        let storage = ref BufferStorage(data, 0, ucap, 0)
        return Buffer(storage)
    }

    public from_string(s String) Buffer = {
        let len = s.count()
        let data = [UInt8]alloc_memory(len)
        let mut i UInt = 0
        while i < len then {
            init_memory(data + i, s.at(i))
            i += 1
        }
        let storage = ref BufferStorage(data, len, len, 0)
        return Buffer(storage)
    }

    public from_bytes(bytes [UInt8]List) Buffer = {
        let len = bytes.count()
        let data = [UInt8]alloc_memory(len)
        let mut i UInt = 0
        while i < len then {
            init_memory(data + i, bytes.at(i))
            i += 1
        }
        let storage = ref BufferStorage(data, len, len, 0)
        return Buffer(storage)
    }

    // --- Instance methods ---

    public count(self) UInt = self.storage.length

    public capacity(self) UInt = self.storage.capacity

    public take_byte(self) [UInt8]Option = {
        if self.storage.read_pos >= self.storage.length then {
            return [UInt8]Option.None()
        }
        let b = deptr (self.storage.data + self.storage.read_pos)
        self.storage.read_pos = self.storage.read_pos + 1
        return [UInt8]Option.Some(b)
    }

    public push_byte(self, b UInt8) Void = {
        if self.storage.length >= self.storage.capacity then {
            self.grow(1)
        }
        init_memory(self.storage.data + self.storage.length, b)
        self.storage.length = self.storage.length + 1
    }

    public take_bytes(self) [UInt8]List = {
        let remaining = self.storage.length - self.storage.read_pos
        let mut result = [UInt8]List.with_capacity(remaining)
        let mut i = self.storage.read_pos
        while i < self.storage.length then {
            result.push(deptr (self.storage.data + i))
            i += 1
        }
        self.storage.read_pos = self.storage.length
        return result
    }

    public take_n_bytes(self, n Int) [UInt8]List = {
        let remaining = self.storage.length - self.storage.read_pos
        let take = if n < 0 then 0
            else if (UInt)n > remaining then remaining
            else (UInt)n
        let mut result = [UInt8]List.with_capacity(take)
        let mut i UInt = 0
        while i < take then {
            result.push(deptr (self.storage.data + self.storage.read_pos + i))
            i += 1
        }
        self.storage.read_pos = self.storage.read_pos + take
        return result
    }

    public push_bytes(self, bytes [UInt8]List) Void = {
        let count = bytes.count()
        self.ensure_space(count)
        let mut i UInt = 0
        while i < count then {
            init_memory(self.storage.data + self.storage.length, bytes.at(i))
            self.storage.length = self.storage.length + 1
            i += 1
        }
    }

    public push_n_bytes(self, n Int, bytes [UInt8]List) Void = {
        let count = bytes.count()
        let take = if n < 0 then 0
            else if (UInt)n > count then count
            else (UInt)n
        self.ensure_space(take)
        let mut i UInt = 0
        while i < take then {
            init_memory(self.storage.data + self.storage.length, bytes.at(i))
            self.storage.length = self.storage.length + 1
            i += 1
        }
    }

    public take_string(self) [String]Result = {
        let start = self.storage.read_pos
        let end = self.storage.length
        let len = end - start
        if len == 0 then {
            self.storage.read_pos = end
            return [String]Result.Ok("")
        }
        // Validate UTF-8
        if not self.validate_utf8_range(start, end) then {
            return [String]Result.Error(ref IoError.InvalidUtf8())
        }
        // Build string from validated bytes using pointer arithmetic
        let s = String.from_bytes_unchecked(self.storage.data + start, len)
        self.storage.read_pos = end
        return [String]Result.Ok(s)
    }

    public clear(self) Void = {
        self.storage.length = 0
        self.storage.read_pos = 0
    }

    public reset(self) Void = {
        self.storage.read_pos = 0
    }

    // --- Low-level IO support ---
    // These methods expose the internal read/write positions and raw pointers
    // so that cross-module Reader/Writer implementations (e.g. std.os.File)
    // can perform IO directly into/from the buffer without accessing
    // protected storage fields.

    /// Number of unread bytes (length - read_pos)
    public readable(self) UInt = self.storage.length - self.storage.read_pos

    /// Remaining writable space before reallocation (capacity - length)
    public writable(self) UInt = self.storage.capacity - self.storage.length

    /// Ensure at least `n` bytes of writable space, growing if needed
    public reserve(self, n UInt) Void = self.ensure_space(n)

    /// Raw pointer to the next unread byte (data + read_pos)
    public read_ptr(self) UInt8 ptr = self.storage.data + self.storage.read_pos

    /// Raw pointer to the next writable position (data + length)
    public write_ptr(self) UInt8 ptr = self.storage.data + self.storage.length

    /// Advance the read cursor by `n` bytes (read_pos += n)
    /// Caller must ensure n <= readable()
    public advance_read(self, n UInt) Void = {
        self.storage.read_pos = self.storage.read_pos + n
    }

    /// Advance the write cursor by `n` bytes (length += n)
    /// Caller must ensure n <= writable() (call reserve first)
    public advance_write(self, n UInt) Void = {
        self.storage.length = self.storage.length + n
    }

    // --- Private helpers ---

    protected grow(self, additional UInt) Void = {
        let required = self.storage.length + additional
        let old_cap = self.storage.capacity
        let mut new_cap = if old_cap == 0 then 1 else old_cap
        while new_cap < required then {
            new_cap = new_cap * 2
        }
        let new_data = [UInt8]alloc_memory(new_cap)
        if self.storage.length > 0 then {
            copy_memory(new_data, self.storage.data, self.storage.length)
        }
        if old_cap > 0 then {
            dealloc_memory(self.storage.data)
        }
        self.storage.data = new_data
        self.storage.capacity = new_cap
    }

    protected ensure_space(self, needed UInt) Void = {
        let required = self.storage.length + needed
        if required > self.storage.capacity then {
            self.grow(needed)
        }
    }

    // --- Reader trait implementation ---

    public read(self, buf Buffer) [UInt]Result = {
        let available = self.storage.length - self.storage.read_pos
        if available == 0 then {
            return [UInt]Result.Ok(0)
        }
        buf.ensure_space(available)
        copy_memory(buf.storage.data + buf.storage.length, self.storage.data + self.storage.read_pos, available)
        buf.storage.length = buf.storage.length + available
        self.storage.read_pos = self.storage.read_pos + available
        return [UInt]Result.Ok(available)
    }

    // --- Writer trait implementation ---

    public write(self, buf Buffer) [UInt]Result = {
        let available = buf.storage.length - buf.storage.read_pos
        if available == 0 then {
            return [UInt]Result.Ok(0)
        }
        self.ensure_space(available)
        copy_memory(self.storage.data + self.storage.length, buf.storage.data + buf.storage.read_pos, available)
        self.storage.length = self.storage.length + available
        buf.storage.read_pos = buf.storage.read_pos + available
        return [UInt]Result.Ok(available)
    }

    public flush(self) [Void]Result =
        [Void]Result.Ok({})

    // --- Private UTF-8 validation ---

    private validate_utf8_range(self, start UInt, end UInt) Bool = {
        let mut i = start
        while i < end then {
            let b0 = deptr (self.storage.data + i)
            // 1-byte (ASCII)
            if b0 < 128 then {
                i += 1
                continue
            }
            // Continuation byte as leading byte
            if b0 < 192 then {
                return false
            }
            // 2-byte sequence
            if b0 < 224 then {
                if i + 1 >= end then {
                    return false
                }
                let b1 = deptr (self.storage.data + i + 1)
                if (b1 & 192) <> 128 then {
                    return false
                }
                let cp = ((UInt32)b0 & 31) << 6 | (UInt32)b1 & 63
                if cp < 128 then {
                    return false
                }
                i += 2
                continue
            }
            // 3-byte sequence
            if b0 < 240 then {
                if i + 2 >= end then {
                    return false
                }
                let b1 = deptr (self.storage.data + i + 1)
                let b2 = deptr (self.storage.data + i + 2)
                if (b1 & 192) <> 128 or (b2 & 192) <> 128 then {
                    return false
                }
                let cp = ((UInt32)b0 & 15) << 12 | ((UInt32)b1 & 63) << 6 | (UInt32)b2 & 63
                if cp < 2048 then {
                    return false
                }
                if cp >= 55296 and cp <= 57343 then {
                    return false
                }
                i += 3
                continue
            }
            // 4-byte sequence
            if b0 < 248 then {
                if i + 3 >= end then {
                    return false
                }
                let b1 = deptr (self.storage.data + i + 1)
                let b2 = deptr (self.storage.data + i + 2)
                let b3 = deptr (self.storage.data + i + 3)
                if (b1 & 192) <> 128 or (b2 & 192) <> 128 or (b3 & 192) <> 128 then {
                    return false
                }
                let cp = ((UInt32)b0 & 7) << 18 | ((UInt32)b1 & 63) << 12 | ((UInt32)b2 & 63) << 6 | (UInt32)b3 & 63
                if cp < 65536 or cp > 1114111 then {
                    return false
                }
                i += 4
                continue
            }
            // Invalid leading byte (>= 248)
            return false
        }
        return true
    }
}
