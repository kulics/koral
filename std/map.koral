// ============================================================================
// Koral Standard Library - Map Type
// ============================================================================
// NOTE: This file is merged into core.koral, so all previous types are already available.
// ============================================================================

// ============================================================================
// Map Storage and Type Definition
// ============================================================================
public type [K Hashable, V Any]MapEntry(key K, value V)

public type [K Hashable, V Any]MapBucket {
    Empty(),
    Occupied(entry [K, V]MapEntry),
    Deleted(),
}

protected type [K Hashable, V Any]MapStorage(
    mut buckets [K, V]MapBucket ptr,
    mut count UInt,
    mut capacity UInt,
)

given[K Hashable, V Any] [K, V]MapStorage {
    __drop(self ref) = {
        let mut i UInt = 0
        while i < self.capacity then {
            deinit_memory(self.buckets + i)
            i += 1
        }
        dealloc_memory(self.buckets)
    }
}

public type [K Hashable, V Any]Map(protected mut storage [K, V]MapStorage ref)

public type [K Hashable, V Any]MapIterator(protected storage [K, V]MapStorage ref, mut index UInt)

// ============================================================================
// Map Methods
// ============================================================================
given[K Hashable, V Any] [K, V]Map {
    public new() Self = {
        let capacity UInt = 16
        let buckets = [[K, V]MapBucket]alloc_memory(capacity)
        let mut i UInt = 0
        while i < capacity then {
            init_memory(buckets + i, [K, V]MapBucket.Empty())
            i += 1
        }
        let storage = ref [K, V]MapStorage(buckets, 0, capacity)
        return [K, V]Map(storage)
    }

    public with_capacity(capacity UInt) Self = {
        // Hash tables need extra space for efficiency (load factor ~0.5)
        let cap = if capacity < 4 then 4 else capacity * 2
        let buckets = [[K, V]MapBucket]alloc_memory(cap)
        let mut i UInt = 0
        while i < cap then {
            init_memory(buckets + i, [K, V]MapBucket.Empty())
            i += 1
        }
        let storage = ref [K, V]MapStorage(buckets, 0, cap)
        return [K, V]Map(storage)
    }

    public count(self) UInt = self.storage.count

    private ensure_unique(self ref) Void = {
        if ref_count(self.storage) > 1 then {
            let old = self.storage
            let new_buckets = [[K, V]MapBucket]alloc_memory(old.capacity)
            let mut i UInt = 0
            while i < old.capacity then {
                let bucket = deptr (old.buckets + i)
                init_memory(new_buckets + i, bucket)
                i += 1
            }
            let new_storage = ref [K, V]MapStorage(new_buckets, old.count, old.capacity)
            self.storage = new_storage
        }
    }

    // Using when for bucket handling
    private find_slot(self ref, key K) [UInt]Option = {
        let h = key.hash()
        let mut idx = h % self.storage.capacity
        let mut first_deleted = [UInt]Option.None()
        let mut probes UInt = 0
        while probes < self.storage.capacity then {
            let bucket = deptr (self.storage.buckets + idx)
            when bucket in {
                .Empty then {
                    when first_deleted in {
                        .Some(_) then {
                            return first_deleted
                        },
                        .None then {
                            return [UInt]Option.Some(idx)
                        },
                    }
                },
                .Deleted then {
                    when first_deleted in {
                        .None then {
                            first_deleted = [UInt]Option.Some(idx)
                        },
                        _ then {},
                    }
                },
                .Occupied(e) then {
                    if e.key == key then {
                        return [UInt]Option.Some(idx)
                    }
                },
            }
            idx = (idx + 1) % self.storage.capacity
            probes += 1
        }
        return first_deleted
    }

    private rehash(self ref) Void = {
        let old_cap = self.storage.capacity
        let old_buckets = self.storage.buckets
        let new_cap = old_cap * 2
        let new_buckets = [[K, V]MapBucket]alloc_memory(new_cap)
        let mut i UInt = 0
        while i < new_cap then {
            init_memory(new_buckets + i, [K, V]MapBucket.Empty())
            i += 1
        }
        self.storage.buckets = new_buckets
        self.storage.capacity = new_cap
        self.storage.count = 0
        i = 0
        while i < old_cap then {
            let bucket = take_memory(old_buckets + i)
            when bucket in {
                .Occupied(e) then {
                    self.insert_internal(e.key, e.value);
                },
                _ then {},
            }
            i += 1
        }
        dealloc_memory(old_buckets)
    }

    // Internal insert used by rehash - doesn't return old value
    private insert_internal(self ref, key K, value V) Void = {
        when self.find_slot(key) in {
            .None then {
                panic("Map insert failed");
            },
            .Some(idx) then {
                let bucket = deptr (self.storage.buckets + idx)
                when bucket in {
                    .Occupied(_) then {
                        deptr (self.storage.buckets + idx) = [K, V]MapBucket.Occupied([K, V]MapEntry(key, value))
                    },
                    .Empty or .Deleted then {
                        deptr (self.storage.buckets + idx) = [K, V]MapBucket.Occupied([K, V]MapEntry(key, value))
                        self.storage.count = self.storage.count + 1
                    },
                }
            },
        }
    }

    // Returns None if key was new, Some(old_value) if overwritten
    public insert(self ref, key K, value V) [V]Option = {
        self.ensure_unique()
        if self.storage.count * 2 >= self.storage.capacity then {
            self.rehash();
        }
        when self.find_slot(key) in {
            .None then {
                panic("Map insert failed");
                return [V]Option.None()
            },
            .Some(idx) then {
                let bucket = deptr (self.storage.buckets + idx)
                when bucket in {
                    .Occupied(e) then {
                        deptr (self.storage.buckets + idx) = [K, V]MapBucket.Occupied([K, V]MapEntry(key, value))
                        return [V]Option.Some(e.value)
                    },
                    .Empty or .Deleted then {
                        deptr (self.storage.buckets + idx) = [K, V]MapBucket.Occupied([K, V]MapEntry(key, value))
                        self.storage.count = self.storage.count + 1
                        return [V]Option.None()
                    },
                }
            },
        }
    }

    public insert_all(self ref, other [K, V]Map) Void = {
        let mut it = other.iterator()
        while it.next() is .Some(entry) then {
            self.insert(entry.key, entry.value);
        }
    }

    public get(self, key K) [V]Option = {
        when self.find_slot(key) in {
            .None then {
                return [V]Option.None()
            },
            .Some(idx) then {
                let bucket = deptr (self.storage.buckets + idx)
                when bucket in {
                    .Occupied(e) then {
                        return [V]Option.Some(e.value)
                    },
                    _ then {
                        return [V]Option.None()
                    },
                }
            },
        }
    }

    public at(self, key K) V = {
        when self.find_slot(key) in {
            .None then {
                return panic("Map key not found")
            },
            .Some(idx) then {
                let bucket = deptr (self.storage.buckets + idx)
                when bucket in {
                    .Occupied(e) then {
                        return e.value
                    },
                    _ then {
                        return panic("Map key not found")
                    },
                }
            },
        }
    }

    public contains_key(self, key K) Bool = when self.get(key) in {
        .Some(_) then true,
        .None then false,
    }

    public remove(self ref, key K) [V]Option = {
        self.ensure_unique()
        when self.find_slot(key) in {
            .None then {
                return [V]Option.None()
            },
            .Some(idx) then {
                let bucket = deptr (self.storage.buckets + idx)
                when bucket in {
                    .Occupied(e) then {
                        deptr (self.storage.buckets + idx) = [K, V]MapBucket.Deleted()
                        self.storage.count = self.storage.count - 1
                        return [V]Option.Some(e.value)
                    },
                    _ then {
                        return [V]Option.None()
                    },
                }
            },
        }
    }

    public is_empty(self) Bool = self.storage.count == 0

    public clear(self ref) Void = {
        self.ensure_unique()
        let mut i UInt = 0
        while i < self.storage.capacity then {
            deptr (self.storage.buckets + i) = [K, V]MapBucket.Empty()
            i += 1
        }
        self.storage.count = 0
    }

    public iterator(self) [K, V]MapIterator = [K, V]MapIterator(self.storage, 0)
}

// ============================================================================
// Map Iterator
// ============================================================================
given[K Hashable, V Any] [K, V]MapIterator {
    public next(self ref) [[K, V]MapEntry]Option = {
        while self.index < self.storage.capacity then {
            let bucket = deptr (self.storage.buckets + self.index)
            self.index = self.index + 1
            when bucket in {
                .Occupied(e) then {
                    return [[K, V]MapEntry]Option.Some(e)
                },
                _ then {},
            }
        }
        return [[K, V]MapEntry]Option.None()
    }
}

// ============================================================================
// Map ToString Implementation
// ============================================================================
given[K ToString and Hashable, V ToString] [K, V]Map {
    public to_string(self) String = {
        let mut result = String.zero()
        result.push_string("[")
        let mut first = true
        let mut i UInt = 0
        while i < self.storage.capacity then {
            let bucket = deptr (self.storage.buckets + i)
            when bucket in {
                .Occupied(entry) then {
                    if not first then {
                        result.push_string(", ");
                    }
                    first = false
                    result.push_string(entry.key.to_string())
                    result.push_string(": ")
                    result.push_string(entry.value.to_string())
                },
                _ then {},
            }
            i += 1
        }
        result.push_string("]")
        return result
    }
}

// ============================================================================
// Map Keys and Values Types with Iterators
// ============================================================================

// MapKeysIterator - iterates over keys only
public type [K Hashable, V Any]MapKeysIterator(
    storage [K, V]MapStorage ref,
    mut index UInt,
)

given[K Hashable, V Any] [K, V]MapKeysIterator {
    public next(self ref) [K]Option = {
        while self.index < self.storage.capacity then {
            let bucket = deptr (self.storage.buckets + self.index)
            self.index = self.index + 1
            when bucket in {
                .Occupied(e) then {
                    return [K]Option.Some(e.key)
                },
                _ then {},
            }
        }
        return [K]Option.None()
    }
}

// MapValuesIterator - iterates over values only
public type [K Hashable, V Any]MapValuesIterator(
    storage [K, V]MapStorage ref,
    mut index UInt,
)

given[K Hashable, V Any] [K, V]MapValuesIterator {
    public next(self ref) [V]Option = {
        while self.index < self.storage.capacity then {
            let bucket = deptr (self.storage.buckets + self.index)
            self.index = self.index + 1
            when bucket in {
                .Occupied(e) then {
                    return [V]Option.Some(e.value)
                },
                _ then {},
            }
        }
        return [V]Option.None()
    }
}

// Add keys() and values() methods to Map
given[K Hashable, V Any] [K, V]Map {
    public keys(self) [K, V]MapKeysIterator = [K, V]MapKeysIterator(self.storage, 0)
    public values(self) [K, V]MapValuesIterator = [K, V]MapValuesIterator(self.storage, 0)
}
