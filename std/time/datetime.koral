// ============================================================================
// DateTime — Calendar date/time with timezone
// ============================================================================

using super.Duration
using super.String
using super.Option

// FFI Declaration
foreign let koral_wallclock_now(out_secs Int64 ptr, out_nanos Int64 ptr) Void

// ============================================================================
// Gregorian Calendar Algorithms (private, pure Koral)
// Reference: Howard Hinnant's date algorithms
// https://howardhinnant.github.io/date_algorithms.html
// ============================================================================

/// Private helper type for returning (year, month, day) from calendar functions.
type CivilDate(year Int, month Int, day Int)

/// Floor division: rounds toward negative infinity.
let floor_div(a Int64, b Int64) Int64 = {
    let q = a / b
    let r = a - q * b
    if r <> 0 and ((a ^ b) < 0) then {
        q - 1
    } else {
        q
    }
}

/// Convert Unix day count (days since 1970-01-01) to (year, month, day).
let civil_from_days(z Int64) CivilDate = {
    let shifted = z + 719468
    let era = floor_div(shifted, 146097)
    let doe = shifted - era * 146097
    let yoe = (doe - doe / 1460 + doe / 36524 - doe / 146096) / 365
    let y = yoe + era * 400
    let doy = doe - (365 * yoe + yoe / 4 - yoe / 100)
    let mp = (5 * doy + 2) / 153
    let d = doy - (153 * mp + 2) / 5 + 1
    let m = if mp < 10 then mp + 3 else mp - 9
    let yr = if m <= 2 then y + 1 else y
    CivilDate((Int)yr, (Int)m, (Int)d)
}

/// Convert (year, month, day) to Unix day count (days since 1970-01-01).
let days_from_civil(y Int, m Int, d Int) Int64 = {
    let yr = (Int64)(if m <= 2 then y - 1 else y)
    let era = floor_div(yr, 400)
    let yoe = yr - era * 400
    let doy = (153 * (Int64)(if m > 2 then m - 3 else m + 9) + 2) / 5 + (Int64)d - 1
    let doe = yoe * 365 + yoe / 4 - yoe / 100 + doy
    era * 146097 + doe - 719468
}

/// Returns true if the given year is a leap year in the Gregorian calendar.
let is_leap_year(y Int) Bool = {
    y % 4 == 0 and (y % 100 <> 0 or y % 400 == 0)
}

/// Returns the number of days in the given month of the given year.
let days_in_month(y Int, m Int) Int = {
    if m == 2 then {
        if is_leap_year(y) then 29 else 28
    } else if m == 4 or m == 6 or m == 9 or m == 11 then {
        30
    } else {
        31
    }
}

// ============================================================================
// DateTime Type
// ============================================================================

/// DateTime represents a calendar date and time with timezone information.
/// Internal storage is UTC unix seconds + nanoseconds + timezone.
public type DateTime(private unix_secs Int64, private nanos Int32, private tz TimeZone)


// ============================================================================
// TimeZone Instance Methods (depend on DateTime, so placed here)
// ============================================================================

given TimeZone {
    /// Returns the timezone name.
    public name(self) String = {
        when self.kind is {
            .Utc() then "UTC",
            .Local(n) then n,
            .Named(n) then n,
            .Fixed(offset_secs) then {
                let abs_secs = if offset_secs < 0 then 0 - (Int)offset_secs else (Int)offset_secs
                let hours = abs_secs / 3600
                let mins = (abs_secs % 3600) / 60
                let mut result = String.zero()
                if offset_secs < 0 then {
                    result.push('-')
                } else {
                    result.push('+')
                }
                if hours < 10 then { result.push('0') }
                result.push_int(hours)
                result.push(':')
                if mins < 10 then { result.push('0') }
                result.push_int(mins)
                result
            },
        }
    }

    /// Returns the UTC offset at the given DateTime as a Duration.
    public offset_at(self, dt DateTime) Duration = {
        when self.kind is {
            .Utc() then Duration.zero(),
            .Fixed(offset_secs) then Duration.from_secs((Int)offset_secs),
            .Local(n) then {
                let mut out Int32 = 0
                koral_timezone_offset_at(n.storage.data, dt.unix_secs, ptr out)
                Duration.from_secs((Int)out)
            },
            .Named(n) then {
                let mut out Int32 = 0
                koral_timezone_offset_at(n.storage.data, dt.unix_secs, ptr out)
                Duration.from_secs((Int)out)
            },
        }
    }

    /// Eq: equals
    public equals(self, other TimeZone) Bool = {
        when self.kind is {
            .Utc() then when other.kind is {
                .Utc() then true,
                _ then false,
            },
            .Fixed(a) then when other.kind is {
                .Fixed(b) then a == b,
                _ then false,
            },
            .Named(a) then when other.kind is {
                .Named(b) then a == b,
                _ then false,
            },
            .Local(a) then when other.kind is {
                .Local(b) then a == b,
                _ then false,
            },
        }
    }
}

// ============================================================================
// DateTime Static Constructors
// ============================================================================

given DateTime {
    /// Returns the current local time.
    public now() DateTime = {
        let mut s Int64 = 0
        let mut n Int64 = 0
        koral_wallclock_now(ptr s, ptr n)
        DateTime(s, (Int32)n, TimeZone.local())
    }

    /// Returns the current UTC time.
    public now_utc() DateTime = {
        let mut s Int64 = 0
        let mut n Int64 = 0
        koral_wallclock_now(ptr s, ptr n)
        DateTime(s, (Int32)n, TimeZone.utc())
    }

    /// Returns the Unix epoch (1970-01-01T00:00:00Z).
    public epoch() DateTime = DateTime(0, 0, TimeZone.utc())

    /// Creates a UTC DateTime from a Duration since the Unix epoch.
    public from_unix_timestamp(ts Duration) DateTime = {
        DateTime(ts.secs, (Int32)ts.nanos, TimeZone.utc())
    }

    /// Creates a UTC DateTime from seconds since the Unix epoch.
    public from_unix_secs(secs Int64) DateTime = DateTime(secs, 0, TimeZone.utc())

    /// Creates a DateTime from calendar components.
    /// Returns None if any field is out of range.
    public from_components(year Int, month Int, day Int, hour Int, minute Int, second Int, nanos Int, tz TimeZone) [DateTime]Option = {
        // Validate ranges
        if month < 1 or month > 12 then { return [DateTime]Option.None() }
        if day < 1 or day > days_in_month(year, month) then { return [DateTime]Option.None() }
        if hour < 0 or hour > 23 then { return [DateTime]Option.None() }
        if minute < 0 or minute > 59 then { return [DateTime]Option.None() }
        if second < 0 or second > 59 then { return [DateTime]Option.None() }
        if nanos < 0 or nanos > 999_999_999 then { return [DateTime]Option.None() }

        // Convert to unix seconds (in the given timezone)
        let day_count = days_from_civil(year, month, day)
        let local_secs = day_count * 86400 + (Int64)hour * 3600 + (Int64)minute * 60 + (Int64)second

        // Create a temporary DateTime to query the timezone offset
        let temp = DateTime(local_secs, (Int32)nanos, tz)
        let offset = tz.offset_at(temp)
        let unix_secs = local_secs - offset.secs

        [DateTime]Option.Some(DateTime(unix_secs, (Int32)nanos, tz))
    }
}


// ============================================================================
// DateTime Field Access Methods
// ============================================================================

given DateTime {
    /// Returns the year.
    public year(self) Int = {
        let offset = self.tz.offset_at(self)
        let local_secs = self.unix_secs + offset.secs
        let days = floor_div(local_secs, 86400)
        let civil = civil_from_days(days)
        civil.year
    }

    /// Returns the month (1-12).
    public month(self) Int = {
        let offset = self.tz.offset_at(self)
        let local_secs = self.unix_secs + offset.secs
        let days = floor_div(local_secs, 86400)
        let civil = civil_from_days(days)
        civil.month
    }

    /// Returns the day of month (1-31).
    public day(self) Int = {
        let offset = self.tz.offset_at(self)
        let local_secs = self.unix_secs + offset.secs
        let days = floor_div(local_secs, 86400)
        let civil = civil_from_days(days)
        civil.day
    }

    /// Returns the hour (0-23).
    public hour(self) Int = {
        let offset = self.tz.offset_at(self)
        let local_secs = self.unix_secs + offset.secs
        let day_secs = local_secs - floor_div(local_secs, 86400) * 86400
        (Int)(day_secs / 3600)
    }

    /// Returns the minute (0-59).
    public minute(self) Int = {
        let offset = self.tz.offset_at(self)
        let local_secs = self.unix_secs + offset.secs
        let day_secs = local_secs - floor_div(local_secs, 86400) * 86400
        (Int)((day_secs % 3600) / 60)
    }

    /// Returns the second (0-59).
    public second(self) Int = {
        let offset = self.tz.offset_at(self)
        let local_secs = self.unix_secs + offset.secs
        let day_secs = local_secs - floor_div(local_secs, 86400) * 86400
        (Int)(day_secs % 60)
    }

    /// Returns the nanosecond (0-999_999_999).
    public nanosecond(self) Int = (Int)self.nanos

    /// Returns the associated timezone.
    public timezone(self) TimeZone = self.tz
}

// ============================================================================
// DateTime Conversion Methods
// ============================================================================

given DateTime {
    /// Returns the Duration since the Unix epoch.
    public to_unix_timestamp(self) Duration = Duration(self.unix_secs, (Int64)self.nanos)

    /// Returns the seconds since the Unix epoch.
    public to_unix_secs(self) Int64 = self.unix_secs

    /// Converts to the given timezone (same instant, different display).
    public in_timezone(self, tz TimeZone) DateTime = DateTime(self.unix_secs, self.nanos, tz)

    /// Converts to UTC.
    public in_utc(self) DateTime = DateTime(self.unix_secs, self.nanos, TimeZone.utc())

    /// Converts to local timezone.
    public in_local(self) DateTime = DateTime(self.unix_secs, self.nanos, TimeZone.local())
}

// ============================================================================
// DateTime Affine, Eq, Ord Traits
// ============================================================================

given DateTime {
    /// [Duration]Affine: add_vector — DateTime + Duration
    public add_vector(self, v Duration) DateTime = {
        let mut new_nanos = (Int64)self.nanos + v.nanos
        let mut new_secs = self.unix_secs + v.secs
        if new_nanos >= 1_000_000_000 then {
            new_secs = new_secs + new_nanos / 1_000_000_000
            new_nanos = new_nanos % 1_000_000_000
        } else if new_nanos < 0 then {
            let borrow = (0 - new_nanos + 999_999_999) / 1_000_000_000
            new_secs = new_secs - borrow
            new_nanos = new_nanos + borrow * 1_000_000_000
        }
        DateTime(new_secs, (Int32)new_nanos, self.tz)
    }

    /// [Duration]Affine: sub_vector — DateTime - Duration
    public sub_vector(self, v Duration) DateTime = {
        let mut new_nanos = (Int64)self.nanos - v.nanos
        let mut new_secs = self.unix_secs - v.secs
        if new_nanos < 0 then {
            let borrow = (0 - new_nanos + 999_999_999) / 1_000_000_000
            new_secs = new_secs - borrow
            new_nanos = new_nanos + borrow * 1_000_000_000
        } else if new_nanos >= 1_000_000_000 then {
            new_secs = new_secs + new_nanos / 1_000_000_000
            new_nanos = new_nanos % 1_000_000_000
        }
        DateTime(new_secs, (Int32)new_nanos, self.tz)
    }

    /// [Duration]Affine: sub_point — DateTime - DateTime
    public sub_point(self, other DateTime) Duration = {
        let mut diff_nanos = (Int64)self.nanos - (Int64)other.nanos
        let mut diff_secs = self.unix_secs - other.unix_secs
        if diff_nanos < 0 then {
            diff_secs = diff_secs - 1
            diff_nanos = diff_nanos + 1_000_000_000
        }
        Duration(diff_secs, diff_nanos)
    }

    /// Eq: equals — based on unix_secs + nanos (timezone-independent)
    public equals(self, other DateTime) Bool = {
        self.unix_secs == other.unix_secs and self.nanos == other.nanos
    }

    /// Ord: compare — based on unix_secs + nanos (timezone-independent)
    public compare(self, other DateTime) Int = {
        if self.unix_secs < other.unix_secs then {
            -1
        } else if self.unix_secs > other.unix_secs then {
            1
        } else if self.nanos < other.nanos then {
            -1
        } else if self.nanos > other.nanos then {
            1
        } else {
            0
        }
    }
}


// ============================================================================
// DateTime ISO 8601 Formatting and Parsing
// ============================================================================

/// Helper: push a zero-padded integer of given width to a string.
let push_padded(s String ref, value Int, width Int) Void = {
    if width >= 4 and value < 1000 then { s.push('0') }
    if width >= 3 and value < 100 then { s.push('0') }
    if width >= 2 and value < 10 then { s.push('0') }
    s.push_int(value)
}

given DateTime {
    /// Formats as ISO 8601 string.
    /// UTC: "2024-01-15T10:30:00Z"
    /// Fixed offset: "2024-01-15T10:30:00+08:00"
    /// With nanos: "2024-01-15T10:30:00.123456789Z"
    public to_iso8601(self) String = {
        let mut result = String.zero()

        // Date part
        push_padded(ref result, self.year(), 4)
        result.push('-')
        push_padded(ref result, self.month(), 2)
        result.push('-')
        push_padded(ref result, self.day(), 2)
        result.push('T')

        // Time part
        push_padded(ref result, self.hour(), 2)
        result.push(':')
        push_padded(ref result, self.minute(), 2)
        result.push(':')
        push_padded(ref result, self.second(), 2)

        // Fractional seconds (if non-zero, trim trailing zeros)
        let ns = self.nanosecond()
        if ns > 0 then {
            result.push('.')
            // Write up to 9 digits, then trim trailing zeros
            let mut digits = ns
            let mut count = 9
            // Remove trailing zeros
            while digits % 10 == 0 and count > 0 then {
                digits = digits / 10
                count = count - 1
            }
            // Pad leading zeros
            if count >= 2 and digits < 10 then { result.push('0') }
            if count >= 3 and digits < 100 then { result.push('0') }
            if count >= 4 and digits < 1000 then { result.push('0') }
            if count >= 5 and digits < 10000 then { result.push('0') }
            if count >= 6 and digits < 100000 then { result.push('0') }
            if count >= 7 and digits < 1000000 then { result.push('0') }
            if count >= 8 and digits < 10000000 then { result.push('0') }
            if count >= 9 and digits < 100000000 then { result.push('0') }
            result.push_int(digits)
        }

        // Timezone suffix
        let offset = self.tz.offset_at(self)
        let offset_secs = (Int)offset.secs
        if offset_secs == 0 and offset.nanos == 0 then {
            result.push('Z')
        } else {
            let abs_offset = if offset_secs < 0 then 0 - offset_secs else offset_secs
            if offset_secs < 0 then {
                result.push('-')
            } else {
                result.push('+')
            }
            let oh = abs_offset / 3600
            let om = (abs_offset % 3600) / 60
            push_padded(ref result, oh, 2)
            result.push(':')
            push_padded(ref result, om, 2)
        }

        result
    }
}

/// Helper: parse exactly `count` digits from string at position `pos`.
/// Returns the parsed integer and new position, or -1 if parsing fails.
type ParseResult(value Int, pos Int)

let parse_digits(s String, pos Int, count Int) ParseResult = {
    let len = (Int)s.count()
    if pos + count > len then {
        return ParseResult(-1, pos)
    }
    let mut value = 0
    let mut i = 0
    while i < count then {
        let c = s.at((UInt)(pos + i))
        if c < (UInt8)48 or c > (UInt8)57 then {
            return ParseResult(-1, pos)
        }
        value = value * 10 + (Int)(c - (UInt8)48)
        i = i + 1
    }
    ParseResult(value, pos + count)
}

/// Helper: parse variable-length digits (1-9) for fractional seconds.
let parse_frac_digits(s String, pos Int) ParseResult = {
    let len = (Int)s.count()
    let mut value = 0
    let mut i = 0
    let mut digit_count = 0
    while pos + i < len and digit_count < 9 then {
        let c = s.at((UInt)(pos + i))
        if c < (UInt8)48 or c > (UInt8)57 then {
            // stop at non-digit
            if digit_count == 0 then { return ParseResult(-1, pos) }
            // pad to 9 digits
            let mut v = value
            let mut d = digit_count
            while d < 9 then {
                v = v * 10
                d = d + 1
            }
            return ParseResult(v, pos + i)
        }
        value = value * 10 + (Int)(c - (UInt8)48)
        digit_count = digit_count + 1
        i = i + 1
    }
    if digit_count == 0 then { return ParseResult(-1, pos) }
    let mut v = value
    let mut d = digit_count
    while d < 9 then {
        v = v * 10
        d = d + 1
    }
    ParseResult(v, pos + i)
}

given DateTime {
    /// Parses an ISO 8601 string into a DateTime.
    /// Supports: "2024-01-15T10:30:00Z", "2024-01-15T10:30:00+08:00",
    ///           "2024-01-15T10:30:00.123456789Z"
    /// Returns None if the string does not match.
    public parse_iso8601(s String) [DateTime]Option = {
        let len = (Int)s.count()
        // Minimum: "YYYY-MM-DDTHH:MM:SSZ" = 20 chars
        if len < 20 then { return [DateTime]Option.None() }

        // Parse date: YYYY-MM-DD
        let yr = parse_digits(s, 0, 4)
        if yr.value < 0 then { return [DateTime]Option.None() }
        if s.at(4) <> (UInt8)45 then { return [DateTime]Option.None() } // '-'
        let mo = parse_digits(s, 5, 2)
        if mo.value < 0 then { return [DateTime]Option.None() }
        if s.at(7) <> (UInt8)45 then { return [DateTime]Option.None() } // '-'
        let dy = parse_digits(s, 8, 2)
        if dy.value < 0 then { return [DateTime]Option.None() }

        // 'T' separator
        if s.at(10) <> (UInt8)84 then { return [DateTime]Option.None() } // 'T'

        // Parse time: HH:MM:SS
        let hr = parse_digits(s, 11, 2)
        if hr.value < 0 then { return [DateTime]Option.None() }
        if s.at(13) <> (UInt8)58 then { return [DateTime]Option.None() } // ':'
        let mi = parse_digits(s, 14, 2)
        if mi.value < 0 then { return [DateTime]Option.None() }
        if s.at(16) <> (UInt8)58 then { return [DateTime]Option.None() } // ':'
        let se = parse_digits(s, 17, 2)
        if se.value < 0 then { return [DateTime]Option.None() }

        let mut pos = 19
        let mut nanos = 0

        // Optional fractional seconds
        if pos < len and s.at((UInt)pos) == (UInt8)46 then { // '.'
            pos = pos + 1
            let frac = parse_frac_digits(s, pos)
            if frac.value < 0 then { return [DateTime]Option.None() }
            nanos = frac.value
            pos = frac.pos
        }

        // Timezone: 'Z' or '+HH:MM' or '-HH:MM'
        if pos >= len then { return [DateTime]Option.None() }
        let tz_char = s.at((UInt)pos)

        let tz = if tz_char == (UInt8)90 then { // 'Z'
            pos = pos + 1
            TimeZone.utc()
        } else if tz_char == (UInt8)43 or tz_char == (UInt8)45 then { // '+' or '-'
            let sign = if tz_char == (UInt8)45 then -1 else 1
            pos = pos + 1
            let oh = parse_digits(s, pos, 2)
            if oh.value < 0 then { return [DateTime]Option.None() }
            pos = pos + 2
            if pos >= len or s.at((UInt)pos) <> (UInt8)58 then { return [DateTime]Option.None() } // ':'
            pos = pos + 1
            let om = parse_digits(s, pos, 2)
            if om.value < 0 then { return [DateTime]Option.None() }
            pos = pos + 2
            let offset_secs = sign * (oh.value * 3600 + om.value * 60)
            let tz_result = TimeZone.from_offset(Duration.from_secs(offset_secs))
            when tz_result is {
                .Ok(t) then t,
                .Error(_) then { return [DateTime]Option.None() },
            }
        } else {
            return [DateTime]Option.None()
        }

        // Must have consumed entire string
        if pos <> len then { return [DateTime]Option.None() }

        // Build DateTime via from_components
        DateTime.from_components(yr.value, mo.value, dy.value, hr.value, mi.value, se.value, nanos, tz)
    }
}
