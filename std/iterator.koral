// ============================================================================
// Koral Standard Library - Iterator API
// ============================================================================
// Provides lazy, chainable operations on iterators similar to Java Streams.
// ============================================================================

// Generic Iterator trait for for-loop support
public trait [T Any]Iterator {
    next(self ref) [T]Option
}

// Iterable trait - types that can produce an iterator
public trait [T Any, R [T]Iterator]Iterable {
    iterator(self) R
}

// ============================================================================
// Intermediate Iterator Types
// ============================================================================

// FilterIterator - filters elements based on predicate
public type [T Any, R [T]Iterator]FilterIterator(
    mut iter R,
    predicate [T, Bool]Func,
)

given[T Any, R [T]Iterator] [T, R]FilterIterator [T]Iterator {
    public next(self ref) [T]Option = {
        while self.iter.next() is .Some(v) then {
            if self.predicate(v) then {
                return [T]Option.Some(v)
            }
        }
        return [T]Option.None()
    }
}

// MappedIterator - transforms elements using mapper function
public type [T Any, U Any, R [T]Iterator]MappedIterator(mut iter R, mapper [T, U]Func)

given[T Any, U Any, R [T]Iterator] [T, U, R]MappedIterator [U]Iterator {
    public next(self ref) [U]Option = self.iter.next() and then self.mapper(_)
}

// FilterMapIterator - filters and transforms in one operation
public type [T Any, U Any, R [T]Iterator]FilterMapIterator(
    mut iter R,
    mapper [T, [U]Option]Func,
)

given[T Any, U Any, R [T]Iterator] [T, U, R]FilterMapIterator [U]Iterator {
    public next(self ref) [U]Option = {
        while self.iter.next() is .Some(v) then {
            when self.mapper(v) in {
                .Some(u) then {
                    return [U]Option.Some(u)
                },
                .None then {},
            }
        }
        return [U]Option.None()
    }
}

// TakeIterator - takes first n elements
public type [T Any, R [T]Iterator]TakeIterator(mut iter R, mut remaining UInt)

given[T Any, R [T]Iterator] [T, R]TakeIterator [T]Iterator {
    public next(self ref) [T]Option = {
        if self.remaining == 0 then {
            return [T]Option.None()
        }
        self.remaining -= 1
        return self.iter.next()
    }
}

// SkipIterator - skips first n elements
public type [T Any, R [T]Iterator]SkipIterator(mut iter R, mut to_skip UInt)

given[T Any, R [T]Iterator] [T, R]SkipIterator [T]Iterator {
    public next(self ref) [T]Option = {
        while self.to_skip > 0 then {
            self.iter.next() or else {
                return [T]Option.None()
            }
            self.to_skip -= 1
        }
        return self.iter.next()
    }
}

// StepIterator - takes every nth element
public type [T Any, R [T]Iterator]StepIterator(
    mut iter R,
    step_size UInt,
    mut first Bool,
)

given[T Any, R [T]Iterator] [T, R]StepIterator [T]Iterator {
    public next(self ref) [T]Option = {
        if self.first then {
            self.first = false
            return self.iter.next()
        }
        // Skip step_size - 1 elements
        let mut i UInt = 1
        while i < self.step_size then {
            self.iter.next() or else {
                return [T]Option.None()
            }
            i += 1
        }
        return self.iter.next()
    }
}

// EnumerateIterator - pairs each element with its index
public type [T Any, R [T]Iterator]EnumerateIterator(mut iter R, mut index UInt)

given[T Any, R [T]Iterator] [T, R]EnumerateIterator [[UInt, T]Pair]Iterator {
    public next(self ref) [[UInt, T]Pair]Option = {
        return self.iter.next() and then {
            let idx = self.index
            self.index += 1
            yield [UInt, T]Pair(idx, _)
        }
    }
}

// PeekIterator - executes side effect without modifying elements
public type [T Any, R [T]Iterator]PeekIterator(mut iter R, action [T, Void]Func)

given[T Any, R [T]Iterator] [T, R]PeekIterator [T]Iterator {
    public next(self ref) [T]Option = {
        return self.iter.next() and then {
            self.action(_);
            yield _
        }
    }
}

// IntersperseIterator - inserts separator between elements
public type [T Any, R [T]Iterator]IntersperseIterator(
    mut iter R,
    separator T,
    mut next_is_separator Bool,
    mut pending [T]Option,
)

given[T Any, R [T]Iterator] [T, R]IntersperseIterator [T]Iterator {
    public next(self ref) [T]Option = {
        // If we need to return separator
        if self.next_is_separator then {
            when self.pending in {
                .Some(_) then {
                    self.next_is_separator = false
                    return [T]Option.Some(self.separator)
                },
                .None then {},
            }
        }
        // Return pending value
        when self.pending in {
            .Some(v) then {
                self.pending = [T]Option.None()
                // Prefetch next element
                when self.iter.next() in {
                    .Some(next_v) then {
                        self.pending = [T]Option.Some(next_v)
                        self.next_is_separator = true
                    },
                    .None then {},
                }
                return [T]Option.Some(v)
            },
            .None then {
                // First call, get first element
                when self.iter.next() in {
                    .Some(v) then {
                        // Prefetch next
                        when self.iter.next() in {
                            .Some(next_v) then {
                                self.pending = [T]Option.Some(next_v)
                                self.next_is_separator = true
                            },
                            .None then {},
                        }
                        return [T]Option.Some(v)
                    },
                    .None then {
                        return [T]Option.None()
                    },
                }
            },
        }
    }
}

// TakeWhileIterator - takes elements while predicate is true
public type [T Any, R [T]Iterator]TakeWhileIterator(
    mut iter R,
    predicate [T, Bool]Func,
    mut done Bool,
)

given[T Any, R [T]Iterator] [T, R]TakeWhileIterator [T]Iterator {
    public next(self ref) [T]Option = {
        if self.done then {
            return [T]Option.None()
        }
        when self.iter.next() in {
            .Some(v) then {
                if self.predicate(v) then {
                    return [T]Option.Some(v)
                } else {
                    self.done = true
                    return [T]Option.None()
                }
            },
            .None then {
                return [T]Option.None()
            },
        }
    }
}

// SkipWhileIterator - skips elements while predicate is true
public type [T Any, R [T]Iterator]SkipWhileIterator(
    mut iter R,
    predicate [T, Bool]Func,
    mut skipping Bool,
)

given[T Any, R [T]Iterator] [T, R]SkipWhileIterator [T]Iterator {
    public next(self ref) [T]Option = {
        if not self.skipping then {
            return self.iter.next()
        }
        while self.iter.next() is .Some(v) then {
            if not self.predicate(v) then {
                self.skipping = false
                return [T]Option.Some(v)
            }
        }
        return [T]Option.None()
    }
}

// ChainIterator - chains two iterators of the same element type
public type [T Any, R1 [T]Iterator, R2 [T]Iterator]ChainIterator(
    mut first R1,
    mut second R2,
    mut use_second Bool,
)

given[T Any, R1 [T]Iterator, R2 [T]Iterator] [T, R1, R2]ChainIterator [T]Iterator {
    public next(self ref) [T]Option = {
        if not self.use_second then {
            when self.first.next() in {
                .Some(v) then {
                    return [T]Option.Some(v)
                },
                .None then {
                    self.use_second = true
                },
            }
        }
        return self.second.next()
    }
}

// ZipIterator - zips two iterators into pairs
public type [A Any, B Any, R1 [A]Iterator, R2 [B]Iterator]ZipIterator(
    mut first R1,
    mut second R2,
)

given[A Any, B Any, R1 [A]Iterator, R2 [B]Iterator] [A, B, R1, R2]ZipIterator [[A, B]Pair]Iterator {
    public next(self ref) [[A, B]Pair]Option = {
        return self.first.next() and then {
            let a = _
            yield self.second.next() and then [A, B]Pair(a, _)
        }
    }
}

// FlatMapIterator - flattens nested iterators (fully lazy)
public type [T Any, U Any, R [T]Iterator, InnerR [U]Iterator]FlatMapIterator(
    mut outer R,
    mapper [T, InnerR]Func,
    mut current_inner [InnerR]Option,
)

given[T Any, U Any, R [T]Iterator, InnerR [U]Iterator] [T, U, R, InnerR]FlatMapIterator [U]Iterator {
    public next(self ref) [U]Option = {
        while true then {
            when self.current_inner in {
                .Some(inner) then {
                    // Copy out the inner iterator
                    let mut inner_copy = inner
                    when inner_copy.next() in {
                        .Some(v) then {
                            // Write modified iterator back
                            self.current_inner = [InnerR]Option.Some(inner_copy)
                            return [U]Option.Some(v)
                        },
                        .None then {
                            // Inner exhausted, clear it
                            self.current_inner = [InnerR]Option.None()
                        },
                    }
                },
                .None then {
                    // Get next from outer iterator
                    when self.outer.next() in {
                        .None then {
                            return [U]Option.None()
                        },
                        .Some(outer_val) then {
                            self.current_inner = [InnerR]Option.Some(self.mapper(outer_val))
                        },
                    }
                },
            }
        }
        return [U]Option.None()
    }
}

// ============================================================================
// Iterator Intermediate Operations
// ============================================================================
given[T Any] [T]Iterator {
    // Filter - returns iterator with elements matching predicate
    public filter(self, fn [T, Bool]Func) [T, Self]FilterIterator =
        [T, Self]FilterIterator(self, fn)

    // Map - transforms each element
    public [U Any]map(self, fn [T, U]Func) [T, U, Self]MappedIterator =
        [T, U, Self]MappedIterator(self, fn)

    // FilterMap - filter and transform in one operation
    public [U Any]filter_map(self, fn [T, [U]Option]Func) [T, U, Self]FilterMapIterator =
        [T, U, Self]FilterMapIterator(self, fn)

    // Take - take first n elements
    public take(self, n UInt) [T, Self]TakeIterator =
        [T, Self]TakeIterator(self, n)

    // Skip - skip first n elements
    public skip(self, n UInt) [T, Self]SkipIterator =
        [T, Self]SkipIterator(self, n)

    // StepBy - take every nth element
    public step_by(self, n UInt) [T, Self]StepIterator = {
        if n < 1 then {
            panic("step size must be at least 1");
        }
        return [T, Self]StepIterator(self, n, true)
    }

    // Enumerate - pair each element with its index
    public enumerate(self) [T, Self]EnumerateIterator =
        [T, Self]EnumerateIterator(self, 0)

    // Peek - execute side effect without modifying elements
    public peek(self, fn [T, Void]Func) [T, Self]PeekIterator =
        [T, Self]PeekIterator(self, fn)

    // Intersperse - insert separator between elements
    public intersperse(self, v T) [T, Self]IntersperseIterator =
        [T, Self]IntersperseIterator(self, v, false, [T]Option.None())

    // TakeWhile - take elements while predicate is true
    public take_while(self, fn [T, Bool]Func) [T, Self]TakeWhileIterator =
        [T, Self]TakeWhileIterator(self, fn, false)

    // SkipWhile - skip elements while predicate is true
    public skip_while(self, fn [T, Bool]Func) [T, Self]SkipWhileIterator =
        [T, Self]SkipWhileIterator(self, fn, true)

    // Chain - chain with another iterator of the same element type
    public [R2 [T]Iterator]chain(self, other R2) [T, Self, R2]ChainIterator =
        [T, Self, R2]ChainIterator(self, other, false)

    // Zip - zip with another iterator into pairs
    public [U Any, R2 [U]Iterator]zip(self, other R2) [T, U, Self, R2]ZipIterator =
        [T, U, Self, R2]ZipIterator(self, other)

    // FlatMap - map each element to an iterator and flatten results
    public [U Any, InnerR [U]Iterator]flat_map(self, fn [T, InnerR]Func) [T, U, Self, InnerR]FlatMapIterator =
        [T, U, Self, InnerR]FlatMapIterator(self, fn, [InnerR]Option.None())
}

// ============================================================================
// Iterator Terminal Operations
// ============================================================================
given[T Any] [T]Iterator {
    // Fold - reduce with initial value
    public [U Any]fold(self, initial U, fn [U, T, U]Func) U = {
        let mut acc = initial
        let mut it = self
        while it.next() is .Some(v) then {
            acc = fn(acc, v)
        }
        return acc
    }

    // Reduce - reduce without initial value
    public reduce(self, fn [T, T, T]Func) [T]Option = {
        let mut it = self
        when it.next() in {
            .None then {
                return [T]Option.None()
            },
            .Some(first) then {
                let mut acc = first
                while it.next() is .Some(v) then {
                    acc = fn(acc, v)
                }
                return [T]Option.Some(acc)
            },
        }
    }

    // ToList - collect into List
    public to_list(self) [T]List = {
        let mut result = [T]List.new()
        let mut it = self
        while it.next() is .Some(v) then {
            result.push(v)
        }
        return result
    }

    public [R1 Hashable, R2 Any]to_map(self, trans [T, [R1, R2]Pair]Func) [R1, R2]Map = {
        let mut result = [R1, R2]Map.new()
        let mut it = self
        while it.next() is .Some(v) then {
            let pair = trans(v)
            result.insert(pair.first, pair.second);
        }
        return result
    }

    // ForEach - execute side effect for each element
    public for_each(self, fn [T, Void]Func) Void = {
        let mut it = self
        while it.next() is .Some(v) then {
            fn(v);
        }
    }

    // Count - count elements
    public count(self) UInt = {
        let mut n UInt = 0
        let mut it = self
        while it.next() is .Some(_) then {
            n += 1
        }
        return n
    }

    // First - get first element
    public first(self) [T]Option = self.next()

    // Last - get last element
    public last(self) [T]Option = {
        let mut result = [T]Option.None()
        let mut it = self
        while it.next() is .Some(v) then {
            result = [T]Option.Some(v)
        }
        return result
    }

    // Nth - get element at index
    public nth(self, n UInt) [T]Option = {
        let mut it = self
        let mut i UInt = 0
        while it.next() is .Some(v) then {
            if i == n then {
                return [T]Option.Some(v)
            }
            i += 1
        }
        return [T]Option.None()
    }

    // Position - find index of first element matching predicate
    public position(self, fn [T, Bool]Func) [UInt]Option = {
        let mut it = self
        let mut i UInt = 0
        while it.next() is .Some(v) then {
            if fn(v) then {
                return [UInt]Option.Some(i)
            }
            i += 1
        }
        return [UInt]Option.None()
    }

    // Find - find first element matching predicate
    public find(self, fn [T, Bool]Func) [T]Option = {
        let mut it = self
        while it.next() is .Some(v) then {
            if fn(v) then {
                return [T]Option.Some(v)
            }
        }
        return [T]Option.None()
    }

    // FindMap - find first element that maps to Some
    public [U Any]find_map(self, fn [T, [U]Option]Func) [U]Option = {
        let mut it = self
        while it.next() is .Some(v) then {
            when fn(v) in {
                .Some(u) then {
                    return [U]Option.Some(u)
                },
                .None then {},
            }
        }
        return [U]Option.None()
    }

    // Any - check if any element matches predicate
    public any(self, fn [T, Bool]Func) Bool = {
        let mut it = self
        while it.next() is .Some(v) then {
            if fn(v) then {
                return true
            }
        }
        return false
    }

    // All - check if all elements match predicate
    public all(self, fn [T, Bool]Func) Bool = {
        let mut it = self
        while it.next() is .Some(v) then {
            if not fn(v) then {
                return false
            }
        }
        return true
    }

    // IsEmpty - check if iterator has no elements
    public is_empty(self) Bool = self.next().is_none()

    // MaxBy - find element with maximum key
    public [K Ord]max_by(self, fn [T, K]Func) [T]Option = {
        let mut it = self
        when it.next() in {
            .None then {
                return [T]Option.None()
            },
            .Some(first) then {
                let mut result = first
                let mut result_key = fn(first)
                while it.next() is .Some(v) then {
                    let key = fn(v)
                    if key > result_key then {
                        result = v
                        result_key = key
                    }
                }
                return [T]Option.Some(result)
            },
        }
    }

    // MinBy - find element with minimum key
    public [K Ord]min_by(self, fn [T, K]Func) [T]Option = {
        let mut it = self
        when it.next() in {
            .None then {
                return [T]Option.None()
            },
            .Some(first) then {
                let mut result = first
                let mut result_key = fn(first)
                while it.next() is .Some(v) then {
                    let key = fn(v)
                    if key < result_key then {
                        result = v
                        result_key = key
                    }
                }
                return [T]Option.Some(result)
            },
        }
    }
}

// ============================================================================
// Iterator Terminal Operations with Eq constraint
// ============================================================================
given[T Eq] [T]Iterator {
    // Contains - check if iterator contains a value
    public contains(self, value T) Bool = {
        let mut it = self
        while it.next() is .Some(v) then {
            if v == value then {
                return true
            }
        }
        return false
    }
}

// ============================================================================
// Iterator Terminal Operations with Ord constraint
// ============================================================================
given[T Ord] [T]Iterator {
    // Max - find maximum element
    public max(self) [T]Option = {
        let mut it = self
        when it.next() in {
            .None then {
                return [T]Option.None()
            },
            .Some(first) then {
                let mut result = first
                while it.next() is .Some(v) then {
                    if v > result then {
                        result = v
                    }
                }
                return [T]Option.Some(result)
            },
        }
    }

    // Min - find minimum element
    public min(self) [T]Option = {
        let mut it = self
        when it.next() in {
            .None then {
                return [T]Option.None()
            },
            .Some(first) then {
                let mut result = first
                while it.next() is .Some(v) then {
                    if v < result then {
                        result = v
                    }
                }
                return [T]Option.Some(result)
            },
        }
    }
}

// ============================================================================
// Iterator Terminal Operations with Hashable constraint
// ============================================================================
given[T Hashable] [T]Iterator {
    // ToSet - collect into Set
    public to_set(self) [T]Set = {
        let mut result = [T]Set.new()
        let mut it = self
        while it.next() is .Some(v) then {
            result.insert(v);
        }
        return result
    }
}

// ============================================================================
// Iterator Numeric Aggregations
// ============================================================================
given[T Add] [T]Iterator {
    // Sum - sums elements using Add.zero/add
    public sum(self) T = {
        let mut acc = T.zero()
        let mut it = self
        while it.next() is .Some(v) then {
            acc = acc.add(v)
        }
        return acc
    }
}

given[T Mul] [T]Iterator {
    // Product - multiplies elements using Mul.one/mul
    public product(self) T = {
        let mut acc = T.one()
        let mut it = self
        while it.next() is .Some(v) then {
            acc = acc.mul(v)
        }
        return acc
    }
}

given[T Add and Div] [T]Iterator {
    // Average - returns None for empty iterators to avoid division by zero.
    public average(self) [T]Option = {
        let mut acc = T.zero()
        let mut count = 0
        let mut count_t = T.zero()
        let mut it = self
        while it.next() is .Some(v) then {
            acc = acc.add(v)
            count += 1
            count_t = count_t.add(T.one())
        }
        return if count == 0 then [T]Option.None()
        else [T]Option.Some(acc.div(count_t))
    }
}
