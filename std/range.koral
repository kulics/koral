// ============================================================================
// Koral Standard Library - Range Type
// ============================================================================
// NOTE: This file is merged into core.koral, so all previous types are already available.
// ============================================================================

// ============================================================================
// Range Type Definition
// ============================================================================

// Range union type representing different kinds of intervals
public type [T Ord]Range {
    // Bound ranges (4 kinds)
    ClosedRange(start T, end T), // a..b   : start <= x <= end
    ClosedOpenRange(start T, end T), // a..<b  : start <= x < end
    OpenClosedRange(start T, end T), // a<..b  : start < x <= end
    OpenRange(start T, end T), // a<..<b : start < x < end

    // From ranges (2 kinds)
    FromRange(start T), // a...   : start <= x <= max
    FromOpenRange(start T), // a<...  : start < x <= max

    // To ranges (2 kinds)
    ToRange(end T), // ...b   : min <= x <= end
    ToOpenRange(end T), // ...<b  : min <= x < end

    // Full range (1 kind)
    FullRange(), // ....   : min <= x <= max
}

// Range contains method - checks if a value is within the range
given[T Ord] [T]Range {
    public contains(self, value T) Bool = when self in {
        .ClosedRange(start, end) then start <= value and value <= end,
        .ClosedOpenRange(start, end) then start <= value and value < end,
        .OpenClosedRange(start, end) then start < value and value <= end,
        .OpenRange(start, end) then start < value and value < end,
        .FromRange(start) then start <= value,
        .FromOpenRange(start) then start < value,
        .ToRange(end) then value <= end,
        .ToOpenRange(end) then value < end,
        .FullRange then true,
    }
}

// ============================================================================
// Steppable Trait
// ============================================================================

// Steppable trait for types that can be stepped through sequentially
public trait Steppable Bounded {
    succ(self) [Self]Option
    pred(self) [Self]Option
}

// Steppable implementation for Int
given Int Steppable {
    public succ(self) [Self]Option =
        if self == Int.max_value() then [Self]Option.None() else [Self]Option.Some(self + 1)

    public pred(self) [Self]Option =
        if self == Int.min_value() then [Self]Option.None() else [Self]Option.Some(self - 1)
}

// Steppable implementation for Int8
given Int8 Steppable {
    public succ(self) [Self]Option =
        if self == Int8.max_value() then [Self]Option.None() else [Self]Option.Some(self + 1)

    public pred(self) [Self]Option =
        if self == Int8.min_value() then [Self]Option.None() else [Self]Option.Some(self - 1)
}

// Steppable implementation for Int16
given Int16 Steppable {
    public succ(self) [Self]Option =
        if self == Int16.max_value() then [Self]Option.None() else [Self]Option.Some(self + 1)

    public pred(self) [Self]Option =
        if self == Int16.min_value() then [Self]Option.None() else [Self]Option.Some(self - 1)
}

// Steppable implementation for Int32
given Int32 Steppable {
    public succ(self) [Self]Option =
        if self == Int32.max_value() then [Self]Option.None() else [Self]Option.Some(self + 1)

    public pred(self) [Self]Option =
        if self == Int32.min_value() then [Self]Option.None() else [Self]Option.Some(self - 1)
}

// Steppable implementation for Int64
given Int64 Steppable {
    public succ(self) [Self]Option =
        if self == Int64.max_value() then [Self]Option.None() else [Self]Option.Some(self + 1)

    public pred(self) [Self]Option =
        if self == Int64.min_value() then [Self]Option.None() else [Self]Option.Some(self - 1)
}

// Steppable implementation for UInt
given UInt Steppable {
    public succ(self) [Self]Option =
        if self == UInt.max_value() then [Self]Option.None() else [Self]Option.Some(self + 1)

    public pred(self) [Self]Option =
        if self == UInt.min_value() then [Self]Option.None() else [Self]Option.Some(self - 1)
}

// Steppable implementation for UInt8
given UInt8 Steppable {
    public succ(self) [Self]Option =
        if self == UInt8.max_value() then [Self]Option.None() else [Self]Option.Some(self + 1)

    public pred(self) [Self]Option =
        if self == UInt8.min_value() then [Self]Option.None() else [Self]Option.Some(self - 1)
}

// Steppable implementation for UInt16
given UInt16 Steppable {
    public succ(self) [Self]Option =
        if self == UInt16.max_value() then [Self]Option.None() else [Self]Option.Some(self + 1)

    public pred(self) [Self]Option =
        if self == UInt16.min_value() then [Self]Option.None() else [Self]Option.Some(self - 1)
}

// Steppable implementation for UInt32
given UInt32 Steppable {
    public succ(self) [Self]Option =
        if self == UInt32.max_value() then [Self]Option.None() else [Self]Option.Some(self + 1)

    public pred(self) [Self]Option =
        if self == UInt32.min_value() then [Self]Option.None() else [Self]Option.Some(self - 1)
}

// Steppable implementation for UInt64
given UInt64 Steppable {
    public succ(self) [Self]Option =
        if self == UInt64.max_value() then [Self]Option.None() else [Self]Option.Some(self + 1)

    public pred(self) [Self]Option =
        if self == UInt64.min_value() then [Self]Option.None() else [Self]Option.Some(self - 1)
}

given[T Steppable] [T]Range {
    private succ_clamped(v T, hi T) T =
        when v.succ() in {
            .Some(next) then if next > hi then hi else next,
            .None then hi,
        }

    public clamp(self, lo T, hi T) [T, T]Pair = {
        let mut start T = lo
        let mut end T = hi

        when self in {
            .ClosedRange(s, e) then {
                start = s
                end = if e >= hi then hi else [T]Range.succ_clamped(e, hi)
            },
            .ClosedOpenRange(s, e) then {
                start = s
                end = if e > hi then hi else e
            },
            .OpenClosedRange(s, e) then {
                start = [T]Range.succ_clamped(s, hi)
                end = if e >= hi then hi else [T]Range.succ_clamped(e, hi)
            },
            .OpenRange(s, e) then {
                start = [T]Range.succ_clamped(s, hi)
                end = if e > hi then hi else e
            },
            .FromRange(s) then {
                start = s
                end = hi
            },
            .FromOpenRange(s) then {
                start = [T]Range.succ_clamped(s, hi)
                end = hi
            },
            .ToRange(e) then {
                start = lo
                end = if e >= hi then hi else [T]Range.succ_clamped(e, hi)
            },
            .ToOpenRange(e) then {
                start = lo
                end = if e > hi then hi else e
            },
            .FullRange then {
                start = lo
                end = hi
            },
        }

        if start < lo then {
            start = lo
        }
        if start > hi then {
            start = hi
        }
        if end < lo then {
            end = lo
        }
        if end > hi then {
            end = hi
        }
        if start > end then {
            start = end
        }

        return [T, T]Pair(start, end)
    }
}

// ============================================================================
// Range Iterator
// ============================================================================

// RangeIterator type for iterating over ranges
public type [T Steppable]RangeIterator(mut current [T]Option, end T, include_end Bool)

// RangeIterator next method
given[T Steppable] [T]RangeIterator [T]Iterator {
    public next(self ref) [T]Option = when self.current in {
        .None then [T]Option.None(),
        .Some(c) then {
            // Check if we've reached or passed the end
            let at_end = if self.include_end then c > self.end else c >= self.end

            if at_end then {
                self.current = [T]Option.None()
                return [T]Option.None()
            } else {
                self.current = c.succ()
                return [T]Option.Some(c)
            }
        },
    }
}

// Range iterator method - only available when T is Steppable
given[T Steppable] [T]Range [T, [T]RangeIterator]Iterable {
    public iterator(self) [T]RangeIterator = when self in {
        .ClosedRange(start, end) then [T]RangeIterator([T]Option.Some(start), end, true),
        .ClosedOpenRange(start, end) then [T]RangeIterator([T]Option.Some(start), end, false),
        .OpenClosedRange(start, end) then [T]RangeIterator(start.succ(), end, true),
        .OpenRange(start, end) then [T]RangeIterator(start.succ(), end, false),
        .FromRange(start) then [T]RangeIterator([T]Option.Some(start), T.max_value(), true),
        .FromOpenRange(start) then [T]RangeIterator(start.succ(), T.max_value(), true),
        .ToRange(end) then [T]RangeIterator([T]Option.Some(T.min_value()), end, true),
        .ToOpenRange(end) then [T]RangeIterator([T]Option.Some(T.min_value()), end, false),
        .FullRange then [T]RangeIterator([T]Option.Some(T.min_value()), T.max_value(), true),
    }
}
