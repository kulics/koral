// ============================================================================
// Koral Standard Library - Range Type
// ============================================================================
// NOTE: This file is merged into core.koral, so all previous types are already available.
// ============================================================================

// ============================================================================
// Range Type Definition
// ============================================================================

// Range union type representing different kinds of intervals
public type [T Ord]Range {
    // Bounded ranges (4 kinds)
    ClosedRange(start T, end T), // a..b   : start <= x <= end
    ClosedOpenRange(start T, end T), // a..<b  : start <= x < end
    OpenClosedRange(start T, end T), // a<..b  : start < x <= end
    OpenRange(start T, end T), // a<..<b : start < x < end

    // From ranges (2 kinds)
    FromRange(start T), // a...   : start <= x <= max
    FromOpenRange(start T), // a<...  : start < x <= max

    // To ranges (2 kinds)
    ToRange(end T), // ...b   : min <= x <= end
    ToOpenRange(end T), // ...<b  : min <= x < end

    // Full range (1 kind)
    FullRange(), // ....   : min <= x <= max
}

// Range contains method - checks if a value is within the range
given[T Ord] [T]Range {
    public contains(self, value T) Bool = when self is {
        .ClosedRange(start, end) then start <= value and value <= end,
        .ClosedOpenRange(start, end) then start <= value and value < end,
        .OpenClosedRange(start, end) then start < value and value <= end,
        .OpenRange(start, end) then start < value and value < end,
        .FromRange(start) then start <= value,
        .FromOpenRange(start) then start < value,
        .ToRange(end) then value <= end,
        .ToOpenRange(end) then value < end,
        .FullRange then true,
    }
}

// ============================================================================
// Steppable Trait
// ============================================================================

// Steppable trait for types that can be stepped through sequentially
public trait Steppable Ord {
    max() Self
    min() Self
    succ(self) [Self]Option
    pred(self) [Self]Option
}

// Steppable implementation for Int
given Int {
    public succ(self) [Self]Option =
        if self == Int.max() then [Self]Option.None() else [Self]Option.Some(self + 1)

    public pred(self) [Self]Option =
        if self == Int.min() then [Self]Option.None() else [Self]Option.Some(self - 1)
}

// Steppable implementation for Int8
given Int8 {
    public succ(self) [Self]Option =
        if self == Int8.max() then [Self]Option.None() else [Self]Option.Some(self + 1)

    public pred(self) [Self]Option =
        if self == Int8.min() then [Self]Option.None() else [Self]Option.Some(self - 1)
}

// Steppable implementation for Int16
given Int16 {
    public succ(self) [Self]Option =
        if self == Int16.max() then [Self]Option.None() else [Self]Option.Some(self + 1)

    public pred(self) [Self]Option =
        if self == Int16.min() then [Self]Option.None() else [Self]Option.Some(self - 1)
}

// Steppable implementation for Int32
given Int32 {
    public succ(self) [Self]Option =
        if self == Int32.max() then [Self]Option.None() else [Self]Option.Some(self + 1)

    public pred(self) [Self]Option =
        if self == Int32.min() then [Self]Option.None() else [Self]Option.Some(self - 1)
}

// Steppable implementation for Int64
given Int64 {
    public succ(self) [Self]Option =
        if self == Int64.max() then [Self]Option.None() else [Self]Option.Some(self + 1)

    public pred(self) [Self]Option =
        if self == Int64.min() then [Self]Option.None() else [Self]Option.Some(self - 1)
}

// Steppable implementation for UInt
given UInt {
    public succ(self) [Self]Option =
        if self == UInt.max() then [Self]Option.None() else [Self]Option.Some(self + 1)

    public pred(self) [Self]Option =
        if self == UInt.min() then [Self]Option.None() else [Self]Option.Some(self - 1)
}

// Steppable implementation for UInt8
given UInt8 {
    public succ(self) [Self]Option =
        if self == UInt8.max() then [Self]Option.None() else [Self]Option.Some(self + 1)

    public pred(self) [Self]Option =
        if self == UInt8.min() then [Self]Option.None() else [Self]Option.Some(self - 1)
}

// Steppable implementation for UInt16
given UInt16 {
    public succ(self) [Self]Option =
        if self == UInt16.max() then [Self]Option.None() else [Self]Option.Some(self + 1)

    public pred(self) [Self]Option =
        if self == UInt16.min() then [Self]Option.None() else [Self]Option.Some(self - 1)
}

// Steppable implementation for UInt32
given UInt32 {
    public succ(self) [Self]Option =
        if self == UInt32.max() then [Self]Option.None() else [Self]Option.Some(self + 1)

    public pred(self) [Self]Option =
        if self == UInt32.min() then [Self]Option.None() else [Self]Option.Some(self - 1)
}

// Steppable implementation for UInt64
given UInt64 {
    public succ(self) [Self]Option =
        if self == UInt64.max() then [Self]Option.None() else [Self]Option.Some(self + 1)

    public pred(self) [Self]Option =
        if self == UInt64.min() then [Self]Option.None() else [Self]Option.Some(self - 1)
}

// ============================================================================
// Range Iterator
// ============================================================================

// RangeIterator type for iterating over ranges
public type [T Steppable]RangeIterator(mut current [T]Option, end T, include_end Bool)

// RangeIterator next method
given[T Steppable] [T]RangeIterator {
    public next(self ref) [T]Option = when self.current is {
        .None then [T]Option.None(),
        .Some(c) then {
            // Check if we've reached or passed the end
            let at_end = if self.include_end then c > self.end else c >= self.end

            if at_end then {
                self.current = [T]Option.None()
                return [T]Option.None()
            } else {
                self.current = c.succ()
                return [T]Option.Some(c)
            }
        },
    }
}

// Range iterator method - only available when T is Steppable
given[T Steppable] [T]Range {
    public iterator(self) [T]RangeIterator = when self is {
        .ClosedRange(start, end) then [T]RangeIterator([T]Option.Some(start), end, true),
        .ClosedOpenRange(start, end) then [T]RangeIterator([T]Option.Some(start), end, false),
        .OpenClosedRange(start, end) then [T]RangeIterator(start.succ(), end, true),
        .OpenRange(start, end) then [T]RangeIterator(start.succ(), end, false),
        .FromRange(start) then [T]RangeIterator([T]Option.Some(start), T.max(), true),
        .FromOpenRange(start) then [T]RangeIterator(start.succ(), T.max(), true),
        .ToRange(end) then [T]RangeIterator([T]Option.Some(T.min()), end, true),
        .ToOpenRange(end) then [T]RangeIterator([T]Option.Some(T.min()), end, false),
        .FullRange then [T]RangeIterator([T]Option.Some(T.min()), T.max(), true),
    }
}
