// ============================================================================
// Koral Standard Library - String Type
// ============================================================================
// NOTE: This file is merged into core.koral, so primitives, traits, and option are already available.
// ============================================================================

// ============================================================================
// String Storage and Type Definition
// ============================================================================

// Internal storage for String (COW semantics)
public type StringStorage(mut data UInt8 ptr, mut len Int, mut cap Int)

given StringStorage {
    __drop(self ref) = { dealloc_memory(self.data) }
}

// String type with COW semantics
public type String(mut storage StringStorage ref)

// Forward declarations for String iterators
// Wrapper types (provide iterator() method)
public type StringSplitAsciiWhitespace(source String)
public type StringSplit(source String, sep String)
public type StringLines(source String)

// Iterator types (provide next() method)
public type StringSplitAsciiWhitespaceIterator(source String, mut index Int)
public type StringSplitIterator(source String, sep String, mut index Int)
public type StringLinesIterator(source String, mut index Int)

// ============================================================================
// String Methods
// ============================================================================

given String {
    // Unsafe constructor: does not validate UTF-8
    public from_bytes_unchecked(bytes UInt8 ptr, len Int) String = {
        let cap = len + 1
        let data = [UInt8]alloc_memory(cap)
        copy_memory(data, bytes, len)
        init_memory(offset_ptr(data, len), 0)
        let storage = ref StringStorage(data, len, cap)
        String(storage)
    }

    // Validate UTF-8 byte sequence (strict)
    private validate_utf8(bytes UInt8 ptr, len Int) Bool = {
        if len < 0 then { return false; }
        let mut i = 0
        while i < len then {
            let b0 = deptr offset_ptr(bytes, i)
            // 1-byte (ASCII)
            if b0 < 128u8 then {
                i += 1
                continue
            }
            // Continuation byte as leading byte
            if b0 < 192u8 then { return false; }
            // 2-byte sequence
            if b0 < 224u8 then {
                if i + 1 >= len then { return false; }
                let b1 = deptr offset_ptr(bytes, i + 1)
                if { b1 & 192u8 } <> 128u8 then { return false; }
                let cp = { { (UInt32)b0 & 31u32 } << 6 } | { (UInt32)b1 & 63u32 }
                if cp < 128u32 then { return false; }
                i += 2
                continue
            }
            // 3-byte sequence
            if b0 < 240u8 then {
                if i + 2 >= len then { return false; }
                let b1 = deptr offset_ptr(bytes, i + 1)
                let b2 = deptr offset_ptr(bytes, i + 2)
                if { b1 & 192u8 } <> 128u8 or { b2 & 192u8 } <> 128u8 then { return false; }
                let cp = { { (UInt32)b0 & 15u32 } << 12 } | { { (UInt32)b1 & 63u32 } << 6 } | { (UInt32)b2 & 63u32 }
                if cp < 2048u32 then { return false; }
                if cp >= 55296u32 and cp <= 57343u32 then { return false; }
                i += 3
                continue
            }
            // 4-byte sequence
            if b0 < 248u8 then {
                if i + 3 >= len then { return false; }
                let b1 = deptr offset_ptr(bytes, i + 1)
                let b2 = deptr offset_ptr(bytes, i + 2)
                let b3 = deptr offset_ptr(bytes, i + 3)
                if { b1 & 192u8 } <> 128u8 or { b2 & 192u8 } <> 128u8 or { b3 & 192u8 } <> 128u8 then { return false; }
                let cp = { { (UInt32)b0 & 7u32 } << 18 } | { { (UInt32)b1 & 63u32 } << 12 } | { { (UInt32)b2 & 63u32 } << 6 } | { (UInt32)b3 & 63u32 }
                if cp < 65536u32 or cp > 1114111u32 then { return false; }
                i += 4
                continue
            }
            // Invalid leading byte (>= 248)
            return false
        }
        true
    }

    // Safe constructor: validates UTF-8
    public from_bytes(bytes UInt8 ptr, len Int) String = {
        if not String.validate_utf8(bytes, len) then {
            panic("Invalid UTF-8")
        }
        String.from_bytes_unchecked(bytes, len)
    }

    // Safe constructor from C string (null-terminated, validates UTF-8)
    public from_cstring(cstr UInt8 ptr) String = {
        let mut len = 0
        while deptr offset_ptr(cstr, len) <> 0u8 then {
            len += 1
        }
        String.from_bytes(cstr, len)
    }

    public empty() String = {
        let data = [UInt8]alloc_memory(1)
        init_memory(data, 0)
        let storage = ref StringStorage(data, 0, 1)
        String(storage)
    }

    public with_capacity(capacity Int) String = {
        let cap = if capacity < 1 then 1 else capacity + 1
        let data = [UInt8]alloc_memory(cap)
        init_memory(data, 0)
        let storage = ref StringStorage(data, 0, cap)
        String(storage)
    }

    public new() String = {
        let cap = 16  // 默认容量
        let data = [UInt8]alloc_memory(cap)
        init_memory(data, 0)
        let storage = ref StringStorage(data, 0, cap)
        String(storage)
    }

    // Using comparison patterns for ASCII space check
    private is_ascii_space(b UInt8) Bool =
        b == " " or b == "\t" or b == "\n" or b == "\v" or b == "\f" or b == "\r"

    private bounds_check_read(self, index Int) Void = {
        if index < 0 or index > self.storage.len then {
            panic("String index out of bounds")
        }
    }

    private bounds_check_write(self, index Int) Void = {
        if index < 0 or index >= self.storage.len then {
            panic("String index out of bounds")
        }
    }

    private ensure_unique(self ref) Void = {
        if ref_count(self.storage) > 1 then {
            let old = self.storage
            let new_data = [UInt8]alloc_memory(old.cap)
            copy_memory(new_data, old.data, old.len + 1)
            let new_storage = ref StringStorage(new_data, old.len, old.cap)
            self.storage = new_storage
        }
    }

    private ensure_capacity(self ref, min_cap Int) Void = {
        if self.storage.cap >= min_cap then { return; }
        let mut new_cap = self.storage.cap * 2
        if new_cap < min_cap then { new_cap = min_cap; }
        let new_data = [UInt8]alloc_memory(new_cap)
        copy_memory(new_data, self.storage.data, self.storage.len + 1)
        let new_storage = ref StringStorage(new_data, self.storage.len, new_cap)
        self.storage = new_storage
    }

    public count(self) Int = self.storage.len
    public is_empty(self) Bool = self.storage.len == 0
    public capacity(self) Int = self.storage.cap - 1

    public get(self, index Int) [UInt8]Option = {
        if index < 0 or index >= self.storage.len then {
            return [UInt8]Option.None()
        }
        [UInt8]Option.Some(deptr offset_ptr(self.storage.data, index))
    }

    public at(self, index Int) UInt8 = {
        if index < 0 or index >= self.storage.len then {
            panic("String index out of bounds")
        }
        deptr offset_ptr(self.storage.data, index)
    }

    public push(self ref, value UInt8) Void = {
        self.ensure_unique()
        let needed = self.storage.len + 2
        self.ensure_capacity(needed)
        init_memory(offset_ptr(self.storage.data, self.storage.len), value)
        self.storage.len = self.storage.len + 1
        deptr offset_ptr(self.storage.data, self.storage.len) = 0;
    }

    public push_string(self ref, other String) Void = {
        let other_len = other.storage.len
        self.ensure_unique()
        let needed = self.storage.len + other_len + 1
        self.ensure_capacity(needed)
        let dest = offset_ptr(self.storage.data, self.storage.len)
        copy_memory(dest, other.storage.data, other_len)
        self.storage.len = self.storage.len + other_len
        deptr offset_ptr(self.storage.data, self.storage.len) = 0;
    }

    // Push an Int value directly to the string
    public push_int(self ref, value Int) Void = {
        if value == 0 then {
            self.push('0')
            return
        }
        
        let mut n = value
        let is_negative = n < 0
        if is_negative then { n = 0 - n; }
        
        let buf = [UInt8]alloc_memory(21)
        let mut pos = 20
        while n > 0 then {
            pos -= 1
            init_memory(offset_ptr(buf, pos), (UInt8){ n % 10 } + '0')
            n = n / 10
        }
        
        if is_negative then {
            pos -= 1
            init_memory(offset_ptr(buf, pos), '-')
        }
        
        let mut i = pos
        while i < 20 then {
            self.push(deptr offset_ptr(buf, i))
            i += 1
        }
        
        let mut j = pos
        while j < 20 then {
            deinit_memory(offset_ptr(buf, j))
            j += 1
        }
        dealloc_memory(buf)
    }

    // Push a UInt value directly to the string
    public push_uint(self ref, value UInt) Void = {
        if value == 0u then {
            self.push('0')
            return
        }
        
        let mut n = value
        let buf = [UInt8]alloc_memory(21)
        let mut pos = 20
        while n > 0u then {
            pos -= 1
            init_memory(offset_ptr(buf, pos), (UInt8){ n % 10u } + '0')
            n = n / 10u
        }
        
        let mut i = pos
        while i < 20 then {
            self.push(deptr offset_ptr(buf, i))
            i += 1
        }
        
        let mut j = pos
        while j < 20 then {
            deinit_memory(offset_ptr(buf, j))
            j += 1
        }
        dealloc_memory(buf)
    }

    public reserve(self ref, capacity Int) Void = {
        self.ensure_unique()
        self.ensure_capacity(capacity + 1)
    }

    public starts_with(self, prefix String) Bool = {
        if prefix.storage.len > self.storage.len then { return false; }
        let mut i = 0
        while i < prefix.storage.len then {
            if deptr offset_ptr(self.storage.data, i) <> deptr offset_ptr(prefix.storage.data, i) then { return false; }
            i += 1
        }
        true
    }

    public ends_with(self, suffix String) Bool = {
        let slen = suffix.storage.len
        if slen > self.storage.len then { return false; }
        let offset = self.storage.len - slen
        let mut i = 0
        while i < slen then {
            if deptr offset_ptr(self.storage.data, offset + i) <> deptr offset_ptr(suffix.storage.data, i) then { return false; }
            i += 1
        }
        true
    }

    public find_index(self, pat String) [Int]Option = self.find_index_from(pat, 0)

    public find_last_index(self, pat String) [Int]Option = {
        if pat.storage.len == 0 then {
            panic("find_last_index empty pattern")
        }
        let mut result = [Int]Option.None()
        let mut start = 0
        // Using while is pattern matching for iterator-like loop
        while self.find_index_from(pat, start) is .Some(idx) then {
            result = [Int]Option.Some(idx)
            start = idx + 1
        }
        result
    }

    private make_substring(self, start Int, len Int) String = {
        if start < 0 or len < 0 or start + len > self.storage.len then {
            panic("substring out of bounds")
        }
        let cap = len + 1
        let data = [UInt8]alloc_memory(cap)
        copy_memory(data, offset_ptr(self.storage.data, start), len)
        init_memory(offset_ptr(data, len), 0)
        let storage = ref StringStorage(data, len, cap)
        String(storage)
    }

    public slice(self, range [Int]Range) String = when range is {
        .ClosedRange(start, end) then self.make_substring(start, end - start + 1),
        .ClosedOpenRange(start, end) then self.make_substring(start, end - start),
        .OpenClosedRange(start, end) then self.make_substring(start + 1, end - start),
        .OpenRange(start, end) then self.make_substring(start + 1, end - start - 1),
        .FromRange(start) then self.make_substring(start, self.storage.len - start),
        .FromOpenRange(start) then self.make_substring(start + 1, self.storage.len - start - 1),
        .ToRange(end) then self.make_substring(0, end + 1),
        .ToOpenRange(end) then self.make_substring(0, end),
        .FullRange then self.make_substring(0, self.storage.len),
    }

    public trim_ascii_start(self) String = {
        let mut i = 0
        while i < self.storage.len and String.is_ascii_space(deptr offset_ptr(self.storage.data, i)) then { i += 1; }
        self.make_substring(i, self.storage.len - i)
    }

    public trim_ascii_end(self) String = {
        let mut end = self.storage.len
        while end > 0 and String.is_ascii_space(deptr offset_ptr(self.storage.data, end - 1)) then { end -= 1; }
        self.make_substring(0, end)
    }

    public trim_ascii(self) String = {
        let head = self.trim_ascii_start()
        head.trim_ascii_end()
    }

    // Using comparison patterns for case conversion
    private to_lower_byte(b UInt8) UInt8 =
        if b is >= 65 and <= 90 then b + 32 else b

    private to_upper_byte(b UInt8) UInt8 =
        if b is >= 97 and <= 122 then b - 32 else b

    public to_ascii_lowercase(self) String = {
        let cap = self.storage.len + 1
        let data = [UInt8]alloc_memory(cap)
        let mut i = 0
        while i < self.storage.len then {
            init_memory(offset_ptr(data, i), String.to_lower_byte(deptr offset_ptr(self.storage.data, i)))
            i += 1
        }
        init_memory(offset_ptr(data, self.storage.len), 0)
        let storage = ref StringStorage(data, self.storage.len, cap)
        String(storage)
    }

    public to_ascii_uppercase(self) String = {
        let cap = self.storage.len + 1
        let data = [UInt8]alloc_memory(cap)
        let mut i = 0
        while i < self.storage.len then {
            init_memory(offset_ptr(data, i), String.to_upper_byte(deptr offset_ptr(self.storage.data, i)))
            i += 1
        }
        init_memory(offset_ptr(data, self.storage.len), 0)
        let storage = ref StringStorage(data, self.storage.len, cap)
        String(storage)
    }

    public is_ascii(self) Bool = {
        let mut i = 0
        while i < self.storage.len then {
            if deptr offset_ptr(self.storage.data, i) >= 128 then { return false; }
            i += 1
        }
        true
    }

    public is_ascii_whitespace(self) Bool = {
        let mut i = 0
        while i < self.storage.len then {
            if not String.is_ascii_space(deptr offset_ptr(self.storage.data, i)) then { return false; }
            i += 1
        }
        true
    }

    public equals(self, other String) Bool = {
        if self.storage.len <> other.storage.len then { return false; }
        let mut i = 0
        while i < self.storage.len then {
            if deptr offset_ptr(self.storage.data, i) <> deptr offset_ptr(other.storage.data, i) then { return false; }
            i += 1
        }
        true
    }

    public compare(self, other String) Int = {
        let min = if self.storage.len < other.storage.len then self.storage.len else other.storage.len
        let mut i = 0
        while i < min then {
            let a = deptr offset_ptr(self.storage.data, i)
            let b = deptr offset_ptr(other.storage.data, i)
            if a < b then { return 0 - 1; }
            if a > b then { return 1; }
            i += 1
        }
        if self.storage.len < other.storage.len then 0 - 1
        else if self.storage.len > other.storage.len then 1
        else 0
    }

    public hash(self) UInt = {
        let mut h UInt = 2166136261u
        let mut i Int = 0
        while i < self.storage.len then {
            let b UInt8 = deptr offset_ptr(self.storage.data, i)
            h = combine_hash(h, (UInt)b)
            i += 1
        }
        h
    }

    public to_string(self) String = self

    public find_index_from(self, pat String, start Int) [Int]Option = {
        if pat.storage.len == 0 then {
            panic("find empty pattern")
        }
        if start < 0 or start > self.storage.len then {
            panic("find start out of bounds")
        }
        let mut i = start
        let max = self.storage.len - pat.storage.len
        while i <= max then {
            let mut j = 0
            let mut ok = true
            while j < pat.storage.len then {
                if deptr offset_ptr(self.storage.data, i + j) <> deptr offset_ptr(pat.storage.data, j) then { ok = false; break; }
                j += 1
            }
            if ok then { return [Int]Option.Some(i); }
            i += 1
        }
        [Int]Option.None()
    }

    public contains(self, pat String) Bool = when self.find_index_from(pat, 0) is {
        .Some(_) then true,
        .None then false,
    }

    public repeat(self, times Int) String = {
        if times < 0 then {
            panic("repeat negative")
        }
        if times == 0 then { return String.empty(); }
        let total = self.storage.len * times
        let cap = total + 1
        let data = [UInt8]alloc_memory(cap)
        let mut offset = 0
        let mut t = 0
        while t < times then {
            copy_memory(offset_ptr(data, offset), self.storage.data, self.storage.len)
            offset += self.storage.len
            t += 1
        }
        init_memory(offset_ptr(data, total), 0)
        let storage = ref StringStorage(data, total, cap)
        String(storage)
    }

    public replace_all(self, pat String, with String) String = {
        if pat.storage.len == 0 then {
            panic("replace empty pattern")
        }
        let mut result = String.empty()
        let mut start = 0
        // Using while is pattern matching
        while self.find_index_from(pat, start) is .Some(idx) then {
            let prefix_len = idx - start
            if prefix_len > 0 then {
                let slice = self.make_substring(start, prefix_len)
                result.push_string(slice)
            }
            result.push_string(with)
            start = idx + pat.storage.len
        }
        if start < self.storage.len then {
            let tail = self.make_substring(start, self.storage.len - start)
            result.push_string(tail)
        }
        result
    }

    public split_ascii_whitespace(self) StringSplitAsciiWhitespace =
        StringSplitAsciiWhitespace(self)

    public split(self, sep String) StringSplit = {
        if sep.storage.len == 0 then {
            panic("split empty separator")
        }
        StringSplit(self, sep)
    }

    public lines(self) StringLines = StringLines(self)

    public remove_prefix(self, prefix String) String =
        if self.starts_with(prefix) then { self.make_substring(prefix.storage.len, self.storage.len - prefix.storage.len) } else { self }

    public remove_suffix(self, suffix String) String = {
        if self.ends_with(suffix) then {
            let remain = self.storage.len - suffix.storage.len
            self.make_substring(0, remain)
        } else { self }
    }
}

// ============================================================================
// String Iterator Implementations - Using new pattern matching
// ============================================================================

// Wrapper types provide iterator() method
given StringSplitAsciiWhitespace {
    public iterator(self) StringSplitAsciiWhitespaceIterator =
        StringSplitAsciiWhitespaceIterator(self.source, 0)
}

given StringSplit {
    public iterator(self) StringSplitIterator =
        StringSplitIterator(self.source, self.sep, 0)
}

given StringLines {
    public iterator(self) StringLinesIterator =
        StringLinesIterator(self.source, 0)
}

// Iterator types provide next() method
given StringSplitAsciiWhitespaceIterator {
    public next(self ref) [String]Option = {
        let len = self.source.count()
        let mut i = self.index
        while i < len and String.is_ascii_space(self.source[i]) then { i += 1; }
        if i >= len then { return [String]Option.None(); }
        let start = i
        while i < len and not String.is_ascii_space(self.source[i]) then { i += 1; }
        let part = self.source.slice(start..<i)
        self.index = i
        [String]Option.Some(part)
    }
}

given StringSplitIterator {
    public next(self ref) [String]Option = {
        let len = self.source.count()
        if self.index > len then { return [String]Option.None() }
        when self.source.find_index_from(self.sep, self.index) is {
            .Some(i) then {
                let part = self.source.slice(self.index..<i)
                self.index = i + self.sep.count()
                [String]Option.Some(part)
            },
            .None then {
                let part = self.source.slice(self.index...)
                self.index = len + 1
                [String]Option.Some(part)
            },
        }
    }
}

given StringLinesIterator {
    public next(self ref) [String]Option = {
        let len = self.source.count()
        if self.index > len then { return [String]Option.None() }
        if self.index == len then {
            self.index = len + 1
            return [String]Option.None()
        }
        when self.source.find_index_from("\n", self.index) is {
            .Some(i) then {
                let part = self.source.slice(self.index..<i)
                self.index = i + 1
                [String]Option.Some(part)
            },
            .None then {
                let part = self.source.slice(self.index...)
                self.index = len + 1
                [String]Option.Some(part)
            },
        }
    }
}

// ============================================================================
// Additional String Methods
// ============================================================================

given String {
    // Push a Float64 value directly to the string
    public push_float64(self ref, value Float64) Void = {
        // Handle special cases
        let bits = value.to_bits()
        let exp = { bits >> 52 } & 2047u64
        let mantissa = bits & 4503599627370495u64
        if exp == 2047u64 then {
            if mantissa <> 0u64 then {
                self.push_string("NaN")
                return
            }
            if { bits >> 63 } == 1u64 then {
                self.push_string("-Inf")
                return
            }
            self.push_string("Inf")
            return
        }
        
        let is_negative = { bits >> 63 } == 1u64
        let mut f = if is_negative then 0.0 - value else value
        
        let int_part = (Int)f
        let frac_part = f - (Float64)int_part
        
        if is_negative then { self.push('-'); }
        self.push_int(int_part)
        self.push('.')
        
        let mut frac = frac_part
        let mut digits = 0
        while digits < 6 then {
            frac = frac * 10.0
            let d = (Int)frac
            self.push((UInt8)d + '0')
            frac = frac - (Float64)d
            digits += 1
        }
    }

    // Push a Bool value directly to the string
    public push_bool(self ref, value Bool) Void = {
        if value then {
            self.push_string("true")
        } else {
            self.push_string("false")
        }
    }

    public to_ascii_titlecase(self) String = {
        let cap = self.storage.len + 1
        let data = [UInt8]alloc_memory(cap)
        let mut in_word = false
        let mut i = 0
        while i < self.storage.len then {
            let b = deptr offset_ptr(self.storage.data, i)
            if String.is_ascii_space(b) then {
                in_word = false
                init_memory(offset_ptr(data, i), b)
            } else {
                if not in_word then {
                    in_word = true
                    init_memory(offset_ptr(data, i), String.to_upper_byte(b))
                } else {
                    init_memory(offset_ptr(data, i), String.to_lower_byte(b))
                }
            }
            i += 1
        }
        init_memory(offset_ptr(data, self.storage.len), 0)
        let storage = ref StringStorage(data, self.storage.len, cap)
        String(storage)
    }
}


// ============================================================================
// Primitive ToString Implementations
// ============================================================================

given Bool {
    public to_string(self) String = if self then "true" else "false"
}

given Int {
    public to_string(self) String = {
        if self == 0 then { return "0"; }
    
        let mut n = self
        let is_negative = n < 0
        if is_negative then { n = 0 - n; }
    
        // Extract digits in reverse order into buffer
        let buf = [UInt8]alloc_memory(21)
        let mut pos = 20
        init_memory(offset_ptr(buf, pos), 0)
        while n > 0 then {
            pos -= 1
            init_memory(offset_ptr(buf, pos), (UInt8){ n % 10 } + '0')
            n = n / 10
        }
    
        if is_negative then {
            pos -= 1
            init_memory(offset_ptr(buf, pos), '-')
        }
        
        let len = 20 - pos
        if pos > 0 then {
            move_memory(buf, offset_ptr(buf, pos), len + 1)
        }
        let storage = ref StringStorage(buf, len, 21)
        String(storage)
    }
}

given Int8 {
    public to_string(self) String = ((Int)self).to_string()
}

given Int16 {
    public to_string(self) String = ((Int)self).to_string()
}

given Int32 {
    public to_string(self) String = ((Int)self).to_string()
}

given Int64 {
    public to_string(self) String = ((Int)self).to_string()
}


given UInt {
    public to_string(self) String = {
        if self == 0u then { return "0"; }
        
        let mut n = self
        let buf = [UInt8]alloc_memory(21)
        let mut pos = 20
        init_memory(offset_ptr(buf, pos), 0)
        while n > 0u then {
            pos -= 1
            init_memory(offset_ptr(buf, pos), (UInt8){ n % 10u } + '0')
            n = n / 10u
        }
    
        let len = 20 - pos
        if pos > 0 then {
            move_memory(buf, offset_ptr(buf, pos), len + 1)
        }
        let storage = ref StringStorage(buf, len, 21)
        String(storage)
    }
}

given UInt8 {
    public to_string(self) String = ((UInt)self).to_string()
}

given UInt16 {
    public to_string(self) String = ((UInt)self).to_string()
}

given UInt32 {
    public to_string(self) String = ((UInt)self).to_string()
}

given UInt64 {
    public to_string(self) String = ((UInt)self).to_string()
}


given Float32 {
    public to_string(self) String = {
        let bits = self.to_bits()
        let exp = { bits >> 23 } & 255u32
        let mantissa = bits & 8388607u32
        if exp == 255u32 then {
            if mantissa <> 0u32 then { return "NaN"; }
            if { bits >> 31 } == 1u32 then { return "-Inf"; }
            return "Inf"
        }
        
        let is_negative = { bits >> 31 } == 1u32
        let mut f = if is_negative then 0.0 - (Float64)self else (Float64)self
        
        let int_part = (Int)f
        let frac_part = f - (Float64)int_part
        
        let mut result = String.empty()
        if is_negative then { result.push('-'); }
        
        result.push_string(int_part.to_string())
        result.push('.')
        
        let mut frac = frac_part
        let mut digits = 0
        while digits < 6 then {
            frac = frac * 10.0
            let d = (Int)frac
            result.push((UInt8)d + '0')
            frac = frac - (Float64)d
            digits += 1
        }
        
        result
    }
}


given Float64 {
    public to_string(self) String = {
        let bits = self.to_bits()
        let exp = { bits >> 52 } & 2047u64
        let mantissa = bits & 4503599627370495u64
        if exp == 2047u64 then {
            if mantissa <> 0u64 then { return "NaN"; }
            if { bits >> 63 } == 1u64 then { return "-Inf"; }
            return "Inf"
        }
        
        let is_negative = { bits >> 63 } == 1u64
        let mut f = if is_negative then 0.0 - self else self
        
        let int_part = (Int)f
        let frac_part = f - (Float64)int_part
        
        let mut result = String.empty()
        if is_negative then { result.push('-'); }

        result.push_string(int_part.to_string())
        result.push('.')
        
        let mut frac = frac_part
        let mut digits = 0
        while digits < 6 then {
            frac = frac * 10.0
            let d = (Int)frac
            result.push((UInt8)d + '0')
            frac = frac - (Float64)d
            digits += 1
        }
        
        result
    }
}


// ============================================================================
// Option ToString Implementation
// ============================================================================

given [T ToString] [T]Option {
    public to_string(self) String = when self is {
        .Some(v) then {
            let mut result = String.empty()
            result.push_string("Some(")
            result.push_string(v.to_string())
            result.push_string(")")
            result
        },
        .None then "None",
    }
}


// ============================================================================
// Rune Iterator Types
// ============================================================================

// Wrapper type for rune iteration (provides iterator() method)
public type Runes(source String)

// Iterator type for rune iteration (provides next() method)
public type RunesIterator(source String, mut byte_index Int)

given Runes {
    public iterator(self) RunesIterator = RunesIterator(self.source, 0)
}


given RunesIterator {
    // Decode next UTF-8 sequence and return Rune
    public next(self ref) [Rune]Option = {
        let len = self.source.count()
        if self.byte_index >= len then {
            return [Rune]Option.None()
        }
        
        let b0 = self.source[self.byte_index]
        
        // 1-byte sequence (ASCII): 0xxxxxxx
        if b0 < 128u8 then {
            self.byte_index = self.byte_index + 1
            return [Rune]Option.Some(Rune((UInt32)b0))
        }
        
        // Invalid: continuation byte as first byte
        if b0 < 192u8 then {
            self.byte_index = self.byte_index + 1
            return [Rune]Option.Some(Rune.replacement_char())
        }
        
        // 2-byte sequence: 110xxxxx 10xxxxxx
        if b0 < 224u8 then {
            if self.byte_index + 1 >= len then {
                self.byte_index = self.byte_index + 1
                return [Rune]Option.Some(Rune.replacement_char())
            }
            let b1 = self.source[self.byte_index + 1]
            if { b1 & 192u8 } <> 128u8 then {
                self.byte_index = self.byte_index + 1
                return [Rune]Option.Some(Rune.replacement_char())
            }
            let cp = { { (UInt32)b0 & 31u32 } << 6 } | { (UInt32)b1 & 63u32 }
            // Check for overlong encoding
            if cp < 128u32 then {
                self.byte_index = self.byte_index + 2
                return [Rune]Option.Some(Rune.replacement_char())
            }
            self.byte_index = self.byte_index + 2
            return [Rune]Option.Some(Rune(cp))
        }
        
        // 3-byte sequence: 1110xxxx 10xxxxxx 10xxxxxx
        if b0 < 240u8 then {
            if self.byte_index + 2 >= len then {
                self.byte_index = self.byte_index + 1
                return [Rune]Option.Some(Rune.replacement_char())
            }
            let b1 = self.source[self.byte_index + 1]
            let b2 = self.source[self.byte_index + 2]
            if { b1 & 192u8 } <> 128u8 or { b2 & 192u8 } <> 128u8 then {
                self.byte_index = self.byte_index + 1
                return [Rune]Option.Some(Rune.replacement_char())
            }
            let cp = { { (UInt32)b0 & 15u32 } << 12 } | { { (UInt32)b1 & 63u32 } << 6 } | { (UInt32)b2 & 63u32 }
            // Check for overlong encoding or surrogate
            if cp < 2048u32 or (cp >= 55296u32 and cp <= 57343u32) then {
                self.byte_index = self.byte_index + 3
                return [Rune]Option.Some(Rune.replacement_char())
            }
            self.byte_index = self.byte_index + 3
            return [Rune]Option.Some(Rune(cp))
        }
        
        // 4-byte sequence: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        if b0 < 248u8 then {
            if self.byte_index + 3 >= len then {
                self.byte_index = self.byte_index + 1
                return [Rune]Option.Some(Rune.replacement_char())
            }
            let b1 = self.source[self.byte_index + 1]
            let b2 = self.source[self.byte_index + 2]
            let b3 = self.source[self.byte_index + 3]
            if { b1 & 192u8 } <> 128u8 or { b2 & 192u8 } <> 128u8 or { b3 & 192u8 } <> 128u8 then {
                self.byte_index = self.byte_index + 1
                return [Rune]Option.Some(Rune.replacement_char())
            }
            let cp = { { (UInt32)b0 & 7u32 } << 18 } | { { (UInt32)b1 & 63u32 } << 12 } | { { (UInt32)b2 & 63u32 } << 6 } | { (UInt32)b3 & 63u32 }
            // Check for overlong encoding or out of range
            if cp < 65536u32 or cp > 1114111u32 then {
                self.byte_index = self.byte_index + 4
                return [Rune]Option.Some(Rune.replacement_char())
            }
            self.byte_index = self.byte_index + 4
            return [Rune]Option.Some(Rune(cp))
        }
        
        // Invalid first byte
        self.byte_index = self.byte_index + 1
        [Rune]Option.Some(Rune.replacement_char())
    }
}


// ============================================================================
// String Rune Methods
// ============================================================================

given String {
    // Return Runes wrapper for iterating over Unicode code points
    public runes(self) Runes = Runes(self)
}


given String {
    // Count number of Unicode code points (runes) in the string
    public rune_count(self) Int = {
        let mut count = 0
        let mut iter = self.runes().iterator()
        while iter.next() is .Some(_) then {
            count = count + 1
        }
        count
    }
}


given String {
    // Get rune at specified index (0-based rune position, not byte position)
    public get_rune(self, index Int) [Rune]Option = {
        if index < 0 then {
            return [Rune]Option.None()
        }
        let mut iter = self.runes().iterator()
        let mut i = 0
        while iter.next() is .Some(r) then {
            if i == index then {
                return [Rune]Option.Some(r)
            }
            i = i + 1
        }
        [Rune]Option.None()
    }
}


given String {
    // Append a rune to the string (encodes as UTF-8)
    public push_rune(self ref, rune Rune) Void = {
        let cp = rune.value
        
        // Handle invalid code points - append replacement character
        if not rune.is_valid() then {
            self.push(239u8)   // 0xEF
            self.push(191u8)   // 0xBF
            self.push(189u8)   // 0xBD
            return
        }
        
        // 1-byte sequence (ASCII)
        if cp < 128u32 then {
            self.push((UInt8)cp)
            return
        }
        
        // 2-byte sequence
        if cp < 2048u32 then {
            self.push((UInt8){ cp >> 6 } | 192u8)
            self.push((UInt8){ cp & 63u32 } | 128u8)
            return
        }
        
        // 3-byte sequence
        if cp < 65536u32 then {
            self.push((UInt8){ cp >> 12 } | 224u8)
            self.push((UInt8){ { cp >> 6 } & 63u32 } | 128u8)
            self.push((UInt8){ cp & 63u32 } | 128u8)
            return
        }
        
        // 4-byte sequence
        self.push((UInt8){ cp >> 18 } | 240u8)
        self.push((UInt8){ { cp >> 12 } & 63u32 } | 128u8)
        self.push((UInt8){ { cp >> 6 } & 63u32 } | 128u8)
        self.push((UInt8){ cp & 63u32 } | 128u8)
    }
}
