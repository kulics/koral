// ============================================================================
// Koral Standard Library - Time Module
// ============================================================================

/// Duration 表示时间间隔
/// 内部存储与 C timespec 完全对齐
public type Duration(secs Int64, nanos Int64)

given Duration {
    // ============ 转换方法 ============

    /// 转换为纳秒总数
    public as_nanos(self) Int64 = {
        self.secs * 1_000_000_000i64 + self.nanos
    }

    /// 转换为微秒总数
    public as_micros(self) Int64 = {
        self.secs * 1_000_000i64 + self.nanos / 1_000i64
    }

    /// 转换为毫秒总数
    public as_millis(self) Int64 = {
        self.secs * 1_000i64 + self.nanos / 1_000_000i64
    }

    /// 转换为秒数（截断）
    public as_seconds(self) Int64 = {
        self.secs
    }

    /// 转换为分钟数（截断）
    public as_minutes(self) Int64 = {
        self.secs / 60i64
    }

    /// 转换为小时数（截断）
    public as_hours(self) Int64 = {
        self.secs / 3600i64
    }

    /// 转换为天数（截断）
    public as_days(self) Int64 = {
        self.secs / 86400i64
    }

    // ============ 运算符 trait ============

    /// 加法
    public add(self, other Duration) Duration = {
        let total_nanos = self.nanos + other.nanos
        let extra_secs = total_nanos / 1_000_000_000i64
        let final_nanos = total_nanos % 1_000_000_000i64
        Duration(self.secs + other.secs + extra_secs, final_nanos)
    }

    /// 取负
    public neg(self) Duration = {
        let mut total_nanos = -self.nanos
        let mut secs = -self.secs
        if total_nanos < 0i64 then {
            secs = secs - 1i64
            total_nanos = total_nanos + 1_000_000_000i64
        }
        Duration(secs, total_nanos)
    }

    /// 减法（可选快速路径）
    public sub(self, other Duration) Duration = {
        let mut total_nanos = self.nanos - other.nanos
        let mut secs_diff = self.secs - other.secs
        if total_nanos < 0i64 then {
            secs_diff = secs_diff - 1i64
            total_nanos = total_nanos + 1_000_000_000i64
        }
        Duration(secs_diff, total_nanos)
    }

    /// 标量缩放（用于运算符 lowering: Duration * Int）
    public scale(self, k Int) Duration = {
        let total_nanos = self.as_nanos() * (Int64)k
        let secs = total_nanos / 1_000_000_000i64
        let nanos = total_nanos % 1_000_000_000i64
        Duration(secs, nanos)
    }

    /// 逆缩放（用于运算符 lowering: Duration / Int）
    public unscale(self, k Int) Duration = {
        let total_nanos = self.as_nanos() / (Int64)k
        let secs = total_nanos / 1_000_000_000i64
        let nanos = total_nanos % 1_000_000_000i64
        Duration(secs, nanos)
    }

    /// 比率（Duration / Duration -> Float64）
    public ratio(self, other Duration) Float64 = {
        let a Float64 = (Float64)self.as_nanos()
        let b Float64 = (Float64)other.as_nanos()
        a / b
    }

    // ============ 比较方法 ============

    /// 相等比较
        public equals(self, other Duration) Bool = {
        self.secs == other.secs and self.nanos == other.nanos
    }

    /// 三路比较
    /// 返回: -1 (self < other), 0 (self == other), 1 (self > other)
        public compare(self, other Duration) Int = {
        if self.secs < other.secs then { -1 }
        else if self.secs > other.secs then { 1 }
        else if self.nanos < other.nanos then { -1 }
        else if self.nanos > other.nanos then { 1 }
        else { 0 }
    }

    // ============ 显示方法 ============

    /// 转换为可读字符串
    /// 格式: "1d2h", "1h30min", "500ms", "100ns"
    public to_string(self) String = {
        if self.secs >= 86400i64 then {
            let days = self.secs / 86400i64
            let remaining_secs = self.secs % 86400i64
            if remaining_secs >= 3600i64 then {
                let hours = remaining_secs / 3600i64
                let mut result = String.empty()
                result.push_string(days.to_string())
                result.push_string("d")
                result.push_string(hours.to_string())
                result.push_string("h")
                result
            } else if remaining_secs >= 60i64 then {
                let mins = remaining_secs / 60i64
                let mut result = String.empty()
                result.push_string(days.to_string())
                result.push_string("d")
                result.push_string(mins.to_string())
                result.push_string("min")
                result
            } else if remaining_secs > 0i64 then {
                let mut result = String.empty()
                result.push_string(days.to_string())
                result.push_string("d")
                result.push_string(remaining_secs.to_string())
                result.push_string("s")
                result
            } else {
                let mut result = String.empty()
                result.push_string(days.to_string())
                result.push_string("d")
                result
            }
        } else if self.secs >= 3600i64 then {
            let hours = self.secs / 3600i64
            let remaining_secs = self.secs % 3600i64
            if remaining_secs >= 60i64 then {
                let mins = remaining_secs / 60i64
                let mut result = String.empty()
                result.push_string(hours.to_string())
                result.push_string("h")
                result.push_string(mins.to_string())
                result.push_string("min")
                result
            } else if remaining_secs > 0i64 then {
                let mut result = String.empty()
                result.push_string(hours.to_string())
                result.push_string("h")
                result.push_string(remaining_secs.to_string())
                result.push_string("s")
                result
            } else {
                let mut result = String.empty()
                result.push_string(hours.to_string())
                result.push_string("h")
                result
            }
        } else if self.secs >= 60i64 then {
            let mins = self.secs / 60i64
            let remaining_secs = self.secs % 60i64
            if remaining_secs > 0i64 then {
                let mut result = String.empty()
                result.push_string(mins.to_string())
                result.push_string("min")
                result.push_string(remaining_secs.to_string())
                result.push_string("s")
                result
            } else {
                let mut result = String.empty()
                result.push_string(mins.to_string())
                result.push_string("min")
                result
            }
        } else if self.secs > 0i64 then {
            if self.nanos > 0i64 then {
                let mut result = String.empty()
                result.push_string(self.secs.to_string())
                result.push_string("s")
                result.push_string(self.nanos.to_string())
                result.push_string("ns")
                result
            } else {
                let mut result = String.empty()
                result.push_string(self.secs.to_string())
                result.push_string("s")
                result
            }
        } else if self.nanos >= 1_000_000i64 then {
            let mut result = String.empty()
            result.push_string((self.nanos / 1_000_000i64).to_string())
            result.push_string("ms")
            result
        } else if self.nanos >= 1_000i64 then {
            let mut result = String.empty()
            result.push_string((self.nanos / 1_000i64).to_string())
            result.push_string("us")
            result
        } else {
            let mut result = String.empty()
            result.push_string(self.nanos.to_string())
            result.push_string("ns")
            result
        }
    }
}

// ============================================================================
// Sleep API (koral_nanosleep runtime)
// ============================================================================

// FFI 结构体：与 C timespec 布局对齐
foreign type KoralTimespec(tv_sec Int64, tv_nsec Int64)

// FFI 函数声明
// Runtime 提供 koral_nanosleep，避免与系统 nanosleep 冲突
foreign let koral_nanosleep(req KoralTimespec ptr, rem KoralTimespec ptr) Int32

/// 休眠指定时间
public let sleep(d Duration) Void = {
    if d.secs < 0i64 or d.nanos < 0i64 then {
        panic("sleep: negative duration")
    }

    let mut secs = d.secs
    let mut nanos = d.nanos
    if nanos >= 1_000_000_000i64 then {
        let extra = nanos / 1_000_000_000i64
        secs = secs + extra
        nanos = nanos % 1_000_000_000i64
    }

    let ts = KoralTimespec(secs, nanos)
    let _ = koral_nanosleep(ptr ts, [KoralTimespec]null_ptr())
}
