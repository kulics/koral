// ============================================================================
// Koral Standard Library - Time Module
// ============================================================================

/// Duration 表示时间间隔
/// 内部存储与 C timespec 完全对齐
public type Duration(secs Int64, nanos Int64)

given Duration {
    // ============ 工厂方法 ============

    /// 从纳秒创建 Duration
    public from_nanoseconds(n Int) Duration = {
        let total = (Int64)n
        let secs = total / 1_000_000_000
        let nanos = total % 1_000_000_000
        return Duration(secs, nanos)
    }

    /// 从微秒创建 Duration
    public from_microseconds(n Int) Duration = {
        let total_nanos = (Int64)n * 1_000
        let secs = total_nanos / 1_000_000_000
        let nanos = total_nanos % 1_000_000_000
        return Duration(secs, nanos)
    }

    /// 从毫秒创建 Duration
    public from_milliseconds(n Int) Duration = {
        let total_nanos = (Int64)n * 1_000_000
        let secs = total_nanos / 1_000_000_000
        let nanos = total_nanos % 1_000_000_000
        return Duration(secs, nanos)
    }

    /// 从秒创建 Duration
    public from_seconds(n Int) Duration = Duration((Int64)n, 0)

    /// 从分钟创建 Duration
    public from_minutes(n Int) Duration = Duration((Int64)n * 60, 0)

    /// 从小时创建 Duration
    public from_hours(n Int) Duration = Duration((Int64)n * 3600, 0)

    // ============ 转换方法 ============

    /// 转换为纳秒总数
    public as_nanoseconds(self) Int64 =
        self.secs * 1_000_000_000 + self.nanos

    /// 转换为微秒总数
    public as_microseconds(self) Int64 =
        self.secs * 1_000_000 + self.nanos / 1_000

    /// 转换为毫秒总数
    public as_milliseconds(self) Int64 =
        self.secs * 1_000 + self.nanos / 1_000_000

    /// 转换为秒数（截断）
    public as_seconds(self) Int64 =
        self.secs

    /// 转换为分钟数（截断）
    public as_minutes(self) Int64 =
        self.secs / 60

    /// 转换为小时数（截断）
    public as_hours(self) Int64 =
        self.secs / 3600

    /// 比率（Duration / Duration -> Float64）
    public ratio(self, other Duration) Float64 = {
        let a Float64 = (Float64)self.as_nanoseconds()
        let b Float64 = (Float64)other.as_nanoseconds()
        return a / b
    }
}

given Duration Add {
    /// 零值
    public zero() Duration = Duration(0, 0)

    /// 加法
    public add(self, other Duration) Duration = {
        let total_nanos = self.nanos + other.nanos
        let extra_secs = total_nanos / 1_000_000_000
        let final_nanos = total_nanos % 1_000_000_000
        return Duration(self.secs + other.secs + extra_secs, final_nanos)
    }
}

given Duration Sub {
    /// 取负
    public neg(self) Duration = {
        let mut total_nanos = -self.nanos
        let mut secs = -self.secs
        if total_nanos < 0 then {
            secs = secs - 1
            total_nanos = total_nanos + 1_000_000_000
        }
        return Duration(secs, total_nanos)
    }

    /// 减法（可选快速路径）
    public sub(self, other Duration) Duration = {
        let mut total_nanos = self.nanos - other.nanos
        let mut secs_diff = self.secs - other.secs
        if total_nanos < 0 then {
            secs_diff = secs_diff - 1
            total_nanos = total_nanos + 1_000_000_000
        }
        return Duration(secs_diff, total_nanos)
    }
}

given Duration [Int]Scale {
    /// 标量缩放（用于运算符 lowering: Duration * Int）
    public scale(self, k Int) Duration = {
        let total_nanos = self.as_nanoseconds() * (Int64)k
        let secs = total_nanos / 1_000_000_000
        let nanos = total_nanos % 1_000_000_000
        return Duration(secs, nanos)
    }
}

given Duration [Int]InvScale {
    /// 逆缩放（用于运算符 lowering: Duration / Int）
    public unscale(self, k Int) Duration = {
        let total_nanos = self.as_nanoseconds() / (Int64)k
        let secs = total_nanos / 1_000_000_000
        let nanos = total_nanos % 1_000_000_000
        return Duration(secs, nanos)
    }
}

given Duration Eq {
    /// 相等比较
    public equals(self, other Duration) Bool =
        self.secs == other.secs and self.nanos == other.nanos
}

given Duration Ord {
    /// 三路比较
    /// 返回: -1 (self < other), 0 (self == other), 1 (self > other)
    public compare(self, other Duration) Int = {
        if self.secs < other.secs then {
            return -1
        } else if self.secs > other.secs then {
            return 1
        } else if self.nanos < other.nanos then {
            return -1
        } else if self.nanos > other.nanos then {
            return 1
        } else {
            return 0
        }
    }
}

given Duration ToString {
    /// 转换为可读字符串
    /// 格式: "1d2h", "1h30min", "500ms", "100ns"
    public to_string(self) String = {
        if self.secs >= 86400 then {
            let days = self.secs / 86400
            let remaining_secs = self.secs % 86400
            if remaining_secs >= 3600 then {
                let hours = remaining_secs / 3600
                let mut result = String.zero()
                result.push_string(days.to_string())
                result.push_string("d")
                result.push_string(hours.to_string())
                result.push_string("h")
                return result
            } else if remaining_secs >= 60 then {
                let mins = remaining_secs / 60
                let mut result = String.zero()
                result.push_string(days.to_string())
                result.push_string("d")
                result.push_string(mins.to_string())
                result.push_string("min")
                return result
            } else if remaining_secs > 0 then {
                let mut result = String.zero()
                result.push_string(days.to_string())
                result.push_string("d")
                result.push_string(remaining_secs.to_string())
                result.push_string("s")
                return result
            } else {
                let mut result = String.zero()
                result.push_string(days.to_string())
                result.push_string("d")
                return result
            }
        } else if self.secs >= 3600 then {
            let hours = self.secs / 3600
            let remaining_secs = self.secs % 3600
            if remaining_secs >= 60 then {
                let mins = remaining_secs / 60
                let mut result = String.zero()
                result.push_string(hours.to_string())
                result.push_string("h")
                result.push_string(mins.to_string())
                result.push_string("min")
                return result
            } else if remaining_secs > 0 then {
                let mut result = String.zero()
                result.push_string(hours.to_string())
                result.push_string("h")
                result.push_string(remaining_secs.to_string())
                result.push_string("s")
                return result
            } else {
                let mut result = String.zero()
                result.push_string(hours.to_string())
                result.push_string("h")
                return result
            }
        } else if self.secs >= 60 then {
            let mins = self.secs / 60
            let remaining_secs = self.secs % 60
            if remaining_secs > 0 then {
                let mut result = String.zero()
                result.push_string(mins.to_string())
                result.push_string("min")
                result.push_string(remaining_secs.to_string())
                result.push_string("s")
                return result
            } else {
                let mut result = String.zero()
                result.push_string(mins.to_string())
                result.push_string("min")
                return result
            }
        } else if self.secs > 0 then {
            if self.nanos > 0 then {
                let mut result = String.zero()
                result.push_string(self.secs.to_string())
                result.push_string("s")
                result.push_string(self.nanos.to_string())
                result.push_string("ns")
                return result
            } else {
                let mut result = String.zero()
                result.push_string(self.secs.to_string())
                result.push_string("s")
                return result
            }
        } else if self.nanos >= 1_000_000 then {
            let mut result = String.zero()
            result.push_string((self.nanos / 1_000_000).to_string())
            result.push_string("ms")
            return result
        } else if self.nanos >= 1_000 then {
            let mut result = String.zero()
            result.push_string((self.nanos / 1_000).to_string())
            result.push_string("us")
            return result
        } else {
            let mut result = String.zero()
            result.push_string(self.nanos.to_string())
            result.push_string("ns")
            return result
        }
    }
}

// ============================================================================
// Sleep API (__koral_nanosleep runtime)
// ============================================================================

// FFI 结构体：与 C timespec 布局对齐
foreign type KoralTimespec(tv_sec Int64, tv_nsec Int64)

// FFI 函数声明
// Runtime 提供 __koral_nanosleep，避免与系统 nanosleep 冲突
foreign let __koral_nanosleep(req KoralTimespec ptr, rem KoralTimespec ptr) Int32

/// 休眠指定时间
public let sleep(d Duration) Void = {
    if d.secs < 0 or d.nanos < 0 then {
        panic("sleep: negative duration")
    }

    let mut secs = d.secs
    let mut nanos = d.nanos
    if nanos >= 1_000_000_000 then {
        let extra = nanos / 1_000_000_000
        secs = secs + extra
        nanos = nanos % 1_000_000_000
    }

    let ts = KoralTimespec(secs, nanos)
    let _ = __koral_nanosleep(ptr ts, [KoralTimespec]null_ptr())
}
