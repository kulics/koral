// ============================================================================
// std.sync - Mutex (Bare Lock) + MutexCondvar (Condition Variable)
// ============================================================================
// Provides: Mutex (bare lock), MutexCondvar (condition variable bound to Mutex)
// Access via: using std.sync
// ============================================================================
// Design: Go-style bare lock — Mutex does not bind data, only provides
// lock/unlock. Programmers are responsible for accessing shared data correctly
// between lock() and unlock() calls.
// ============================================================================

// ============================================================================
// FFI Declarations
// ============================================================================
foreign let __koral_mutex_create() UInt8 ptr
foreign let __koral_mutex_destroy(mutex UInt8 ptr) Void
foreign let __koral_mutex_lock(mutex UInt8 ptr) Void
foreign let __koral_mutex_try_lock(mutex UInt8 ptr) Int32
foreign let __koral_mutex_unlock(mutex UInt8 ptr) Void
foreign let __koral_condvar_create() UInt8 ptr
foreign let __koral_condvar_destroy(cv UInt8 ptr) Void
foreign let __koral_condvar_wait(cv UInt8 ptr, mutex UInt8 ptr) Void
foreign let __koral_condvar_signal(cv UInt8 ptr) Void
foreign let __koral_condvar_broadcast(cv UInt8 ptr) Void

// ============================================================================
// Mutex Internal Storage
// ============================================================================
private type MutexStorage(handle UInt8 ptr)

given MutexStorage {
    __drop(self ref) Void = {
        __koral_mutex_destroy(self.handle)
    }
}

// ============================================================================
// Mutex Type
// ============================================================================

/// 互斥锁（裸锁）
/// 不绑定数据，程序员负责在 lock/unlock 之间访问共享数据
public type Mutex(private storage MutexStorage ref)

given Mutex {
    /// 创建互斥锁
    public new() Mutex = {
        Mutex(ref MutexStorage(__koral_mutex_create()))
    }

    /// 获取锁（阻塞直到成功）
    public lock(self) Void = {
        __koral_mutex_lock(self.storage.handle)
    }

    /// 尝试获取锁（非阻塞），成功返回 true，锁被占用返回 false
    public try_lock(self) Bool = {
        __koral_mutex_try_lock(self.storage.handle) == 1
    }

    /// 释放锁
    public unlock(self) Void = {
        __koral_mutex_unlock(self.storage.handle)
    }

    /// 创建绑定到此互斥锁的条件变量
    public condvar(self) MutexCondvar = {
        MutexCondvar(ref MutexCondvarStorage(
            __koral_condvar_create(),
            self
        ))
    }
}


// ============================================================================
// MutexCondvar Type (Condition Variable bound to Mutex)
// ============================================================================

private type MutexCondvarStorage(
    handle UInt8 ptr,
    mutex Mutex,
)

given MutexCondvarStorage {
    __drop(self ref) Void = {
        __koral_condvar_destroy(self.handle)
    }
}

/// 绑定到 Mutex 的条件变量
/// 由 Mutex.condvar() 创建，wait() 自动释放绑定的 Mutex 并等待，被唤醒后重新获取
public type MutexCondvar(private storage MutexCondvarStorage ref)

given MutexCondvar {
    /// 释放绑定的 Mutex 并等待通知，被唤醒后重新获取 Mutex
    /// 调用前必须持有绑定的 Mutex，否则行为未定义
    /// 注意：必须在 while 循环中检查条件谓词（防止虚假唤醒）
    public wait(self) Void = {
        __koral_condvar_wait(self.storage.handle, self.storage.mutex.storage.handle)
    }

    /// 唤醒一个等待中的线程
    public notify(self) Void = {
        __koral_condvar_signal(self.storage.handle)
    }

    /// 唤醒所有等待中的线程
    public notify_all(self) Void = {
        __koral_condvar_broadcast(self.storage.handle)
    }
}