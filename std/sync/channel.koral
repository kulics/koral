// ============================================================================
// std.sync - Channel (Message Passing)
// ============================================================================
// Provides: make_channel factory, Sender, Receiver
// Access via: using std.sync
// ============================================================================
// Design: Pure Koral implementation using Mutex + MutexCondvar + List.
// Bounded channel only — forces users to think about capacity (backpressure).
// Multi-producer multi-consumer via ref counting on SenderStorage/ReceiverStorage.
// ============================================================================

// ============================================================================
// Channel — Implemented with Koral primitives, no additional FFI needed
// ============================================================================

// Channel internal shared storage
private type [T Any]ChannelStorage(
    mutex Mutex,
    not_empty MutexCondvar,          // notify consumer: new message available
    not_full MutexCondvar,           // notify producer: space available
    mut queue [T]List,          // message queue
    capacity UInt,              // buffer size
    mut sender_closed Bool,     // all Senders have been dropped
    mut receiver_closed Bool,   // Receiver has been dropped
)

// ============================================================================
// SenderStorage / ReceiverStorage (intermediate ref layer, tracks holder count)
// ============================================================================

private type [T Any]SenderStorage(channel [T]ChannelStorage ref)

given[T Any] [T]SenderStorage {
    __drop(self ref) Void = {
        self.channel.mutex.lock()
        self.channel.sender_closed = true
        self.channel.not_empty.notify_all()
        self.channel.mutex.unlock()
    }
}

private type [T Any]ReceiverStorage(channel [T]ChannelStorage ref)

given[T Any] [T]ReceiverStorage {
    __drop(self ref) Void = {
        self.channel.mutex.lock()
        self.channel.receiver_closed = true
        self.channel.not_full.notify_all()
        self.channel.mutex.unlock()
    }
}

// ============================================================================
// Factory Function
// ============================================================================

/// 创建有界通道，返回 Sender 和 Receiver 的 Pair
/// capacity == 0 时为同步通道（rendezvous channel）：send 阻塞直到有 recv，recv 阻塞直到有 send
public let [T Any]make_channel(capacity UInt) [[T]Sender, [T]Receiver]Pair = {
    let mu = Mutex.new()
    let not_empty = mu.condvar()
    let not_full = mu.condvar()
    let storage = ref [T]ChannelStorage(
        mu, not_empty, not_full,
        [T]List.new(),
        capacity,
        false, false
    )
    [[T]Sender, [T]Receiver]Pair(
        [T]Sender(ref [T]SenderStorage(storage)),
        [T]Receiver(ref [T]ReceiverStorage(storage))
    )
}

// ============================================================================
// Sender Type
// ============================================================================

public type [T Any]Sender(private storage [T]SenderStorage ref)

given[T Any] [T]Sender {
    /// 发送消息（阻塞，直到有空间或通道关闭）
    public send(self, value T) [Void]Result = {
        self.storage.channel.mutex.lock()
        while self.storage.channel.queue.count() >= self.storage.channel.capacity
              and not self.storage.channel.receiver_closed then {
            self.storage.channel.not_full.wait()
        }
        if self.storage.channel.receiver_closed then {
            self.storage.channel.mutex.unlock()
            return [Void]Result.Error(ref "channel closed")
        }
        self.storage.channel.queue.push(value)
        self.storage.channel.not_empty.notify()
        self.storage.channel.mutex.unlock()
        [Void]Result.Ok({})
    }

    /// 非阻塞发送
    public try_send(self, value T) [Bool]Result = {
        self.storage.channel.mutex.lock()
        if self.storage.channel.receiver_closed then {
            self.storage.channel.mutex.unlock()
            return [Bool]Result.Error(ref "channel closed")
        }
        if self.storage.channel.queue.count() >= self.storage.channel.capacity then {
            self.storage.channel.mutex.unlock()
            return [Bool]Result.Ok(false)
        }
        self.storage.channel.queue.push(value)
        self.storage.channel.not_empty.notify()
        self.storage.channel.mutex.unlock()
        [Bool]Result.Ok(true)
    }
}

// ============================================================================
// Receiver Type
// ============================================================================

public type [T Any]Receiver(private storage [T]ReceiverStorage ref)

given[T Any] [T]Receiver {
    /// 接收消息（阻塞，直到有消息或通道关闭）
    public recv(self) [T]Result = {
        self.storage.channel.mutex.lock()
        while self.storage.channel.queue.is_empty() and not self.storage.channel.sender_closed then {
            self.storage.channel.not_empty.wait()
        }
        if not self.storage.channel.queue.is_empty() then {
            let value = self.storage.channel.queue.remove(0)
            self.storage.channel.not_full.notify()
            self.storage.channel.mutex.unlock()
            return [T]Result.Ok(value)
        }
        self.storage.channel.mutex.unlock()
        [T]Result.Error(ref "channel closed")
    }

    /// 非阻塞接收
    public try_recv(self) [[T]Option]Result = {
        self.storage.channel.mutex.lock()
        if not self.storage.channel.queue.is_empty() then {
            let value = self.storage.channel.queue.remove(0)
            self.storage.channel.not_full.notify()
            self.storage.channel.mutex.unlock()
            return [[T]Option]Result.Ok([T]Option.Some(value))
        }
        if self.storage.channel.sender_closed then {
            self.storage.channel.mutex.unlock()
            return [[T]Option]Result.Error(ref "channel closed")
        }
        self.storage.channel.mutex.unlock()
        [[T]Option]Result.Ok([T]Option.None())
    }
}
