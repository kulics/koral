// ============================================================================
// std.sync - Channel (Message Passing)
// ============================================================================
// Provides: Channel, SendChannel, RecvChannel
// Access via: using std.sync
// ============================================================================
// Design: Pure Koral implementation using Mutex + MutexCondvar + List.
// Bounded channel only — forces users to think about capacity (backpressure).
// Multi-producer multi-consumer via ref counting on SendChannelStorage/RecvChannelStorage.
// ============================================================================

// ============================================================================
// Channel — Implemented with Koral primitives, no additional FFI needed
// ============================================================================

// Channel internal shared storage
private type [T Any]ChannelStorage(
    mutex Mutex,
    not_empty MutexCondvar,          // notify consumer: new message available
    not_full MutexCondvar,           // notify producer: space available
    mut queue [T]List,          // message queue
    capacity UInt,              // buffer size
    mut sender_closed Bool,     // all SendChannels have been dropped
    mut receiver_closed Bool,   // all RecvChannels have been dropped
)

// ============================================================================
// SendChannelStorage / RecvChannelStorage (intermediate ref layer, tracks holder count)
// ============================================================================

private type [T Any]SendChannelStorage(channel [T]ChannelStorage ref)

given[T Any] [T]SendChannelStorage {
    __drop(self ref) Void = {
        self.channel.mutex.lock()
        defer self.channel.mutex.unlock()
        self.channel.sender_closed = true
        self.channel.not_empty.notify_all()
    }
}

private type [T Any]RecvChannelStorage(channel [T]ChannelStorage ref)

given[T Any] [T]RecvChannelStorage {
    __drop(self ref) Void = {
        self.channel.mutex.lock()
        defer self.channel.mutex.unlock()
        self.channel.receiver_closed = true
        self.channel.not_full.notify_all()
    }
}

// ============================================================================
// SendChannel Type
// ============================================================================

public type [T Any]SendChannel(private storage [T]SendChannelStorage ref)

given[T Any] [T]SendChannel {
    /// 发送消息（阻塞，直到有空间或通道关闭）
    public send(self, value T) [Void]Result = {
        self.storage.channel.mutex.lock()
        defer self.storage.channel.mutex.unlock()
        while self.storage.channel.queue.count() >= self.storage.channel.capacity
              and not self.storage.channel.receiver_closed then {
            self.storage.channel.not_full.wait()
        }
        if self.storage.channel.receiver_closed then {
            return [Void]Result.Error(ref "channel closed")
        }
        self.storage.channel.queue.push(value)
        self.storage.channel.not_empty.notify()
        [Void]Result.Ok({})
    }

    /// 非阻塞发送
    public try_send(self, value T) [Bool]Result = {
        self.storage.channel.mutex.lock()
        defer self.storage.channel.mutex.unlock()
        if self.storage.channel.receiver_closed then {
            return [Bool]Result.Error(ref "channel closed")
        }
        if self.storage.channel.queue.count() >= self.storage.channel.capacity then {
            return [Bool]Result.Ok(false)
        }
        self.storage.channel.queue.push(value)
        self.storage.channel.not_empty.notify()
        [Bool]Result.Ok(true)
    }
}

// ============================================================================
// RecvChannel Type
// ============================================================================

public type [T Any]RecvChannel(private storage [T]RecvChannelStorage ref)

given[T Any] [T]RecvChannel {
    /// 接收消息（阻塞，直到有消息或通道关闭）
    public recv(self) [T]Result = {
        self.storage.channel.mutex.lock()
        defer self.storage.channel.mutex.unlock()
        while self.storage.channel.queue.is_empty() and not self.storage.channel.sender_closed then {
            self.storage.channel.not_empty.wait()
        }
        if not self.storage.channel.queue.is_empty() then {
            let value = self.storage.channel.queue.remove(0)
            self.storage.channel.not_full.notify()
            return [T]Result.Ok(value)
        }
        [T]Result.Error(ref "channel closed")
    }

    /// 非阻塞接收
    public try_recv(self) [[T]Option]Result = {
        self.storage.channel.mutex.lock()
        defer self.storage.channel.mutex.unlock()
        if not self.storage.channel.queue.is_empty() then {
            let value = self.storage.channel.queue.remove(0)
            self.storage.channel.not_full.notify()
            return [[T]Option]Result.Ok([T]Option.Some(value))
        }
        if self.storage.channel.sender_closed then {
            return [[T]Option]Result.Error(ref "channel closed")
        }
        [[T]Option]Result.Ok([T]Option.None())
    }
}

// ============================================================================
// Channel Type (unified entry point)
// ============================================================================

/// 类型安全的消息传递通道
/// 值类型，内部持有 SendChannel 和 RecvChannel
/// 提供 send/recv 等方法直接操作，也可通过 sender()/receiver() 拆分使用
public type [T Any]Channel(
    private send_ch [T]SendChannel,
    private recv_ch [T]RecvChannel,
)

given[T Any] [T]Channel {
    /// 创建同步通道（capacity=0，rendezvous channel）
    /// send 阻塞直到有 recv，recv 阻塞直到有 send
    public new() [T]Channel = {
        [T]Channel.with_capacity(0)
    }

    /// 创建有界通道
    /// capacity == 0 时为同步通道
    public with_capacity(capacity UInt) [T]Channel = {
        let mu = Mutex.new()
        let not_empty = mu.condvar()
        let not_full = mu.condvar()
        let storage = ref [T]ChannelStorage(
            mu, not_empty, not_full,
            [T]List.new(),
            capacity,
            false, false
        )
        [T]Channel(
            [T]SendChannel(ref [T]SendChannelStorage(storage)),
            [T]RecvChannel(ref [T]RecvChannelStorage(storage))
        )
    }

    /// 获取发送端
    public sender(self) [T]SendChannel = self.send_ch

    /// 获取接收端
    public receiver(self) [T]RecvChannel = self.recv_ch

    /// 发送消息（转发给内部 SendChannel）
    public send(self, value T) [Void]Result = self.send_ch.send(value)

    /// 非阻塞发送（转发给内部 SendChannel）
    public try_send(self, value T) [Bool]Result = self.send_ch.try_send(value)

    /// 接收消息（转发给内部 RecvChannel）
    public recv(self) [T]Result = self.recv_ch.recv()

    /// 非阻塞接收（转发给内部 RecvChannel）
    public try_recv(self) [[T]Option]Result = self.recv_ch.try_recv()
}