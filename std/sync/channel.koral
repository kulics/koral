// ============================================================================
// std.sync - channel (Message Passing)
// ============================================================================
// Provides: make_channel, SendChannel, RecvChannel
// Access via: using std.sync
// ============================================================================
// Design: Pure Koral implementation using Mutex + MutexCondvar + List.
// Bounded channel only — forces users to think about capacity (backpressure).
// Multi-producer multi-consumer via ref counting on SendChannelStorage/RecvChannelStorage.
// ============================================================================

// ============================================================================
// channel internals — Implemented with Koral primitives, no additional FFI needed
// ============================================================================

// channel internal shared storage
private type [T Any]ChannelStorage(
    mutex Mutex,
    not_empty MutexCondvar,          // notify consumer: new message available
    not_full MutexCondvar,           // notify producer: space available
    mut queue [T]List,          // message queue
    capacity UInt,              // buffer size
    mut sender_closed Bool,     // all SendChannels have been dropped
    mut receiver_closed Bool,   // all RecvChannels have been dropped
)

// ============================================================================
// SendChannelStorage / RecvChannelStorage (intermediate ref layer, tracks holder count)
// ============================================================================

private type [T Any]SendChannelStorage(channel [T]ChannelStorage ref)

given[T Any] [T]SendChannelStorage {
    __drop(self ref) Void = {
        self.channel.mutex.lock()
        defer self.channel.mutex.unlock()
        self.channel.sender_closed = true
        self.channel.not_empty.notify_all()
    }
}

private type [T Any]RecvChannelStorage(channel [T]ChannelStorage ref)

given[T Any] [T]RecvChannelStorage {
    __drop(self ref) Void = {
        self.channel.mutex.lock()
        defer self.channel.mutex.unlock()
        self.channel.receiver_closed = true
        self.channel.not_full.notify_all()
    }
}

// ============================================================================
// SendChannel Type
// ============================================================================

public type [T Any]SendChannel(private storage [T]SendChannelStorage ref)

given[T Any] [T]SendChannel {
    /// 发送消息（阻塞，直到有空间或通道关闭）
    public send(self, value T) [Void]Result = {
        self.storage.channel.mutex.lock()
        defer self.storage.channel.mutex.unlock()
        while self.storage.channel.queue.count() >= self.storage.channel.capacity
              and not self.storage.channel.receiver_closed then {
            self.storage.channel.not_full.wait()
        }
        if self.storage.channel.receiver_closed then {
            return [Void]Result.Error(ref "channel closed")
        }
        self.storage.channel.queue.push(value)
        self.storage.channel.not_empty.notify()
        return [Void]Result.Ok({})
    }

    /// 非阻塞发送
    public try_send(self, value T) [Bool]Result = {
        self.storage.channel.mutex.lock()
        defer self.storage.channel.mutex.unlock()
        if self.storage.channel.receiver_closed then {
            return [Bool]Result.Error(ref "channel closed")
        }
        if self.storage.channel.queue.count() >= self.storage.channel.capacity then {
            return [Bool]Result.Ok(false)
        }
        self.storage.channel.queue.push(value)
        self.storage.channel.not_empty.notify()
        return [Bool]Result.Ok(true)
    }
}

// ============================================================================
// RecvChannel Type
// ============================================================================

public type [T Any]RecvChannel(private storage [T]RecvChannelStorage ref)

given[T Any] [T]RecvChannel {
    /// 接收消息（阻塞，直到有消息或通道关闭）
    public recv(self) [T]Result = {
        self.storage.channel.mutex.lock()
        defer self.storage.channel.mutex.unlock()
        while self.storage.channel.queue.is_empty() and not self.storage.channel.sender_closed then {
            self.storage.channel.not_empty.wait()
        }
        if not self.storage.channel.queue.is_empty() then {
            let value = self.storage.channel.queue.remove(0)
            self.storage.channel.not_full.notify()
            return [T]Result.Ok(value)
        }
        return [T]Result.Error(ref "channel closed")
    }

    /// 非阻塞接收
    public try_recv(self) [[T]Option]Result = {
        self.storage.channel.mutex.lock()
        defer self.storage.channel.mutex.unlock()
        if not self.storage.channel.queue.is_empty() then {
            let value = self.storage.channel.queue.remove(0)
            self.storage.channel.not_full.notify()
            return [[T]Option]Result.Ok([T]Option.Some(value))
        }
        if self.storage.channel.sender_closed then {
            return [[T]Option]Result.Error(ref "channel closed")
        }
        return [[T]Option]Result.Ok([T]Option.None())
    }
}

// ============================================================================
// Channel Factory
// ============================================================================

/// 类型安全的消息传递通道工厂。
/// 返回 (SendChannel, RecvChannel) 对，避免统一 Channel 类型带来的误用。
public let [T Any]make_channel(capacity UInt) [[T]SendChannel, [T]RecvChannel]Pair = {
    let mu = Mutex.new()
    let not_empty = mu.condvar()
    let not_full = mu.condvar()
    let storage = ref [T]ChannelStorage(
        mu, not_empty, not_full,
        [T]List.new(),
        capacity,
        false, false
    )
    let sender = [T]SendChannel(ref [T]SendChannelStorage(storage))
    let receiver = [T]RecvChannel(ref [T]RecvChannelStorage(storage))
    return [[T]SendChannel, [T]RecvChannel]Pair(sender, receiver)
}