// ============================================================================
// Koral Formatter - CLI Entry Point
// ============================================================================
// Usage: koral-fmt [--check] <file1.koral> [file2.koral ...]
// ============================================================================

using "tokenizer"
using "parser"
using "printer"

using std.os.*

// ============================================================================
// CLI Entry Point
// ============================================================================

let main() Void = {
    let arguments = args()

    if arguments.count() <= 1 then {
        print_usage()
        exit(1)
    }

    let mut check_mode = false
    let mut files = [String]List.new()
    let mut i UInt = 1

    while i < arguments.count() then {
        let arg = arguments[i]
        if arg == "--check" then {
            check_mode = true
        } else if arg == "--help" or arg == "-h" then {
            print_usage()
            exit(0)
        } else {
            files.push(arg)
        }
        i += 1
    }

    if files.count() == 0 then {
        print_error_line("Error: no input files specified")
        print_usage()
        exit(1)
    }

    let mut had_error = false
    let mut j UInt = 0

    while j < files.count() then {
        let path = files[j]
        if check_mode then {
            when check_file(path) is {
                .Ok(is_formatted) then {
                    if not is_formatted then {
                        print_error_line("\(path): not formatted")
                        had_error = true
                    }
                },
                .Error(e) then {
                    print_error_line("Error: \(path): \(e.message())")
                    had_error = true
                },
            }
        } else {
            when format_file(path) is {
                .Ok(_) then {},
                .Error(e) then {
                    print_error_line("Error: \(path): \(e.message())")
                    had_error = true
                },
            }
        }
        j += 1
    }

    if had_error then { exit(1) }
}

// ============================================================================
// File Operations
// ============================================================================

let format_file(path String) [Void]Result = {
    let source = read_text(path) or else { return [Void]Result.Error(_) }
    let normalized = normalize_newlines(source)
    let formatted = safe_format_source(normalized) or else { return [Void]Result.Error(_) }

    if formatted == source then {
        [Void]Result.Ok({})
    } else {
        write_text(path, formatted)
    }
}

let check_file(path String) [Bool]Result = {
    let source = read_text(path) or else { return [Bool]Result.Error(_) }
    let normalized = normalize_newlines(source)
    let formatted = safe_format_source(normalized) or else { return [Bool]Result.Error(_) }
    return [Bool]Result.Ok(formatted == normalized)
}

let safe_format_source(source String) [String]Result = {
    let first_pass = format_source(source) or else { return [String]Result.Error(_) }
    let before_sig = comment_signature(source) or else { return [String]Result.Error(_) }
    let after_sig = comment_signature(first_pass) or else { return [String]Result.Error(_) }

    if before_sig <> after_sig then {
        return .Error(ref "Formatter internal error: comment signature changed after formatting")
    }

    let second_pass = format_source(first_pass) or else { return [String]Result.Error(_) }
    if first_pass == second_pass then { .Ok(first_pass) }
    else { .Error(ref "Formatter internal error: formatting is not idempotent") }
}

let normalize_newlines(source String) String = {
    if not source.contains("\r") then {
        return source
    }

    let runes = source.to_runes()
    let mut out = String.new()
    let mut i UInt = 0

    while i < runes.count() then {
        let r = runes[i]
        if r == '\r' then {
            out.push('\n')
            if i + 1 < runes.count() and runes[i + 1] == '\n' then {
                i += 2
            } else {
                i += 1
            }
            continue
        }

        out.push_string(r.to_string())
        i += 1
    }

    out
}

let comment_signature(source String) [String]Result = {
    let mut tokenizer = Tokenizer.new(source)
    when tokenizer.tokenize() is {
        .Ok(tokens) then {
            let mut out = String.new()
            let mut i UInt = 0
            while i < tokens.count() then {
                when tokens[i] is {
                    .LineComment(text) then {
                        out.push_string(text)
                        out.push_string("\n@@\n")
                    },
                    .BlockComment(text) then {
                        out.push_string(text)
                        out.push_string("\n@@\n")
                    },
                    _ then {},
                }
                i += 1
            }
            return .Ok(out)
        },
        .Error(e) then .Error(e),
    }
}

// ============================================================================
// Usage
// ============================================================================

let print_usage() Void = {
    print_error_line("Usage: koral-fmt [--check] <file1.koral> [file2.koral ...]")
    print_error_line("")
    print_error_line("Options:")
    print_error_line("  --check    Check if files are formatted (exit 1 if not)")
    print_error_line("  --help     Show this help message")
}
