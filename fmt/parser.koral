// ============================================================================
// Koral Formatter - Fully Structured CST Parser
// ============================================================================
// CST preserves all tokens (keywords, delimiters) for exact reproduction,
// but parses full structure like an AST so the printer needs zero spacing inference.
// ============================================================================

// ============================================================================
// CST Type Nodes
// ============================================================================

public type CstType {
    Named(name Token),
    SelfType(kw Token),
    Generic(lbracket Token, args [CstTypeArg]List, rbracket Token, base Token),
    Ref(inner CstType ref, kw Token),
    Ptr(inner CstType ref, kw Token),
    Weakref(inner CstType ref, kw Token),
}

// A type argument with optional trailing comma
public type CstTypeArg(inner CstType ref, comma [Token]Option)

// ============================================================================
// CST Expression Nodes
// ============================================================================

public type CstExpr {
    // Literals
    IntLit(token Token),
    FloatLit(token Token),
    StrLit(token Token),
    InterpStr(token Token),
    BoolLit(token Token),
    Ident(token Token),
    SelfExpr(token Token),
    UnderscoreExpr(token Token),
    Commented(comments [Token]List, inner CstExpr ref),

    // Operators
    BinaryOp(left CstExpr ref, op Token, right CstExpr ref),
    UnaryMinus(op Token, operand CstExpr ref),
    NotExpr(op Token, operand CstExpr ref),
    BitwiseNot(op Token, operand CstExpr ref),
    PrefixKw(kw Token, operand CstExpr ref),
    TypeCast(lparen Token, cast_type CstType ref, rparen Token, operand CstExpr ref),
    Paren(lparen Token, inner CstExpr ref, rparen Token),

    // Access and calls
    FieldAccess(base CstExpr ref, dot Token, field Token),
    Call(callee CstExpr ref, lparen Token, args [CstCallArg]List, rparen Token),
    SubscriptExpr(base CstExpr ref, lbracket Token, args [CstCallArg]List, rbracket Token),
    GenericInst(lbracket Token, type_args [CstTypeArg]List, rbracket Token, name Token),
    ImplicitMember(dot Token, name Token, lparen [Token]Option, args [CstCallArg]List, rparen [Token]Option),

    // Control flow
    Block(lbrace Token, items [CstItem ref]List, rbrace Token),
    If(kw Token, cond CstExpr ref, then_kw Token, then_body CstExpr ref,
       else_kw [Token]Option, else_body [CstExpr ref]Option),
    IfPattern(kw Token, subject CstExpr ref, is_kw Token, pattern CstPattern ref,
              then_kw Token, then_body CstExpr ref,
              else_kw [Token]Option, else_body [CstExpr ref]Option),
    While(kw Token, cond CstExpr ref, then_kw Token, body CstExpr ref),
    WhilePattern(kw Token, subject CstExpr ref, is_kw Token, pattern CstPattern ref,
                 then_kw Token, body CstExpr ref),
    For(kw Token, binding CstPattern ref, eq Token, iterable CstExpr ref,
        then_kw Token, body CstExpr ref),
    When(kw Token, subject CstExpr ref, is_kw Token,
         lbrace Token, arms [CstWhenArm ref]List, rbrace Token),

    // Chaining
    AndThen(left CstExpr ref, and_kw Token, then_kw Token, right CstExpr ref),
    OrElse(left CstExpr ref, or_kw Token, else_kw Token, right CstExpr ref),

    // Range
    RangeExpr(left [CstExpr ref]Option, op Token, right [CstExpr ref]Option),

    // Lambda
    Lambda(lparen Token, params [CstLambdaParam]List, rparen Token,
           ret_type [CstType ref]Option, arrow Token, body CstExpr ref),

    // Union variant declaration in type union body
    UnionVariant(name Token, lparen [Token]Option, fields [CstUnionField]List, rparen [Token]Option),
}

// Call argument with optional trailing comma
public type CstCallArg(value CstExpr ref, comma [Token]Option)

// Lambda parameter
public type CstLambdaParam(name Token, param_type [CstType ref]Option, comma [Token]Option)

// Union variant field: Name(Type) as `fieldName FieldType`
public type CstUnionField(name Token, field_type CstType ref, comma [Token]Option)

// ============================================================================
// CST Pattern Nodes
// ============================================================================

public type CstPattern {
    Wildcard(token Token),
    Variable(name Token),
    MutVariable(mut_kw Token, name Token),
    PatIntLit(token Token),
    NegIntLit(minus Token, token Token),
    PatStrLit(token Token),
    PatBoolLit(token Token),
    UnionCase(dot Token, name Token, lparen [Token]Option, args [CstPatternArg]List, rparen [Token]Option),
    StructPattern(name Token, lparen Token, args [CstPatternArg]List, rparen Token),
    Comparison(op Token, value Token),
    AndPattern(left CstPattern ref, and_kw Token, right CstPattern ref),
    OrPattern(left CstPattern ref, or_kw Token, right CstPattern ref),
    NotPattern(not_kw Token, inner CstPattern ref),
    ParenPattern(lparen Token, inner CstPattern ref, rparen Token),
}

public type CstPatternArg(pattern CstPattern ref, comma [Token]Option)

// ============================================================================
// CST When Arm
// ============================================================================

public type CstWhenArm(
    pattern CstPattern ref,
    then_kw Token,
    body CstExpr ref,
    comma [Token]Option,
)

// ============================================================================
// CST Parameter and Generic Parameter
// ============================================================================

public type CstParam {
    SelfParam(kw Token, ref_kw [Token]Option, comma [Token]Option),
    NamedParam(name Token, mut_kw [Token]Option, param_type CstType ref, comma [Token]Option),
}

public type CstGenericParam(
    name Token,
    constraints [CstType ref]List,
    comma [Token]Option,
)

public type CstGenericParams(
    lbracket Token,
    params [CstGenericParam]List,
    rbracket Token,
)

// ============================================================================
// CST Statements
// ============================================================================

public type CstStmt {
    VarDecl(let_kw Token, mut_kw [Token]Option, name Token,
            var_type [CstType ref]Option, eq Token, value CstExpr ref),
    Assignment(target CstExpr ref, op Token, value CstExpr ref),
    ExprStmt(expr CstExpr ref, semi [Token]Option),
    Return(kw Token, value [CstExpr ref]Option),
    Break(kw Token),
    Continue(kw Token),
}

// ============================================================================
// CST Type Body (for type declarations)
// ============================================================================

public type CstTypeBody {
    Struct(lparen Token, fields [CstStructField]List, rparen Token),
    Union(lbrace Token, cases [CstItem ref]List, rbrace Token),
    Alias(eq Token, target CstType ref),
    Empty(),
}

public type CstStructField(
    mut_kw [Token]Option,
    access [Token]Option,
    name Token,
    field_type CstType ref,
    comma [Token]Option,
)

// ============================================================================
// CST Declarations
// ============================================================================

public type CstDecl {
    Using(tokens [Token]List),
    ForeignUsing(foreign_kw Token, tokens [Token]List),
    Func(
        vis [Token]Option,
        modifiers [Token]List,
        let_kw [Token]Option,
        mut_kw [Token]Option,
        generic_params [CstGenericParams ref]Option,
        name [Token]Option,
        lparen [Token]Option,
        params [CstParam]List,
        rparen [Token]Option,
        return_type [CstType ref]Option,
        eq Token,
        body CstExpr ref
    ),
    ForeignDecl(
        vis [Token]Option,
        modifiers [Token]List,
        let_kw [Token]Option,
        mut_kw [Token]Option,
        generic_params [CstGenericParams ref]Option,
        name [Token]Option,
        lparen [Token]Option,
        params [CstParam]List,
        rparen [Token]Option,
        return_type [CstType ref]Option
    ),
    Type(
        vis [Token]Option,
        modifiers [Token]List,
        kw Token,
        generic_params [CstGenericParams ref]Option,
        name Token,
        body CstTypeBody ref
    ),
    Trait(
        vis [Token]Option,
        kw Token,
        generic_params [CstGenericParams ref]Option,
        name Token,
        super_traits [CstType ref]List,
        lbrace Token,
        members [CstItem ref]List,
        rbrace Token
    ),
    Given(
        vis [Token]Option,
        modifiers [Token]List,
        kw Token,
        generic_params [CstGenericParams ref]Option,
        target CstType ref,
        lbrace Token,
        members [CstItem ref]List,
        rbrace Token
    ),
    Var(
        vis [Token]Option,
        let_kw Token,
        mut_kw [Token]Option,
        name Token,
        var_type [CstType ref]Option
    ),
    TraitMethod(
        vis [Token]Option,
        generic_params [CstGenericParams ref]Option,
        name Token,
        lparen Token,
        params [CstTraitMethodParam]List,
        rparen Token,
        return_type [CstType ref]Option
    ),
}

// Trait method parameter
public type CstTraitMethodParam {
    // self
    SelfParam(kw Token, comma [Token]Option),
    // self ref
    SelfRefParam(kw Token, ref_kw Token, comma [Token]Option),
    // name Type
    NamedParam(name Token, param_type CstType ref, comma [Token]Option),
}

// ============================================================================
// CST Item and File
// ============================================================================

public type CstItem {
    Decl(decl CstDecl ref),
    Stmt(stmt CstStmt ref),
    Comment(token Token),
    TrailingComment(token Token),
    BlankLine(),
}

public type CstFile(items [CstItem ref]List)


// ============================================================================
// CstParser
// ============================================================================

public type CstParser(
    tokens [Token]List,
    mut pos UInt,
)

given CstParser {
    public new(tokens [Token]List) CstParser = CstParser(tokens, 0)

    // ========================================================================
    // Token helpers
    // ========================================================================

    private peek(self) Token = {
        let mut i = self.pos
        while i < self.tokens.count() then {
            when self.tokens[i] is {
                .Newline then { i += 1; continue },
                _ then { return self.tokens[i] },
            }
        }
        Token.EOF()
    }

    private peek_raw(self) Token = {
        if self.pos >= self.tokens.count() then { return .EOF() }
        self.tokens[self.pos]
    }

    private advance(self ref) Token = {
        if self.pos >= self.tokens.count() then { return .EOF() }
        let tok = self.tokens[self.pos]
        self.pos += 1
        tok
    }

    private skip_newlines(self ref) Void = {
        while self.pos < self.tokens.count() then {
            when self.tokens[self.pos] is {
                .Newline then { self.pos += 1 },
                _ then { return },
            }
        }
    }

    private expected_error(self, expected String) String = {
        let got = self.peek()
        "Parse error: expected \(expected), got '\(got.to_string())' at token #\(self.pos.to_string())"
    }

    private is_eof(self) Bool = when self.peek() is { .EOF then true, _ then false }

    private check(self, expected Token) Bool =
        Token.tag(self.peek()) == Token.tag(expected)

    private expect(self ref, expected Token, expected_name String) [Token]Result = {
        if self.check(expected) then { return .Ok(self.eat()) }
        return .Error(ref self.expected_error(expected_name))
    }

    private expect_ident(self ref, what String) [Token]Result = {
        return when self.peek() is {
            .Ident(_) then .Ok(self.eat()),
            _ then {
                .Error(ref self.expected_error(what))
            },
        }
    }

    private is_type_start(self, t Token) Bool = when t is {
        .LBracket or .KwSelfType then true,
        .Ident(name) then {
            let runes = name.to_runes()
            if runes.count() == 0 then { false }
            else {
                let first = runes[0].to_uint32()
                first >= 65 and first <= 90
            }
        },
        _ then false,
    }

    private eat(self ref) Token = {
        self.skip_newlines()
        self.advance()
    }

    private eat_comma(self ref) [Token]Option = {
        if self.check(Token.Comma()) then { .Some(self.eat()) }
        else { .None() }
    }

    private count_newlines(self) UInt = {
        let mut count UInt = 0
        let mut i = self.pos
        while i < self.tokens.count() then {
            when self.tokens[i] is {
                .Newline then { count += 1; i += 1 },
                _ then { return count },
            }
        }
        count
    }

    private peek_at_skip_nl(self, offset UInt) Token = {
        let mut count UInt = 0
        let mut i = self.pos
        while i < self.tokens.count() then {
            when self.tokens[i] is {
                .Newline then { i += 1; continue },
                _ then {
                    if count == offset then { return self.tokens[i] }
                    count += 1
                    i += 1
                },
            }
        }
        Token.EOF()
    }

    private is_access_mod(self) Bool = when self.peek() is {
        .KwPublic or .KwPrivate or .KwProtected then true, _ then false,
    }

    private eat_vis(self ref) [Token]Option = {
        if self.is_access_mod() then { .Some(self.eat()) }
        else { .None() }
    }

    private eat_modifiers(self ref) [Token]List = {
        let mut mods = [Token]List.new()
        while true then {
            when self.peek() is {
                .KwForeign or .KwIntrinsic then { mods.push(self.eat()) },
                _ then { return mods },
            }
        }
        mods
    }

    // Check if we crossed a newline boundary (for statement termination)
    private at_newline_boundary(self) Bool = {
        if self.pos == 0 then { return false }
        // Check if there's a newline between current pos-1 and the next non-newline
        let mut i = self.pos
        if i > 0 then {
            i -= 1
            while i > 0 then {
                when self.tokens[i] is {
                    .Newline then { return true },
                    _ then { return false },
                }
            }
        }
        false
    }

    // Check if there's a newline before the current peek position
    private newline_before_current(self) Bool = {
        self.count_newlines() > 0
    }

    // ========================================================================
    // Type parsing
    // ========================================================================

    public parse_type(self ref) [CstType]Result = {
        self.parse_type_node()
    }

    private parse_type_node(self ref) [CstType]Result = {
        // Self type
        if self.check(.KwSelfType()) then {
            let kw = self.eat()
            let mut t = CstType.SelfType(kw)
            t = self.parse_type_suffix(t)
            return .Ok(t)
        }

        // Generic type: [T, U]Name
        if self.check(.LBracket()) then {
            let lb = self.eat()
            let mut args = [CstTypeArg]List.new()
            while not self.check(.RBracket()) and not self.is_eof() then {
                let inner = when self.parse_type_node() is {
                    .Ok(it) then it,
                    .Error(e) then { return .Error(e) },
                }
                let comma = self.eat_comma()
                args.push(CstTypeArg(ref inner, comma))
            }
            let rb = when self.expect(.RBracket(), "']'") is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }
            let base = when self.expect_ident("generic base type name") is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }
            let mut t = CstType.Generic(lb, args, rb, base)
            t = self.parse_type_suffix(t)
            return .Ok(t)
        }

        // Simple named type
        let name = when self.expect_ident("type name") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        when name is {
            .Ident(n) then {
                let runes = n.to_runes()
                if runes.count() == 0 then {
                    return .Error(ref "Parse error: empty type name")
                } else {
                    let first = runes[0].to_uint32()
                    if first < 65 or first > 90 then {
                        return .Error(ref "Parse error: type name must start with uppercase, got '\(n)'")
                    }
                }
            },
            _ then {},
        }
        let mut t = CstType.Named(name)
        t = self.parse_type_suffix(t)
        return .Ok(t)
    }

    private parse_type_suffix(self ref, base CstType) CstType = {
        let mut t = base
        while true then {
            if self.check(.KwRef()) then {
                let kw = self.eat()
                t = .Ref(ref t, kw)
                continue
            }
            if self.check(.KwPtr()) then {
                let kw = self.eat()
                t = .Ptr(ref t, kw)
                continue
            }
            if self.peek() is .KwWeakref then {
                let kw = self.eat()
                t = .Weakref(ref t, kw)
                continue
            }
            break
        }
        t
    }

    // ========================================================================
    // Generic parameters: [T Any, U Eq]
    // ========================================================================

    private parse_generic_params(self ref) [[CstGenericParams ref]Option]Result = {
        if not self.check(.LBracket()) then {
            return .Ok(.None())
        }
        let lb = when self.expect(.LBracket(), "'['") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let mut params = [CstGenericParam]List.new()
        while not self.check(.RBracket()) and not self.is_eof() then {
            let name = when self.expect_ident("generic parameter name") is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }
            let mut constraints = [CstType ref]List.new()
            // Collect constraint types until comma or ]
            while not self.check(.Comma()) and not self.check(.RBracket()) and not self.is_eof() then {
                if self.check(.KwAnd()) then {
                    self.eat()
                    continue
                }
                let ct = when self.parse_type_node() is {
                    .Ok(t) then t,
                    .Error(e) then { return .Error(e) },
                }
                constraints.push(ref ct)
            }
            let comma = self.eat_comma()
            params.push(CstGenericParam(name, constraints, comma))
        }
        let rb = when self.expect(.RBracket(), "']'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        return .Ok(.Some(ref CstGenericParams(lb, params, rb)))
    }

    // ========================================================================
    // Parameters: (name Type, name2 Type2)
    // ========================================================================

    private parse_params(self ref) [[CstParam]List]Result = {
        let mut params = [CstParam]List.new()
        let mut first UInt = 1
        while not self.check(.RParen()) and not self.is_eof() then {
            // Method-first-param support: self / self ref
            if first == 1 and self.check(.KwSelf()) then {
                let kw = self.eat()
                let mut ref_kw = [Token]Option.None()
                if self.check(.KwRef()) then {
                    ref_kw = .Some(self.eat())
                }
                let comma = self.eat_comma()
                params.push(.SelfParam(kw, ref_kw, comma))
                first = 0
                continue
            }

            let mut mut_kw = [Token]Option.None()
            if self.check(.KwMut()) then {
                mut_kw = .Some(self.eat())
            }
            let name = when self.expect_ident("parameter name") is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }

            // Parameters must have explicit type annotation.
            if not self.is_type_start(self.peek()) then {
                return .Error(ref "Parse error: expected parameter type after '\(name.to_string())'")
            }
            let pt = when self.parse_type_node() is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }
            let comma = self.eat_comma()
            params.push(.NamedParam(name, mut_kw, ref pt, comma))
            first = 0
        }
        return .Ok(params)
    }

    // ========================================================================
    // Expression parsing — recursive descent with precedence
    // ========================================================================
    // Precedence (low to high):
    //   or else
    //   or
    //   and then
    //   and
    //   not
    //   | (bitwise or)
    //   ^ (bitwise xor)
    //   & (bitwise and)
    //   range (.., ..<, etc.)
    //   == <> > < >= <=
    //   << >>
    //   + -
    //   * / %
    //   prefix (-, ~, ref, deref, ptr, deptr, cast)
    //   postfix (., call, subscript)
    //   primary
    // ========================================================================

    public parse_expr(self ref) [CstExpr]Result = {
        self.parse_expr_node()
    }

    private parse_expr_node(self ref) [CstExpr]Result = {
        // Top-level: if/while/for/when/let or or-else chain
        when self.peek() is {
            .KwIf then { return self.parse_if_expr() },
            .KwWhile then { return self.parse_while_expr() },
            .KwFor then { return self.parse_for_expr() },
            .KwWhen then { return self.parse_when_expr() },
            _ then {},
        }
        self.parse_or_else()
    }

    private parse_or_else(self ref) [CstExpr]Result = {
        let mut left = when self.parse_or() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        while self.check(.KwOr()) then {
            let next = self.peek_at_skip_nl(1)
            when next is {
                .KwElse then {
                    let or_kw = self.eat()
                    let else_kw = self.eat()
                    let right = when self.parse_or() is {
                        .Ok(e) then e,
                        .Error(e) then { return .Error(e) },
                    }
                    left = .OrElse(ref left, or_kw, else_kw, ref right)
                },
                _ then { break },
            }
        }
        return .Ok(left)
    }

    private parse_or(self ref) [CstExpr]Result = {
        let mut left = when self.parse_and_then() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        while self.check(.KwOr()) then {
            let next = self.peek_at_skip_nl(1)
            if next is .KwElse then { break }
            let op = self.eat()
            let right = when self.parse_and_then() is {
                .Ok(e) then e,
                .Error(e) then { return .Error(e) },
            }
            left = .BinaryOp(ref left, op, ref right)
        }
        return .Ok(left)
    }

    private parse_and_then(self ref) [CstExpr]Result = {
        let mut left = when self.parse_and() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        while self.check(.KwAnd()) then {
            let next = self.peek_at_skip_nl(1)
            when next is {
                .KwThen then {
                    let and_kw = self.eat()
                    let then_kw = self.eat()
                    let right = when self.parse_and() is {
                        .Ok(e) then e,
                        .Error(e) then { return .Error(e) },
                    }
                    left = .AndThen(ref left, and_kw, then_kw, ref right)
                },
                _ then { break },
            }
        }
        return .Ok(left)
    }

    private parse_and(self ref) [CstExpr]Result = {
        let mut left = when self.parse_not() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        while self.check(.KwAnd()) then {
            let next = self.peek_at_skip_nl(1)
            if next is .KwThen then { break }
            let op = self.eat()
            let right = when self.parse_not() is {
                .Ok(e) then e,
                .Error(e) then { return .Error(e) },
            }
            left = .BinaryOp(ref left, op, ref right)
        }
        return .Ok(left)
    }

    private parse_not(self ref) [CstExpr]Result = {
        if self.check(.KwNot()) then {
            let op = self.eat()
            let operand = when self.parse_bitwise_or() is {
                .Ok(e) then e,
                .Error(e) then { return .Error(e) },
            }
            return .Ok(.NotExpr(op, ref operand))
        }
        self.parse_bitwise_or()
    }

    private parse_bitwise_or(self ref) [CstExpr]Result = {
        let mut left = when self.parse_bitwise_xor() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        while self.check(.Pipe()) then {
            if self.newline_before_current() then { break }
            let op = self.eat()
            let right = when self.parse_bitwise_xor() is {
                .Ok(e) then e,
                .Error(e) then { return .Error(e) },
            }
            left = .BinaryOp(ref left, op, ref right)
        }
        return .Ok(left)
    }

    private parse_bitwise_xor(self ref) [CstExpr]Result = {
        let mut left = when self.parse_bitwise_and() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        while self.check(.Caret()) then {
            if self.newline_before_current() then { break }
            let op = self.eat()
            let right = when self.parse_bitwise_and() is {
                .Ok(e) then e,
                .Error(e) then { return .Error(e) },
            }
            left = .BinaryOp(ref left, op, ref right)
        }
        return .Ok(left)
    }

    private parse_bitwise_and(self ref) [CstExpr]Result = {
        let mut left = when self.parse_range() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        while self.check(.Amp()) then {
            if self.newline_before_current() then { break }
            let op = self.eat()
            let right = when self.parse_range() is {
                .Ok(e) then e,
                .Error(e) then { return .Error(e) },
            }
            left = .BinaryOp(ref left, op, ref right)
        }
        return .Ok(left)
    }

    private parse_range(self ref) [CstExpr]Result = {
        // Prefix range: ...b, ...<b, ....
        when self.peek() is {
            .FullRange then {
                let op = self.eat()
                return .Ok(.RangeExpr(.None(), op, .None()))
            },
            .Unbounded then {
                let op = self.eat()
                let right = when self.parse_comparison() is {
                    .Ok(e) then e,
                    .Error(e) then { return .Error(e) },
                }
                return .Ok(.RangeExpr(.None(), op, .Some(ref right)))
            },
            .UnboundedLt then {
                let op = self.eat()
                let right = when self.parse_comparison() is {
                    .Ok(e) then e,
                    .Error(e) then { return .Error(e) },
                }
                return .Ok(.RangeExpr(.None(), op, .Some(ref right)))
            },
            _ then {},
        }

        let left = when self.parse_comparison() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }

        when self.peek() is {
            .Range or .RangeLt or .LtRange or .LtRangeLt then {
                let op = self.eat()
                let right = when self.parse_comparison() is {
                    .Ok(e) then e,
                    .Error(e) then { return .Error(e) },
                }
                return .Ok(.RangeExpr(.Some(ref left), op, .Some(ref right)))
            },
            .Unbounded or .LtUnbounded then {
                let op = self.eat()
                return .Ok(.RangeExpr(.Some(ref left), op, .None()))
            },
            _ then { return .Ok(left) },
        }
    }

    private parse_comparison(self ref) [CstExpr]Result = {
        let mut left = when self.parse_shift() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        while true then {
            when self.peek() is {
                .EqEq or .NotEq or .Gt or .Lt or .GtEq or .LtEq then {
                    if self.newline_before_current() then { break }
                    let op = self.eat()
                    let right = when self.parse_shift() is {
                        .Ok(e) then e,
                        .Error(e) then { return .Error(e) },
                    }
                    left = .BinaryOp(ref left, op, ref right)
                },
                _ then { break },
            }
        }
        return .Ok(left)
    }

    private parse_shift(self ref) [CstExpr]Result = {
        let mut left = when self.parse_additive() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        while true then {
            when self.peek() is {
                .LShift or .RShift then {
                    if self.newline_before_current() then { break }
                    let op = self.eat()
                    let right = when self.parse_additive() is {
                        .Ok(e) then e,
                        .Error(e) then { return .Error(e) },
                    }
                    left = .BinaryOp(ref left, op, ref right)
                },
                _ then { break },
            }
        }
        return .Ok(left)
    }

    private parse_additive(self ref) [CstExpr]Result = {
        let mut left = when self.parse_multiplicative() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        while true then {
            when self.peek() is {
                .Plus then {
                    if self.newline_before_current() then { break }
                    let op = self.eat()
                    let right = when self.parse_multiplicative() is {
                        .Ok(e) then e,
                        .Error(e) then { return .Error(e) },
                    }
                    left = .BinaryOp(ref left, op, ref right)
                },
                .Minus then {
                    if self.newline_before_current() then { break }
                    let op = self.eat()
                    let right = when self.parse_multiplicative() is {
                        .Ok(e) then e,
                        .Error(e) then { return .Error(e) },
                    }
                    left = .BinaryOp(ref left, op, ref right)
                },
                _ then { break },
            }
        }
        return .Ok(left)
    }

    private parse_multiplicative(self ref) [CstExpr]Result = {
        let mut left = when self.parse_prefix() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        while true then {
            when self.peek() is {
                .Star or .Slash or .Percent then {
                    if self.newline_before_current() then { break }
                    let op = self.eat()
                    let right = when self.parse_prefix() is {
                        .Ok(e) then e,
                        .Error(e) then { return .Error(e) },
                    }
                    left = .BinaryOp(ref left, op, ref right)
                },
                _ then { break },
            }
        }
        return .Ok(left)
    }

    // ========================================================================
    // Prefix expressions
    // ========================================================================

    private parse_prefix(self ref) [CstExpr]Result = {
        let mut leading_comments = [Token]List.new()
        while self.peek() is .LineComment(_) or .BlockComment(_) or .Semi then {
            if self.peek() is .Semi then {
                let ignored_semi = self.eat()
            } else {
                leading_comments.push(self.eat())
            }
        }

        if leading_comments.count() > 0 then {
            let inner = when self.parse_prefix() is {
                .Ok(e) then e,
                .Error(e) then { return .Error(e) },
            }
            return .Ok(.Commented(leading_comments, ref inner))
        }

        // Type cast: (Type)expr — try with backtracking
        if self.check(.LParen()) then {
            let saved = self.pos
            let cast_result = self.try_parse_cast()
            when cast_result is {
                .Some(e) then { return .Ok(e) },
                .None then { self.pos = saved },
            }
        }

        // Unary minus
        if self.check(.Minus()) then {
            let op = self.eat()
            // Check for negative literal
            when self.peek() is {
                .IntLit(_) then {
                    let lit = self.eat()
                    return .Ok(.UnaryMinus(op, ref .IntLit(lit)))
                },
                .FloatLit(_) then {
                    let lit = self.eat()
                    return .Ok(.UnaryMinus(op, ref .FloatLit(lit)))
                },
                _ then {
                    let operand = when self.parse_prefix() is {
                        .Ok(e) then e,
                        .Error(e) then { return .Error(e) },
                    }
                    return .Ok(.UnaryMinus(op, ref operand))
                },
            }
        }

        // Bitwise not
        if self.check(.Tilde()) then {
            let op = self.eat()
            let operand = when self.parse_prefix() is {
                .Ok(e) then e,
                .Error(e) then { return .Error(e) },
            }
            return .Ok(.BitwiseNot(op, ref operand))
        }

        // Keyword prefixes: ref, deref, ptr, deptr
        if self.peek() is .KwRef or .KwDeref or .KwPtr or .KwDeptr then {
            let kw = self.eat()
            let operand = when self.parse_prefix() is {
                .Ok(e) then e,
                .Error(e) then { return .Error(e) },
            }
            return .Ok(.PrefixKw(kw, ref operand))
        }

        self.parse_postfix()
    }

    private try_parse_cast(self ref) [CstExpr]Option = {
        // Try: (Type)expr
        let lp = when self.expect(.LParen(), "'('") is {
            .Ok(t) then t,
            .Error(_) then { return .None() },
        }
        // Must be a type — starts with uppercase ident, [, or Self
        when self.peek() is {
            .Ident(_) then {
                let name = self.peek()
                when name is {
                    .Ident(n) then {
                        let runes = n.to_runes()
                        if runes.count() == 0 then { return .None() }
                        let first = runes[0].to_uint32()
                        if first < 65 or first > 90 then { return .None() }
                    },
                    _ then { return .None() },
                }
            },
            .LBracket or .KwSelfType then {},
            _ then { return .None() },
        }
        let ct = when self.parse_type_node() is {
            .Ok(t) then t,
            .Error(_) then { return .None() },
        }
        if not self.check(.RParen()) then { return .None() }
        let rp = when self.expect(.RParen(), "')'") is {
            .Ok(t) then t,
            .Error(_) then { return .None() },
        }
        let operand = when self.parse_prefix() is {
            .Ok(e) then e,
            .Error(_) then { return .None() },
        }
        return .Some(.TypeCast(lp, ref ct, rp, ref operand))
    }

    // ========================================================================
    // Postfix expressions
    // ========================================================================

    private parse_postfix(self ref) [CstExpr]Result = {
        let mut expr = when self.parse_primary() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        while true then {
            // Stop at newline for non-continuation tokens
            if self.newline_before_current() then {
                if self.peek() is not .Dot then { break }
            }

            // Field access: expr.field
            if self.check(.Dot()) then {
                let dot = self.eat()
                let field = when self.expect_ident("field name") is {
                    .Ok(t) then t,
                    .Error(e) then { return .Error(e) },
                }
                // Check for method call: expr.field(args)
                if (not self.newline_before_current()) and self.check(.LParen()) then {
                    let field_expr = CstExpr.FieldAccess(ref expr, dot, field)
                    let lp = self.eat()
                    let args = when self.parse_call_args() is {
                        .Ok(a) then a,
                        .Error(e) then { return .Error(e) },
                    }
                    let rp = when self.expect(.RParen(), "')'") is {
                        .Ok(t) then t,
                        .Error(e) then { return .Error(e) },
                    }
                    expr = .Call(ref field_expr, lp, args, rp)
                    continue
                }
                expr = .FieldAccess(ref expr, dot, field)
                continue
            }

            // Call: expr(args)
            if self.check(.LParen()) then {
                let lp = self.eat()
                let args = when self.parse_call_args() is {
                    .Ok(a) then a,
                    .Error(e) then { return .Error(e) },
                }
                let rp = when self.expect(.RParen(), "')'") is {
                    .Ok(t) then t,
                    .Error(e) then { return .Error(e) },
                }
                expr = .Call(ref expr, lp, args, rp)
                continue
            }

            // Subscript: expr[args]
            if self.check(.LBracket()) then {
                let lb = self.eat()
                let mut args = [CstCallArg]List.new()
                while not self.check(.RBracket()) and not self.is_eof() then {
                    let val = when self.parse_expr_node() is {
                        .Ok(e) then e,
                        .Error(e) then { return .Error(e) },
                    }
                    let comma = self.eat_comma()
                    args.push(CstCallArg(ref val, comma))
                }
                let rb = when self.expect(.RBracket(), "']'") is {
                    .Ok(t) then t,
                    .Error(e) then { return .Error(e) },
                }
                expr = .SubscriptExpr(ref expr, lb, args, rb)
                continue
            }

            break
        }
        return .Ok(expr)
    }

    private parse_call_args(self ref) [[CstCallArg]List]Result = {
        let mut args = [CstCallArg]List.new()
        while not self.check(.RParen()) and not self.is_eof() then {
            if self.peek() is .LineComment(_) or .BlockComment(_) then {
                self.eat()
                continue
            }
            if self.check(.Semi()) then {
                self.eat()
                continue
            }
            let before = self.pos
            let val = when self.parse_expr_node() is {
                .Ok(e) then e,
                .Error(e) then { return .Error(e) },
            }
            let comma = self.eat_comma()
            args.push(CstCallArg(ref val, comma))
            if self.pos == before then {
                return .Error(ref "Parse error: parser made no progress in argument list")
            }
        }
        return .Ok(args)
    }

    // ========================================================================
    // Primary expressions
    // ========================================================================

    private parse_primary(self ref) [CstExpr]Result = {
        when self.peek() is {
            .IntLit(_) then { return .Ok(.IntLit(self.eat())) },
            .FloatLit(_) then { return .Ok(.FloatLit(self.eat())) },
            .StrLit(_) then { return .Ok(.StrLit(self.eat())) },
            .InterpStr(_) then { return .Ok(.InterpStr(self.eat())) },
            .BoolTrue or .BoolFalse then { return .Ok(.BoolLit(self.eat())) },
            .KwSelf then { return .Ok(.SelfExpr(self.eat())) },
            .Underscore then { return .Ok(.UnderscoreExpr(self.eat())) },
            _ then {},
        }

        // Identifier
        if self.peek() is .Ident(_) then { return .Ok(.Ident(self.eat())) }

        // Block: { ... }
        if self.check(.LBrace()) then {
            return self.parse_block_expr()
        }

        // Parenthesized expression or lambda
        if self.check(.LParen()) then {
            return self.parse_paren_or_lambda()
        }

        // Generic instantiation: [T]Name or [T]Name(args)
        if self.check(.LBracket()) then {
            let lb = self.eat()
            let mut type_args = [CstTypeArg]List.new()
            while not self.check(.RBracket()) and not self.is_eof() then {
                let t = when self.parse_type_node() is {
                    .Ok(it) then it,
                    .Error(e) then { return .Error(e) },
                }
                let comma = self.eat_comma()
                type_args.push(CstTypeArg(ref t, comma))
            }
            let rb = when self.expect(.RBracket(), "']'") is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }
            let name = when self.expect_ident("generic callee name") is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }
            let inst = CstExpr.GenericInst(lb, type_args, rb, name)
            // Check for call: [T]Name(args)
            if self.check(.LParen()) then {
                let lp = self.eat()
                let args = when self.parse_call_args() is {
                    .Ok(a) then a,
                    .Error(e) then { return .Error(e) },
                }
                let rp = when self.expect(.RParen(), "')'") is {
                    .Ok(t) then t,
                    .Error(e) then { return .Error(e) },
                }
                return .Ok(.Call(ref inst, lp, args, rp))
            }
            return .Ok(inst)
        }

        // Implicit member: .Name or .Name(args)
        if self.check(.Dot()) then {
            let dot = self.eat()
            let name = when self.expect_ident("member name") is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }
            if self.check(.LParen()) then {
                let lp = self.eat()
                let args = when self.parse_call_args() is {
                    .Ok(a) then a,
                    .Error(e) then { return .Error(e) },
                }
                let rp = when self.expect(.RParen(), "')'") is {
                    .Ok(t) then t,
                    .Error(e) then { return .Error(e) },
                }
                return .Ok(.ImplicitMember(dot, name, .Some(lp), args, .Some(rp)))
            }
            return .Ok(.ImplicitMember(dot, name, .None(), [CstCallArg]List.new(), .None()))
        }

        // Self type used as expression
        if self.check(.KwSelfType()) then {
            return .Ok(.Ident(self.eat()))
        }

        // Invalid primary token
        let got = self.peek()
        when got is {
            .RParen or .RBracket or .RBrace or .Comma or .Semi then {
                return .Error(ref "Parse error: expected primary expression, got '\(got.to_string())' at token #\(self.pos.to_string())")
            },
            _ then {},
        }
        if not self.is_eof() then {
            let bad = self.eat()
            return .Ok(.Ident(bad))
        }
        return .Error(ref "Parse error: expected primary expression, got '\(got.to_string())' at token #\(self.pos.to_string())")
    }

    // ========================================================================
    // Block expression: { stmts; final_expr? }
    // ========================================================================

    private parse_block_expr(self ref) [CstExpr]Result = {
        let lb = when self.expect(.LBrace(), "'{'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let mut items = [CstItem ref]List.new()
        while not self.check(.RBrace()) and not self.is_eof() then {
            let nl_count = self.count_newlines()
            if nl_count >= 2 then {
                self.skip_newlines()
                items.push(ref .BlankLine())
                continue
            }
            self.skip_newlines()
            if self.check(.RBrace()) or self.is_eof() then { break }
            if self.peek() is .LineComment(_) or .BlockComment(_) then {
                let c = self.eat()
                let prev_is_code = {
                    if items.count() > 0 then {
                        let prev = deref items[items.count() - 1]
                        when prev is { .Decl(_) or .Stmt(_) then true, _ then false }
                    } else {
                        false
                    }
                }
                if nl_count == 0 and prev_is_code then {
                    items.push(ref .TrailingComment(c))
                } else {
                    items.push(ref .Comment(c))
                }
                continue
            }
            when self.parse_block_item() is {
                .Ok(item) then { items.push(ref item) },
                .Error(e) then { return .Error(e) },
            }
        }
        let rb = when self.expect(.RBrace(), "'}'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        return .Ok(.Block(lb, items, rb))
    }

    private parse_block_item(self ref) [CstItem]Result = {
        // Variable declaration: let [mut] name [Type] = expr
        if self.peek() is .KwLet then {
            when self.parse_var_decl_stmt() is {
                .Ok(s) then { return .Ok(.Stmt(ref s)) },
                .Error(e) then { return .Error(e) },
            }
        }
        // Statement
        when self.parse_stmt() is {
            .Ok(s) then .Ok(.Stmt(ref s)),
            .Error(e) then .Error(e),
        }
    }

    // ========================================================================
    // Parenthesized expression or lambda
    // ========================================================================

    private parse_paren_or_lambda(self ref) [CstExpr]Result = {
        // Try lambda: (params) [RetType] -> body
        let saved = self.pos
        let lambda_result = self.try_parse_lambda()
        when lambda_result is {
            .Some(e) then { return .Ok(e) },
            .None then { self.pos = saved },
        }
        // Parenthesized expression
        let lp = when self.expect(.LParen(), "'('") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        if self.check(.RParen()) then {
            when self.expect(.RParen(), "')'") is {
                .Ok(_) then {},
                .Error(e) then { return .Error(e) },
            }
            return .Ok(.Ident(.Ident("()")))
        }
        let inner = when self.parse_expr_node() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        let rp = when self.expect(.RParen(), "')'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }

        // Keep one paren layer for readability, but collapse duplicate nesting:
        // ((x)) -> (x)
        when inner is {
            .Paren(_, nested, _) then { return .Ok(.Paren(lp, nested, rp)) },
            _ then { return .Ok(.Paren(lp, ref inner, rp)) },
        }
    }

    private try_parse_lambda(self ref) [CstExpr]Option = {
        let lp = when self.expect(.LParen(), "'('") is {
            .Ok(t) then t,
            .Error(_) then { return .None() },
        }
        let mut params = [CstLambdaParam]List.new()
        while not self.check(.RParen()) and not self.is_eof() then {
            if self.peek() is not .Ident(_) then { return .None() }
            let name = self.eat()
            // Optional type annotation
            let mut pt = [CstType ref]Option.None()
            if self.peek() is .Ident(_) or .LBracket or .KwSelfType then {
                // Check if this looks like a type (uppercase start or [)
                let is_type = when self.peek() is {
                    .LBracket or .KwSelfType then true,
                    .Ident(n) then {
                        let runes = n.to_runes()
                        if runes.count() > 0 then {
                            let first = runes[0].to_uint32()
                            first >= 65 and first <= 90
                        } else { false }
                    },
                    _ then false,
                }
                if is_type then {
                    let t = when self.parse_type_node() is {
                        .Ok(it) then it,
                        .Error(_) then { return .None() },
                    }
                    pt = .Some(ref t)
                }
            }
            let comma = self.eat_comma()
            params.push(CstLambdaParam(name, pt, comma))
        }
        if not self.check(.RParen()) then { return .None() }
        let rp = when self.expect(.RParen(), "')'") is {
            .Ok(t) then t,
            .Error(_) then { return .None() },
        }

        // Optional return type
        let mut ret = [CstType ref]Option.None()
        if self.peek() is .Ident(_) or .LBracket or .KwSelfType then {
            let is_type = when self.peek() is {
                .LBracket or .KwSelfType then true,
                .Ident(n) then {
                    let runes = n.to_runes()
                    if runes.count() > 0 then {
                        let first = runes[0].to_uint32()
                        first >= 65 and first <= 90
                    } else { false }
                },
                _ then false,
            }
            if is_type then {
                let t = when self.parse_type_node() is {
                    .Ok(it) then it,
                    .Error(_) then { return .None() },
                }
                ret = .Some(ref t)
            }
        }

        if not self.check(.Arrow()) then { return .None() }
        let arrow = self.eat()
        let body = when self.parse_expr_node() is {
            .Ok(e) then e,
            .Error(_) then { return .None() },
        }
        return .Some(.Lambda(lp, params, rp, ret, arrow, ref body))
    }

    // ========================================================================
    // Control flow expressions
    // ========================================================================

    private parse_if_expr(self ref) [CstExpr]Result = {
        let kw = when self.expect(.KwIf(), "'if'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }

        // Check for if-pattern: if expr is pattern then ...
        let cond = when self.parse_or_else() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }

        if self.check(.KwIs()) then {
            let is_kw = self.eat()
            let pattern = when self.parse_pattern_node() is {
                .Ok(p) then p,
                .Error(e) then { return .Error(e) },
            }
            let then_kw = when self.expect(.KwThen(), "'then'") is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }
            let then_body = when self.parse_expr_node() is {
                .Ok(e) then e,
                .Error(e) then { return .Error(e) },
            }
            if self.check(.KwElse()) then {
                let else_kw = self.eat()
                let else_body = when self.parse_expr_node() is {
                    .Ok(e) then e,
                    .Error(e) then { return .Error(e) },
                }
                return .Ok(.IfPattern(kw, ref cond, is_kw, ref pattern,
                    then_kw, ref then_body, .Some(else_kw), .Some(ref else_body)))
            }
            return .Ok(.IfPattern(kw, ref cond, is_kw, ref pattern,
                then_kw, ref then_body, .None(), .None()))
        }

        let then_kw = when self.expect(.KwThen(), "'then'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let then_body = when self.parse_expr_node() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        if self.check(.KwElse()) then {
            let else_kw = self.eat()
            let else_body = when self.parse_expr_node() is {
                .Ok(e) then e,
                .Error(e) then { return .Error(e) },
            }
            return .Ok(.If(kw, ref cond, then_kw, ref then_body,
                .Some(else_kw), .Some(ref else_body)))
        }
        return .Ok(.If(kw, ref cond, then_kw, ref then_body, .None(), .None()))
    }

    private parse_while_expr(self ref) [CstExpr]Result = {
        let kw = when self.expect(.KwWhile(), "'while'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let cond = when self.parse_or_else() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }

        // Check for while-pattern: while expr is pattern then ...
        if self.check(.KwIs()) then {
            let is_kw = self.eat()
            let pattern = when self.parse_pattern_node() is {
                .Ok(p) then p,
                .Error(e) then { return .Error(e) },
            }
            let then_kw = when self.expect(.KwThen(), "'then'") is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }
            let body = when self.parse_expr_node() is {
                .Ok(e) then e,
                .Error(e) then { return .Error(e) },
            }
            return .Ok(.WhilePattern(kw, ref cond, is_kw, ref pattern, then_kw, ref body))
        }

        let then_kw = when self.expect(.KwThen(), "'then'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let body = when self.parse_expr_node() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        return .Ok(.While(kw, ref cond, then_kw, ref body))
    }

    private parse_for_expr(self ref) [CstExpr]Result = {
        let kw = when self.expect(.KwFor(), "'for'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let binding = when self.parse_pattern_node() is {
            .Ok(p) then p,
            .Error(e) then { return .Error(e) },
        }
        let eq = when self.expect(.Eq(), "'='") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let iterable = when self.parse_or_else() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        let then_kw = when self.expect(.KwThen(), "'then'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let body = when self.parse_expr_node() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        return .Ok(.For(kw, ref binding, eq, ref iterable, then_kw, ref body))
    }

    private parse_when_expr(self ref) [CstExpr]Result = {
        let kw = when self.expect(.KwWhen(), "'when'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let subject = when self.parse_or_else() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        let is_kw = if self.check(.KwIs()) then { self.eat() } else { Token.KwIs() }

        let lb = when self.expect(.LBrace(), "'{'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let mut arms = [CstWhenArm ref]List.new()
        while not self.check(.RBrace()) and not self.is_eof() then {
            self.skip_newlines()
            if self.check(.RBrace()) or self.is_eof() then { break }
            if self.peek() is .LineComment(_) or .BlockComment(_) then {
                self.eat() // skip comments in when blocks for now
                continue
            }
            when self.parse_when_arm() is {
                .Ok(arm) then { arms.push(ref arm) },
                .Error(e) then { return .Error(e) },
            }
        }
        let rb = when self.expect(.RBrace(), "'}'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        return .Ok(.When(kw, ref subject, is_kw, lb, arms, rb))
    }

    private parse_when_arm(self ref) [CstWhenArm]Result = {
        let pattern = when self.parse_pattern_node() is {
            .Ok(p) then p,
            .Error(e) then { return .Error(e) },
        }
        let then_kw = when self.expect(.KwThen(), "'then'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let body = when self.parse_expr_node() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        let comma = self.eat_comma()
        // Skip semicolons too
        if self.peek() is .Semi then { self.eat() }
        return .Ok(CstWhenArm(ref pattern, then_kw, ref body, comma))
    }

    private expect_pattern_value(self ref, what String) [Token]Result = {
        when self.peek() is {
            .IntLit(_) or .FloatLit(_) or .StrLit(_) or .BoolTrue or .BoolFalse or .Ident(_) then {
                return .Ok(self.eat())
            },
            _ then {
                return .Error(ref self.expected_error(what))
            },
        }
    }

    // ========================================================================
    // Pattern parsing
    // ========================================================================

    public parse_pattern(self ref) [CstPattern]Result = {
        self.parse_pattern_node()
    }

    private parse_pattern_node(self ref) [CstPattern]Result = {
        self.parse_or_pattern()
    }

    private parse_or_pattern(self ref) [CstPattern]Result = {
        let mut left = when self.parse_and_pattern() is {
            .Ok(p) then p,
            .Error(e) then { return .Error(e) },
        }
        while self.check(.KwOr()) then {
            let next = self.peek_at_skip_nl(1)
            if next is .KwElse then { break }
            let op = self.eat()
            let right = when self.parse_and_pattern() is {
                .Ok(p) then p,
                .Error(e) then { return .Error(e) },
            }
            left = .OrPattern(ref left, op, ref right)
        }
        return .Ok(left)
    }

    private parse_and_pattern(self ref) [CstPattern]Result = {
        let mut left = when self.parse_not_pattern() is {
            .Ok(p) then p,
            .Error(e) then { return .Error(e) },
        }
        while self.check(.KwAnd()) then {
            let next = self.peek_at_skip_nl(1)
            if next is .KwThen then { break }
            let op = self.eat()
            let right = when self.parse_not_pattern() is {
                .Ok(p) then p,
                .Error(e) then { return .Error(e) },
            }
            left = .AndPattern(ref left, op, ref right)
        }
        return .Ok(left)
    }

    private parse_not_pattern(self ref) [CstPattern]Result = {
        if self.check(.KwNot()) then {
            let op = self.eat()
            let inner = when self.parse_not_pattern() is {
                .Ok(p) then p,
                .Error(e) then { return .Error(e) },
            }
            return .Ok(.NotPattern(op, ref inner))
        }
        self.parse_primary_pattern()
    }

    private parse_primary_pattern(self ref) [CstPattern]Result = {
        // Comparison patterns: > n, < n, >= n, <= n
        when self.peek() is {
            .Gt or .Lt or .GtEq or .LtEq then {
                let op = self.eat()
                // Handle negative: > -5
                if self.check(.Minus()) then {
                    let minus = self.eat()
                    let val = when self.expect_pattern_value("pattern value") is {
                        .Ok(v) then v,
                        .Error(e) then { return .Error(e) },
                    }
                    return .Ok(.Comparison(op, val))
                }
                let val = when self.expect_pattern_value("pattern value") is {
                    .Ok(v) then v,
                    .Error(e) then { return .Error(e) },
                }
                return .Ok(.Comparison(op, val))
            },
            _ then {},
        }

        // Negative integer: -5
        if self.check(.Minus()) then {
            let minus = self.eat()
            let val = when self.expect_pattern_value("integer literal") is {
                .Ok(v) then v,
                .Error(e) then { return .Error(e) },
            }
            return .Ok(.NegIntLit(minus, val))
        }

        // Integer literal
        when self.peek() is {
            .IntLit(_) then { return .Ok(.PatIntLit(self.eat())) },
            .FloatLit(_) then { return .Ok(.PatIntLit(self.eat())) },
            .StrLit(_) then { return .Ok(.PatStrLit(self.eat())) },
            .BoolTrue or .BoolFalse then { return .Ok(.PatBoolLit(self.eat())) },
            _ then {},
        }

        // Wildcard
        if self.peek() is .Underscore then { return .Ok(.Wildcard(self.eat())) }

        // Mutable variable: mut name
        if self.check(.KwMut()) then {
            let mut_kw = self.eat()
            let name = when self.expect_ident("pattern variable name") is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }
            return .Ok(.MutVariable(mut_kw, name))
        }

        // Union case: .Name or .Name(args)
        if self.check(.Dot()) then {
            let dot = self.eat()
            let name = when self.expect_ident("union case name") is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }
            if self.check(.LParen()) then {
                let lp = self.eat()
                let mut args = [CstPatternArg]List.new()
                while not self.check(.RParen()) and not self.is_eof() then {
                    let p = when self.parse_pattern_node() is {
                        .Ok(it) then it,
                        .Error(e) then { return .Error(e) },
                    }
                    let comma = self.eat_comma()
                    args.push(CstPatternArg(ref p, comma))
                }
                let rp = when self.expect(.RParen(), "')'") is {
                    .Ok(t) then t,
                    .Error(e) then { return .Error(e) },
                }
                return .Ok(.UnionCase(dot, name, .Some(lp), args, .Some(rp)))
            }
            return .Ok(.UnionCase(dot, name, .None(), [CstPatternArg]List.new(), .None()))
        }

        // Parenthesized pattern
        if self.check(.LParen()) then {
            let lp = self.eat()
            let inner = when self.parse_pattern_node() is {
                .Ok(it) then it,
                .Error(e) then { return .Error(e) },
            }
            let rp = when self.expect(.RParen(), "')'") is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }
            return .Ok(.ParenPattern(lp, ref inner, rp))
        }

        // Variable or struct pattern: name or Name(args)
        if self.peek() is .Ident(_) then {
            let name = when self.expect_ident("pattern name") is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }
            if self.check(.LParen()) then {
                let lp = self.eat()
                let mut args = [CstPatternArg]List.new()
                while not self.check(.RParen()) and not self.is_eof() then {
                    let p = when self.parse_pattern_node() is {
                        .Ok(it) then it,
                        .Error(e) then { return .Error(e) },
                    }
                    let comma = self.eat_comma()
                    args.push(CstPatternArg(ref p, comma))
                }
                let rp = when self.expect(.RParen(), "')'") is {
                    .Ok(t) then t,
                    .Error(e) then { return .Error(e) },
                }
                return .Ok(.StructPattern(name, lp, args, rp))
            }
            return .Ok(.Variable(name))
        }

        // Fallback
        return .Error(ref self.expected_error("pattern"))
    }

    // ========================================================================
    // Statement parsing
    // ========================================================================

    private parse_stmt(self ref) [CstStmt]Result = {
        when self.peek() is {
            .KwReturn then {
                let kw = self.eat()
                // Check if there's a value on the same line
                if self.peek_raw() is .Newline or .EOF then {
                    return .Ok(.Return(kw, .None()))
                }
                if self.check(.RBrace()) then {
                    return .Ok(.Return(kw, .None()))
                }
                if self.check(.Semi()) then {
                    self.eat()
                    return .Ok(.Return(kw, .None()))
                }
                let val = when self.parse_expr_node() is {
                    .Ok(e) then e,
                    .Error(e) then { return .Error(e) },
                }
                // Eat optional semicolon
                if self.peek() is .Semi then { self.eat() }
                return .Ok(.Return(kw, .Some(ref val)))
            },
            .KwBreak then {
                let kw = self.eat()
                if self.peek() is .Semi then { self.eat() }
                return .Ok(.Break(kw))
            },
            .KwContinue then {
                let kw = self.eat()
                if self.peek() is .Semi then { self.eat() }
                return .Ok(.Continue(kw))
            },
            _ then {},
        }

        // Expression statement — may be followed by assignment operator
        let expr = when self.parse_expr_node() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        when self.peek() is {
            .Eq or .PlusEq or .MinusEq or .StarEq or .SlashEq or .PercentEq
            or .AmpEq or .PipeEq or .CaretEq or .LShiftEq or .RShiftEq then {
                let op = self.eat()
                let val = when self.parse_expr_node() is {
                    .Ok(e) then e,
                    .Error(e) then { return .Error(e) },
                }
                if self.peek() is .Semi then { self.eat() }
                return .Ok(.Assignment(ref expr, op, ref val))
            },
            _ then {},
        }
        // Eat optional semicolon
        let mut semi = [Token]Option.None()
        if self.peek() is .Semi then { semi = .Some(self.eat()) }
        return .Ok(.ExprStmt(ref expr, semi))
    }

    private parse_var_decl_stmt(self ref) [CstStmt]Result = {
        let let_kw = when self.expect(.KwLet(), "'let'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let mut mut_kw = [Token]Option.None()
        if self.check(.KwMut()) then {
            mut_kw = .Some(self.eat())
        }
        let name = when self.expect_ident("variable name") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }

        // Optional type annotation
        let mut var_type = [CstType ref]Option.None()
        if self.peek() is .Ident(_) or .LBracket or .KwSelfType then {
            let is_type = when self.peek() is {
                .LBracket or .KwSelfType then true,
                .Ident(n) then {
                    let runes = n.to_runes()
                    if runes.count() > 0 then {
                        let first = runes[0].to_uint32()
                        first >= 65 and first <= 90
                    } else { false }
                },
                _ then false,
            }
            if is_type then {
                let t = when self.parse_type_node() is {
                    .Ok(it) then it,
                    .Error(e) then { return .Error(e) },
                }
                var_type = .Some(ref t)
            }
        }

        let eq = when self.expect(.Eq(), "'='") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let val = when self.parse_expr_node() is {
            .Ok(e) then e,
            .Error(e) then { return .Error(e) },
        }
        // Eat optional semicolon
        if self.peek() is .Semi then { self.eat() }
        return .Ok(.VarDecl(let_kw, mut_kw, name, var_type, eq, ref val))
    }

    // ========================================================================
    // Declaration parsing
    // ========================================================================

    // Main entry point
    public parse(self ref) [CstFile]Result = {
        let mut items = [CstItem ref]List.new()
        while not self.is_eof() then {
            let nl_count = self.count_newlines()
            if nl_count >= 2 then {
                self.skip_newlines()
                items.push(ref .BlankLine())
                continue
            }
            self.skip_newlines()
            if self.is_eof() then { break }
            if self.check(.Semi()) then {
                self.eat()
                continue
            }
            if self.peek() is .LineComment(_) or .BlockComment(_) then {
                let c = self.eat()
                let prev_is_code = {
                    if items.count() > 0 then {
                        let prev = deref items[items.count() - 1]
                        when prev is { .Decl(_) or .Stmt(_) then true, _ then false }
                    } else {
                        false
                    }
                }
                if nl_count == 0 and prev_is_code then {
                    items.push(ref .TrailingComment(c))
                } else {
                    items.push(ref .Comment(c))
                }
                continue
            }
            let before = self.pos
            when self.parse_top_item() is {
                .Ok(item) then { items.push(ref item) },
                .Error(e) then { return .Error(e) },
            }
            if self.pos == before then {
                return .Error(ref "Parse error: parser made no progress")
            }
        }
        return .Ok(CstFile(items))
    }

    private parse_top_item(self ref) [CstItem]Result = {
        // Using declaration
        if self.check(.KwUsing()) then {
            when self.parse_using_decl() is {
                .Ok(d) then { return .Ok(.Decl(ref d)) },
                .Error(e) then { return .Error(e) },
            }
        }
        // Foreign using
        if self.check(.KwForeign()) then {
            let next = self.peek_at_skip_nl(1)
            when next is {
                .KwUsing then {
                    when self.parse_foreign_using_decl() is {
                        .Ok(d) then { return .Ok(.Decl(ref d)) },
                        .Error(e) then { return .Error(e) },
                    }
                },
                _ then {},
            }
        }

        // Determine declaration kind by peeking past access modifiers and modifiers
        let mut offset UInt = 0
        if self.is_access_mod() then { offset = 1 }
        let after_access = self.peek_at_skip_nl(offset)
        if after_access is .KwForeign or .KwIntrinsic then { offset += 1 }
        let decl_kw = self.peek_at_skip_nl(offset)
        when decl_kw is {
            .KwLet then {
                when self.parse_let_decl() is {
                    .Ok(d) then { return .Ok(.Decl(ref d)) },
                    .Error(e) then { return .Error(e) },
                }
            },
            .KwType then {
                when self.parse_type_decl() is {
                    .Ok(d) then { return .Ok(.Decl(ref d)) },
                    .Error(e) then { return .Error(e) },
                }
            },
            .KwTrait then {
                when self.parse_trait_decl() is {
                    .Ok(d) then { return .Ok(.Decl(ref d)) },
                    .Error(e) then { return .Error(e) },
                }
            },
            .KwGiven then {
                when self.parse_given_decl() is {
                    .Ok(d) then { return .Ok(.Decl(ref d)) },
                    .Error(e) then { return .Error(e) },
                }
            },
            _ then {},
        }
        // Statement
        when self.parse_stmt() is {
            .Ok(s) then .Ok(.Stmt(ref s)),
            .Error(e) then .Error(e),
        }
    }

    // ========================================================================
    // Using declarations
    // ========================================================================

    private parse_using_decl(self ref) [CstDecl]Result = {
        let mut tokens = [Token]List.new()
        while not self.is_eof() then {
            when self.peek_raw() is {
                .Newline or .EOF then { break },
                _ then { tokens.push(self.advance()) },
            }
        }
        return .Ok(.Using(tokens))
    }

    private parse_foreign_using_decl(self ref) [CstDecl]Result = {
        let foreign_kw = when self.expect(.KwForeign(), "'foreign'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let mut tokens = [Token]List.new()
        while not self.is_eof() then {
            when self.peek_raw() is {
                .Newline or .EOF then { break },
                _ then { tokens.push(self.advance()) },
            }
        }
        return .Ok(.ForeignUsing(foreign_kw, tokens))
    }

    // ========================================================================
    // Let declaration (function or variable)
    // ========================================================================

    private parse_let_decl(self ref) [CstDecl]Result = {
        let vis = self.eat_vis()
        let mods = self.eat_modifiers()
        let let_kw = when self.expect(.KwLet(), "'let'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let mut mut_kw = [Token]Option.None()
        if self.check(.KwMut()) then {
            mut_kw = .Some(self.eat())
        }
        self.finish_func_or_var(vis, mods, .Some(let_kw), mut_kw, false)
    }

    private finish_func_or_var(self ref,
        vis [Token]Option, mods [Token]List,
        let_kw [Token]Option, mut_kw [Token]Option,
        in_member_context Bool
    ) [CstDecl]Result = {
        let gp = when self.parse_generic_params() is {
            .Ok(g) then g,
            .Error(e) then { return .Error(e) },
        }
        let name = when self.peek() is {
            .Ident(_) then {
                when self.expect_ident("declaration name") is {
                    .Ok(t) then t,
                    .Error(e) then { return .Error(e) },
                }
            },
            _ then {
                return .Error(ref self.expected_error("declaration name"))
            },
        }

        // Parameters
        let mut lp = [Token]Option.None()
        let mut params = [CstParam]List.new()
        let mut rp = [Token]Option.None()
        if self.check(.LParen()) then {
            lp = .Some(self.eat())
            params = when self.parse_params() is {
                .Ok(ps) then ps,
                .Error(e) then { return .Error(e) },
            }
            rp = .Some(when self.expect(.RParen(), "')'") is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            })
        }

        // Return type
        let mut ret = [CstType ref]Option.None()
        if self.peek() is .Ident(_) or .LBracket or .KwSelfType then {
            if not self.check(.Eq()) then {
                let is_type = when self.peek() is {
                    .LBracket or .KwSelfType then true,
                    .Ident(n) then {
                        let runes = n.to_runes()
                        if runes.count() > 0 then {
                            let first = runes[0].to_uint32()
                            first >= 65 and first <= 90
                        } else { false }
                    },
                    _ then false,
                }
                if is_type then {
                    let t = when self.parse_type_node() is {
                        .Ok(it) then it,
                        .Error(e) then { return .Error(e) },
                    }
                    ret = .Some(ref t)
                }
            }
        }

        // = body → function
        if self.check(.Eq()) then {
            let eq = when self.expect(.Eq(), "'='") is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }
            let body = when self.parse_expr_node() is {
                .Ok(e) then e,
                .Error(e) then { return .Error(e) },
            }
            return .Ok(.Func(vis, mods, let_kw, mut_kw, gp, .Some(name),
                lp, params, rp, ret, eq, ref body))
        }

        // No = → foreign declaration or variable
        if mods.count() > 0 then {
            return .Ok(.ForeignDecl(vis, mods, let_kw, mut_kw, gp, .Some(name),
                lp, params, rp, ret))
        }

        // In trait/given member context, signature-style declarations without
        // body are method signatures, not variable declarations.
        if in_member_context then {
            if lp is .Some(_) then {
                return .Ok(.ForeignDecl(vis, mods, let_kw, mut_kw, gp, .Some(name),
                    lp, params, rp, ret))
            }
            return .Error(ref self.expected_error("member signature"))
        }

        // Variable declaration (top-level)
        let lk = when let_kw is {
            .Some(k) then k,
            .None then .KwLet(),
        }
        return .Ok(.Var(vis, lk, mut_kw, name, ret))
    }

    // ========================================================================
    // Type declaration
    // ========================================================================

    private parse_type_decl(self ref) [CstDecl]Result = {
        let vis = self.eat_vis()
        let mods = self.eat_modifiers()
        let kw = when self.expect(.KwType(), "'type'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let gp = when self.parse_generic_params() is {
            .Ok(g) then g,
            .Error(e) then { return .Error(e) },
        }
        let name = when self.expect_ident("type name") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }

        // Struct body: (fields)
        if self.check(.LParen()) then {
            let lp = self.eat()
            let mut fields = [CstStructField]List.new()
            while not self.check(.RParen()) and not self.is_eof() then {
                let mut field_mut = [Token]Option.None()
                let mut field_access = [Token]Option.None()
                if self.peek() is .KwPublic or .KwPrivate or .KwProtected then {
                    field_access = .Some(self.eat())
                }
                if self.check(.KwMut()) then {
                    field_mut = .Some(self.eat())
                }
                let field_name = when self.expect_ident("field name") is {
                    .Ok(t) then t,
                    .Error(e) then { return .Error(e) },
                }
                let field_type = when self.parse_type_node() is {
                    .Ok(t) then t,
                    .Error(e) then { return .Error(e) },
                }
                let comma = self.eat_comma()
                fields.push(CstStructField(field_mut, field_access, field_name, ref field_type, comma))
            }
            let rp = when self.expect(.RParen(), "')'") is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }
            return .Ok(.Type(vis, mods, kw, gp, name,
                ref .Struct(lp, fields, rp)))
        }

        // Union body: { .Variant1, .Variant2(T) }
        if self.check(.LBrace()) then {
            let lb = self.eat()
            let mut cases = [CstItem ref]List.new()
            while not self.check(.RBrace()) and not self.is_eof() then {
                let nl_count = self.count_newlines()
                if nl_count >= 2 then {
                    self.skip_newlines()
                    cases.push(ref .BlankLine())
                    continue
                }
                self.skip_newlines()
                if self.check(.RBrace()) or self.is_eof() then { break }
                if self.peek() is .LineComment(_) or .BlockComment(_) then {
                    let c = self.eat()
                    let prev_is_code = {
                        if cases.count() > 0 then {
                            let prev = deref cases[cases.count() - 1]
                            when prev is { .Decl(_) or .Stmt(_) then true, _ then false }
                        } else {
                            false
                        }
                    }
                    if nl_count == 0 and prev_is_code then {
                        cases.push(ref .TrailingComment(c))
                    } else {
                        cases.push(ref .Comment(c))
                    }
                    continue
                }
                let expr = when self.parse_union_variant_expr() is {
                    .Ok(e) then e,
                    .Error(e) then { return .Error(e) },
                }
                when self.expect(.Comma(), "','") is {
                    .Ok(_) then {},
                    .Error(e) then { return .Error(e) },
                }
                let s = CstStmt.ExprStmt(ref expr, .None())
                cases.push(ref .Stmt(ref s))
            }
            let rb = when self.expect(.RBrace(), "'}'") is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }
            return .Ok(.Type(vis, mods, kw, gp, name,
                ref .Union(lb, cases, rb)))
        }

        // Alias: = OtherType
        if self.check(.Eq()) then {
            let eq = when self.expect(.Eq(), "'='") is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }
            let target = when self.parse_type_node() is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }
            return .Ok(.Type(vis, mods, kw, gp, name,
                ref .Alias(eq, ref target)))
        }

        // Empty (foreign type)
        return .Ok(.Type(vis, mods, kw, gp, name, ref .Empty()))
    }

    private parse_union_variant_expr(self ref) [CstExpr]Result = {
        let name = when self.expect_ident("union variant name") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }

        let mut lp = [Token]Option.None()
        let mut fields = [CstUnionField]List.new()
        let mut rp = [Token]Option.None()

        if self.check(.LParen()) then {
            lp = .Some(self.eat())
            while not self.check(.RParen()) and not self.is_eof() then {
                let field_name = when self.expect_ident("union field name") is {
                    .Ok(t) then t,
                    .Error(e) then { return .Error(e) },
                }
                let field_type = when self.parse_type_node() is {
                    .Ok(t) then t,
                    .Error(e) then { return .Error(e) },
                }
                let comma = self.eat_comma()
                fields.push(CstUnionField(field_name, ref field_type, comma))
            }
            rp = .Some(when self.expect(.RParen(), "')'") is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            })
        }

        return .Ok(.UnionVariant(name, lp, fields, rp))
    }

    // ========================================================================
    // Trait declaration
    // ========================================================================

    private parse_trait_decl(self ref) [CstDecl]Result = {
        let vis = self.eat_vis()
        let kw = when self.expect(.KwTrait(), "'trait'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let gp = when self.parse_generic_params() is {
            .Ok(g) then g,
            .Error(e) then { return .Error(e) },
        }
        let name = when self.expect_ident("trait name") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }

        // Super traits (before {)
        let mut supers = [CstType ref]List.new()
        while not self.check(.LBrace()) and not self.is_eof() then {
            if self.peek_raw() is .Newline or .EOF then { break }
            let t = when self.parse_type_node() is {
                .Ok(it) then it,
                .Error(e) then { return .Error(e) },
            }
            supers.push(ref t)
        }

        let lb = when self.expect(.LBrace(), "'{'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let members = when self.parse_trait_members() is {
            .Ok(ms) then ms,
            .Error(e) then { return .Error(e) },
        }
        let rb = when self.expect(.RBrace(), "'}'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        return .Ok(.Trait(vis, kw, gp, name, supers, lb, members, rb))
    }

    // ========================================================================
    // Trait members
    // ========================================================================

    private parse_trait_members(self ref) [[CstItem ref]List]Result = {
        let mut members = [CstItem ref]List.new()
        while not self.check(.RBrace()) and not self.is_eof() then {
            let nl_count = self.count_newlines()
            if nl_count >= 2 then {
                self.skip_newlines()
                members.push(ref .BlankLine())
                continue
            }
            self.skip_newlines()
            if self.check(.RBrace()) or self.is_eof() then { break }
            if self.check(.Semi()) then {
                self.eat()
                continue
            }
            if self.peek() is .LineComment(_) or .BlockComment(_) then {
                let c = self.eat()
                let prev_is_code = {
                    if members.count() > 0 then {
                        let prev = deref members[members.count() - 1]
                        when prev is { .Decl(_) or .Stmt(_) then true, _ then false }
                    } else {
                        false
                    }
                }
                if nl_count == 0 and prev_is_code then {
                    members.push(ref .TrailingComment(c))
                } else {
                    members.push(ref .Comment(c))
                }
                continue
            }
            when self.parse_trait_method_sig() is {
                .Ok(d) then { members.push(ref .Decl(ref d)) },
                .Error(e) then { return .Error(e) },
            }
        }
        return .Ok(members)
    }

    private parse_trait_method_sig(self ref) [CstDecl]Result = {
        let vis = self.eat_vis()
        let gp = when self.parse_generic_params() is {
            .Ok(g) then g,
            .Error(e) then { return .Error(e) },
        }
        let name = when self.expect_ident("method name") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let lp = when self.expect(.LParen(), "'('") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let mut params = [CstTraitMethodParam]List.new()
        while not self.check(.RParen()) and not self.is_eof() then {
            // self or self ref
            if self.peek() is .KwSelf then {
                let kw = self.eat()
                if self.peek() is .KwRef then {
                    let ref_kw = self.eat()
                    let comma = self.eat_comma()
                    params.push(.SelfRefParam(kw, ref_kw, comma))
                } else {
                    let comma = self.eat_comma()
                    params.push(.SelfParam(kw, comma))
                }
                continue
            }
            // name Type
            let pname = when self.expect_ident("parameter name") is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }
            let pt = when self.parse_type_node() is {
                .Ok(t) then t,
                .Error(e) then { return .Error(e) },
            }
            let comma = self.eat_comma()
            params.push(.NamedParam(pname, ref pt, comma))
        }
        let rp = when self.expect(.RParen(), "')'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        // Return type (optional)
        let mut ret = [CstType ref]Option.None()
        if not self.check(.RBrace()) and not self.is_eof() then {
            if self.peek_raw() is not .Newline then {
                let t = when self.parse_type_node() is {
                    .Ok(it) then it,
                    .Error(e) then { return .Error(e) },
                }
                ret = .Some(ref t)
            }
        }
        return .Ok(.TraitMethod(vis, gp, name, lp, params, rp, ret))
    }

    // ========================================================================
    // Given declaration
    // ========================================================================

    private parse_given_decl(self ref) [CstDecl]Result = {
        let vis = self.eat_vis()
        let mods = self.eat_modifiers()
        let kw = when self.expect(.KwGiven(), "'given'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let gp = when self.parse_generic_params() is {
            .Ok(g) then g,
            .Error(e) then { return .Error(e) },
        }

        // Target type (may be complex like [T, R]EnumerateStreamIterator)
        let target = when self.parse_type_node() is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }

        let lb = when self.expect(.LBrace(), "'{'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        let members = when self.parse_member_items() is {
            .Ok(ms) then ms,
            .Error(e) then { return .Error(e) },
        }
        let rb = when self.expect(.RBrace(), "'}'") is {
            .Ok(t) then t,
            .Error(e) then { return .Error(e) },
        }
        return .Ok(.Given(vis, mods, kw, gp, ref target, lb, members, rb))
    }

    // ========================================================================
    // Member items (shared by trait/given)
    // ========================================================================

    private parse_member_items(self ref) [[CstItem ref]List]Result = {
        let mut members = [CstItem ref]List.new()
        while not self.check(.RBrace()) and not self.is_eof() then {
            let nl_count = self.count_newlines()
            if nl_count >= 2 then {
                self.skip_newlines()
                members.push(ref .BlankLine())
                continue
            }
            self.skip_newlines()
            if self.check(.RBrace()) or self.is_eof() then { break }
            if self.check(.Semi()) then {
                self.eat()
                continue
            }
            if self.peek() is .LineComment(_) or .BlockComment(_) then {
                let c = self.eat()
                let prev_is_code = {
                    if members.count() > 0 then {
                        let prev = deref members[members.count() - 1]
                        when prev is { .Decl(_) or .Stmt(_) then true, _ then false }
                    } else {
                        false
                    }
                }
                if nl_count == 0 and prev_is_code then {
                    members.push(ref .TrailingComment(c))
                } else {
                    members.push(ref .Comment(c))
                }
                continue
            }
            // Determine if this is a let-decl or a method without let
            let mut offset UInt = 0
            if self.is_access_mod() then { offset = 1 }
            let after_access = self.peek_at_skip_nl(offset)
            if after_access is .KwForeign or .KwIntrinsic then { offset += 1 }
            let kw = self.peek_at_skip_nl(offset)
            when kw is {
                .KwLet then {
                    when self.parse_let_decl() is {
                        .Ok(d) then { members.push(ref .Decl(ref d)) },
                        .Error(e) then { return .Error(e) },
                    }
                },
                _ then {
                    // Method without let keyword
                    when self.parse_member_no_let() is {
                        .Ok(d) then { members.push(ref .Decl(ref d)) },
                        .Error(e) then { return .Error(e) },
                    }
                },
            }
        }
        return .Ok(members)
    }

    private parse_member_no_let(self ref) [CstDecl]Result = {
        let vis = self.eat_vis()
        let mods = self.eat_modifiers()
        // Generic params and name are handled by finish_func_or_var
        self.finish_func_or_var(vis, mods, .None(), .None(), true)
    }
}
