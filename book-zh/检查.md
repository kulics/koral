# 检查
程序可能会出现各种各样的异常。

- 可能是文件或者用户输入的内容导致的。
- 可能是编码错误或语言中缺少的功能。
- 当然，也可能是由于许多其他不可预知的因素。

异常无法完全避免，但是我们可以选择一些手段帮助我们检查和报告异常。

## 报告异常
我们可以在函数中的任何地方，使用`!~`来声明一个异常数据。

例如：
```
ReadFile : $(name:str)->()
{
    ? name.Length == 0
    {
        !~ #Exception.("something wrong");
    };
};
```
这样我们就声明了一个异常，异常说明是`something wrong`，一旦外部调用者使用了不合法长度的`name`，这个异常就会向上报告，直到被处理或者被忽略。
## 检查异常
我们可以在调用函数的时候，使用`!`和辅助符号`~`来检查可能会有异常的区块。

例如：
```
!
{
    ReadFile.("temp.txt");
}
~ err
{
    Console.WriteLine.(err.message);
};
```
在这里，`!`区块表示所有受到检查的功能逻辑，`~ err`表示将错误数据定义为标识符`err`，其作用就像入参。

一旦读取文件函数出现了异常，就会检查出`err`并执行打印功能，如果没有，则一切正常，不会进入异常处理部分的功能。

同样的，检查逻辑也在函数内，所以如果有处理不了的异常，可以继续向上报告。

例如：
```
...
~ err 
{ 
    !~ err; 
};
```
那么我们怎么区分不同类型的异常呢？

很简单，我们在标识符后面指定类型即可。

例如:
```
~ e : IOException
{
    ...
};
```

## 检查延迟
如果我们有一段功能希望无论程序正常或异常都能处理，例如关键资源的释放问题，我们可以使用检查延迟特性。

很简单，使用`~!`就能声明一段检查延迟的语句。

例如：
```
func : $()->()
{
    file : ReadFile.("./somecode.xy");
    ~!
    {
        file.Release.();  
    };
    ...
};
```
这样我们就声明了`file.Release.();`这条释放文件的语句，这条语句不会被立刻执行，而是会等待函数退出前调用。

有了检查延迟，我们就可以无需关心函数如何退出，安全地处理某些任务。

需要注意的是，正因为检查延迟是函数退出前执行的，并且无论程序运行状态异常与否都会执行，所以检查延迟中不能使用返回语句。

例如：
```
...
~!
{
    file.Release.();  
    <- (); // 错误，不能使用返回语句
};
```

### 检查延迟顺序
特别的，如果在一个语句块中使用了多个`~!`，最终执行是按照倒序逐个执行`~!`中的语句。这是因为`~!`都是放在最后执行的，所以先声明的就会最后执行，因此多个`~!`就会按照声明的倒序来执行。

例如：
```
~! { Console.WriteLine.("1"); };
~! { Console.WriteLine.("2"); };
~! { Console.WriteLine.("3"); };

// 最终显示 3 2 1
```

### 检查延迟作用域
检查延迟的有效作用域仅仅是当前最靠近自己的一层语句块，这对于我们控制执行区域非常有帮助。

例如：
```
func : $()->()
{
    ...
    @ [0~5] ~ index
    {
        // 不会影响到循环外的逻辑
        ~! { Console.WriteLine.(index + 1); };
        Console.WriteLine.(index);
    };
    ...
};
```
### [下一章](异步处理.md)