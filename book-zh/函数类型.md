# 函数类型
函数是用来完成特定任务的独立的代码块。

通常我们会将一系列需要重复使用的任务处理封装成为函数，方便在其它地方重复使用。

在实际工程实践中，给与确定的输入，必定会准确返回确定输出的函数被视为是较好的设计。所以建议尽可能地保持函数地独立性。
## 定义
之前我们已经见过了主入口函数，它只使用了固定语句 `Main () {}` 来定义。

主入口函数是一个特例，实际上这门语言的常规函数都必须明确声明标识符、入参和出参。

我们只需使用 `id ()->() {}` 搭配来定义一个函数，前面的括号为入参，后面的括号为出参。

例如：
```
function ()->()
{
    ...
}
```
这样便定义了一个标识符为 `function` 的函数。 

需要注意的是，函数可以在命名空间、包、协议中定义，也可以在函数内部中定义。在函数中定义函数时，内部函数不具有公有特性，只属于当前函数的私有函数。
## 调用
不像主入口函数不能被调用，常规函数都可以使用标识符来调用，我们只需要使用 `id.()` 语句就可以使用封装好的函数。

例如：
```
function.()  // 调用了 function
```
## 参数
虽然函数可以没有任何参数只执行特定的功能，但是更多时候我们需要的是可以接收某些输入数据、或是可以返回数据、或者两者都有的功能，而这需要参数出场来帮助我们完成任务。

非常简单的，我们只需要使用 `id:type` 就可以声明参数。

例如：
```
func (x:I32)->(y:I32)
{
    <- (x * 2)
}
```
这个函数的意义是，接受输入的一个 `I32` 参数 `x`，返回一个 `I32` 参数 `y`。

这和什么非常相似？没错，其实参数和字典的功能是几乎一致的，参数只是告诉函数，我们需要使用这个类型的数据，通过标识符来标记匹配。所以参数的表达和字典相同，有助于我们理解。

靠左边的括号内是入参，靠右边的括号内是出参，括号内的参数没有数量限制，但是对顺序和类型有严格要求。
## 参数简写
如果我们需要连续几个相同类型的参数，那么可以简写类型，只需要在最后一个同类型的参数编写类型即可。

例如：
```
func (a, b, c:I32, d:Str)->(a:Str, b, c, d:I32)
{
    <- (d, a, b, c)
}
```
### 返回
到这里，即使不明说，大致你也可以猜到 `<-` 应该是一个与返回有关的语句了。

是的，我们只需要使用 `<-` 就可以指定一个明确的返回语句，后面的括号内可以填入需要返回的数据，使用逗号隔开。

例如：
```
<- (1, 2, 3, "Hello")
```
这会返回 `1, 2, 3, "Hello"` 四个值。

和我们调用方法表达相同，我们同样需要使用完整的括号来表达一个返回语句，即使这个函数不需要返回任何数据。

例如：
```
<- ()
```
这样设计的目的为了在语法上保持完整统一。

但如果是一个不需要返回值的函数，语言会自动在函数末尾添加退出功能，因此我们可以选择性省略部分返回语句。

我们可以在函数内的任何一个地方使用返回语句提前终止函数，这样可以满足我们对逻辑控制的需求。

需要注意的是，与循环的跳出一样，返回语句只会中止距离自己最近的一层函数。
### 入参
我们把输入进函数的参数称之为入参，入参可以没有或多个，对类型和标识符没有限制。

当我们调用函数时，需要按照定义好的顺序，将数据按顺序填入括号内。顺序或类型不符合时，都会被视为错误使用。

例如：
```
// 定义一个包含两个入参的函数
sell (price:I32, name:Str)->(){}
// 按照定义的要求，填入符合要求的数据
sell.(1.99, "cola")
```
### 出参
和入参类似，出参也需要在定义时明确带有标识符，这能让调用者更容易获取函数的作用信息。

例如：
```
topSell ()->(name:Str, count:I32)
{
    ...
    <- ("cola", many)
}
```
### 返回值的使用
那么我们如何获取一个函数的返回值呢？

很简单，就像我们做加减乘除运算一样去使用函数即可。

不同的是对于多返回值我们必须要像参数形式一样使用括号包裹每个标识符。

例如:
```
(n, c) := topSell.()    // 将返回的两个值定义给 n 和 c
(n, c) = topSell.()     // 将返回的两个值覆盖赋值给 n 和 c
```
你可以使用定义或赋值语句去获得函数的返回值来使用，也可以将符合要求的函数嵌套到另一个函数里使用。

例如：
```
Console.WriteLine.( topSell.() )      // 打印两个数值
```
如果只有一个返回值，括号可带可不带。

需要注意的是，如果调用了一个带有返回值的函数，是不允许不接收返回值的，因为这样经常会导致无意疏忽丢失了重要数据。

例如：
```
topSell.()      // 错误，没有明确接收返回值
```
但是有时候，作为调用者，我们未必需要所有的返回值，这个时候，我们可以使用匿名标识符 `_` 来帮助我们丢弃数据。只需要将它写在对应位置即可。

例如：
```
name, _ := topSell.()
```
如果确实所有返回值都不需要，我们也可以只写一个 `_` 来丢弃所有。但是为什么会需要调用这样的函数呢？也许我们应该再好好回顾下代码。

例如：
```
_ = topSell.()      // 对于 _ 来说，赋值和定义是等价的
```
## 函数入参
如果我们希望函数的部分细节由外部定义，内部只执行其余的部分逻辑，比如对某个集合遍历处理一些功能，这时我们可以使用函数入参来完成这个目标。

函数入参没有特别的定义方式，只是将参数的类型替换为函数，不需要定义函数执行内容。

例如：
```
each1To10 (func: (item:I32)->() )->()
{
    [1~10].@
    {
        func.(it)
    }
}
```
我们定义了一个名为`func`的函数入参，它的类型一个只有`item`入参的函数。

这样我们就能将处理的细节交给外部传入的`func`定义了。

例如：
```
print (item:I32)->()
{
    Console.WriteLine.(item)
}

each1To10.(print)
```
如此，我们就在`each1To10`内部的循环中执行了`print`函数。

函数入参只要求函数的参数类型相同，不要求参数的命名相同。

## Lambda 表达式
如上面那种方式先定义一个函数再传入使用有时候显得比较啰嗦，因为我们仅仅只是希望执行一小段功能而已，未必想定义一个函数提供给其它地方使用。

这时我们可以使用 Lambda 表达式 的语法来减少我们编码的痛苦。

因为函数入参在声明时就已经确定了，所以我们可以使用简化的语法`(id,id) <- expression`来表达，它的意思是定义入参标识符，直接返回一条表达式。

当`id`只有一个时，可以省略`()`。

例如：
```
each1To10.( it <- Console.WriteLine.(it) )
findAll.( it <- it > 7 )
order.( it <- it.time )
take.( (a, b) <- a + b )
```
非常简单，和函数类型的表达的差异在于，入参只需要声明标识符，而出参则只能用来包裹一条表达式。

如果一条表达式还不够，也可以返回一段函数，只需要使用`{}`声明即可。

例如：
```
each.( it <- 
{
    Console.WriteLine.(1)
    Console.WriteLine.(2)
    Console.WriteLine.(3)
})
```

## Lambda 函数
与上面的简化写法不同，我们也可以直接写入一个完整的函数，就像我们定义函数一样。

例如：
```
each1To10.( (item:I32)->() 
{
    Console.WriteLine.(item)
})
```

### [下一章](控制类型.md)

## 本章示例
```
Demo
{
    .. System

    Main ()
    {
        A.()
        B.(1,2,3)
        x := C.()
        D.( ()<- Console.WriteLine.("D") )
        E.( it <- Console.WriteLine.(it) )
        E.( (a:I32)->()
        {
            Console.WriteLine.(it)
        })
    }

    A ()->(){}

    B (a,b,c :I32)->(){}

    C ()->(a:I32)
    {
        <- (1024)
    }

    D (fn: ()->() )->()
    {
        fn.()
    }

    E (fn: (a:I32)->() )->()
    {
        [1<<20].@
        {
            fn.(it)
        }
    }
}
```