# 协议
我们在现实中常常用协议来规定一些特定的规则，让人或事物可以按照预期的规则来做事情。
我们在程序语言里也常常需要这么做，这个功能就是协议。

协议规定用来实现某一特定功能所必需的方法和属性，让包来遵守。

我们的包可以像签署协议一样引入我们需要的协议，然后声明协议要求的所有属性，这样我们就认为这个包签署了协议。
## 定义
我们只需要使用 `id <- {}` 语句就可以定义一个协议。

例如：
```
Protocol <- {
}
```
这就是一个空的协议。

接下来，让我们设计一个学生都需要完成的艰巨任务……作业。

例如：
```
Homework <- {
    count(): Int
    do() -> ()
}
```
这是一个作业协议，它有两个属性，一个是需要做作业的数量，一个是完成作业的函数。

定义的方式和包内定义属性的方式如出一辙。

与包不同的是，协议定义时属性不需要具体的数值或函数内容，只需要确定类型。

接下来，我们就要让学生来实现这个协议了。
## 实现协议
我们可以在包声明后面，使用 `protocol {}` 语句来实现这个协议。

例如：
```
Student -> {
    ......
} Homework {
    count(): Int

    do() -> () {
        Spend time(1)    # 花费了一个小时 #
        count -= 1      # 完成了一个 #
    }
}
```
我们的学生写作业真是非常艰苦的……

让我们来解释一下这段代码发生了什么：
1. 我们实现了一个协议，现在 `Student` 也被认为是 `Homework` 类型了，我们可以将一个 `Student` 当作 `Homework` 一样去使用。
1. 在协议内我们包含了协议规定的两个属性 `count, do` ，根据规定，一个也不能少。
1. 我们给协议的两个属性都分别编写了真实的值和函数，这样这两个属性就成为了 `Student` 的有效子属性之一。
1. 我们在 `do` 里面做了一些事情，减少了作业的总量。

## 使用协议
包含了协议之后，我们就能使用拥有协议的学生包了。

例如：
```
Peter := Student{ count=999999 }
Prt( Peter.count )
# 打印 999999，好多呀 #
Peter.do()
# 做了一次作业 #
Prt( Peter.count )
# 打印 999998，还是好多呀 #
```
如果只是这样使用，那和在包里直接定义这两个属性比就没什么优势了。

让我们来回想一下协议的作用，协议是让每个包含了协议的包都拥有了规定的相同的属性和方法。

这样对于协议的制定者来说，就无需关心包是如何遵循协议的，只需要知道它们都遵循了，就能用同样的方法去使用它们。

现在我们可以创建各种各样的学生，它们都遵循了一样的协议，我们可以无差别使用协议里的功能。

例如:
```
# 创建了三个不同类型的学生包 #
Student A := Chinese Student{}
Student B := American Student{}
Student C := Japanese Student{}
# 让他们分别做作业 #
Student A.do()
Student B.do()
Student C.do()
```
更有效率的做法是把这个功能写进函数，让函数来帮我们重复调用协议的功能。

例如：
```
Do homework(Student: Homework) -> () {
    student.do()
}
# 现在我们就可以更简单地让每个学生做作业了 #
Do homework(Student A)
Do homework(Student B)
Do homework(Student C)
```
当然，更好的做法是把这些学生都放进数组，这样我们就可以使用循环来处理这些重复的工作了。

例如：
```
Arr := []homeWork{}
Arr.add( Student A )
...... # 塞进很多很多学生 #
Arr @ i {
    Do homework(i)
}
```
╮（￣▽￣）╭  
完美

## 类型判断
因为包类型可以被转为协议类型使用，所以在使用过程中就不能确定数据的原始类型。

但有时候我们又需要获得数据的原始类型来处理，我们可以使用类型判断来帮助我们完成这个事情。

我们可以使用 `value == :type` 或 `value >< :type` 来判断数据的类型，使用 `value:type` 来将数据转化为我们的类型。

例如：
```
Func(hw: Homework) -> () {
    # 判断是否中国学生 #
    ? hw == :Chinese Student {
        # 转换为中国学生数据 #
        Cs := hw:Chinese Student
    }
}
```

### [下一章](enumeration-type.md)

## 本章示例
```
"Demo" {
    "System"
}

Main() -> () {
    P := B{}
    P.do()
    C( P )
}

A <- {
    x(): Int
    do() -> () {}
}

B -> {
    y := 5
} A {
    x() := 0
    do() -> () {
        x += 1
    }
}

C(a: A) -> () {
    a.do()
    ? a == :B {
        Prt( a:B.y )
    }
}
```