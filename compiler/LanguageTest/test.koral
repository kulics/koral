// variable
let x Int = 5;
let y Float = 3.2;
let z String = "Hello";
let b Bool = true;
// function
let add(x Int, y Int) Int = x + y;
let subtract(x Int, y Int) Int = x - y;
let multiply(x Int, y Int) Int = x * y;
let divide(x Int, y Int) Int = x / y;
let modulo(x Int, y Int) Int = x % y;
let compare(x Int, y Int) Bool = x == y;
let not_equal(x Int, y Int) Bool = x <> y;
let greater(x Int, y Int) Bool = x > y;
let less(x Int, y Int) Bool = x < y;
let blockExample(a Int, b Int) Int = {
    let result Int = a * b;
    result
};
let mut x_mut Int = 5;
let change_x() Int = {
    x_mut = 10;
    x_mut
};
let ifExample(x Int, y Int) Int = {
    if x > y then {
        x
    } else if x < y then {
        y
    } else 0
};
let whileExample() Void = {
    let mut counter Int = 0;
    while counter < 5 then {
        counter = counter + 1;
    }
};
let whileSum() Int = {
    let mut sum Int = 0;
    let mut i Int = 1;
    while i <= 10 then {
        sum = sum + i;
        i = i + 1;
    };
    sum
};
let voidExample() Void = if true then {} else {};
let voidExample2() Void = {
    let a Void = {};
    a
};
let callFunction() Int = {
    add(1, 2)
};
let voidFunction() Void = {};
let voidFunction2() Void = {
    let x Int = 5;
};

let shortCircuit(x Int) Int = {
    let a Bool = x > 0;
    let b Bool = x < 10;
    if a and b then {
        1
    } else if not a or b then {
        2
    } else {
        3
    }
};

let conditionExample(x Int, y Int) Int = {
    if x > 0 and y > 0 then {
        1
    } else if not x < 0 or y == 0 then {
        2
    } else {
        3
    }
};

type val ValFoo(x Int, y Int);
type val ValBar(x Bool);

let use_ValFoo(a ValFoo) Void = {};
let make_ValFoo() ValFoo = ValFoo(1, 2);
let make_ValBar() ValBar = ValBar(true);
let access_member_of_ValFoo(a ValFoo) Int = a.x + a.y;

type Foo(x Int, mut y Int);

let access_member_of_Foo(a Foo) Int = a.x + a.y;
let use_Foo(a Foo) Void = {};
let make_Foo() Foo = Foo(1, 2);
let move_Foo(a Foo) Foo = a;
let lifetime_test() Void = {
    let x Foo = make_Foo();
    let mut y Foo = make_Foo();
    y = x;
    y = move_Foo(make_Foo());
    use_Foo(x);
};

type Bar(mut a Foo, mut b Foo);
let access_member_of_Bar(a Bar) Int = a.a.x + a.a.y + a.b.x + a.b.y;
let use_Bar(a Bar) Void = {};
let make_Bar() Bar = Bar(Foo(1, 2), Foo(2, 1));
let move_Bar(a Bar) Bar = a;
let member_assignment(a Bar) Void = {
    let c Foo = a.b;
    a.b = c;
    a.b = a.b;
    a.a.y = 2;
};

let ref_func(a Foo ref) Int = {
    a.x
};

// let [T]genericFunction(a T) T = a;

type Point(x Int, y Int);

given Point {
    area(self Point) Int = self.x * self.y;
};

let testInference() Int = {
    let a = 10;
    let b = 20;
    a + b
};

let testGiven() Int = {
    let p = Point(10, 20);
    p.area()
};

let main() Int = {
    // while true then lifetime_test();
    let x = make_Foo();
    ref_func(ref x);
    testGiven();
    testInference()
};
