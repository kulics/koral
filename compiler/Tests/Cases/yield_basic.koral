// Test basic yield keyword functionality
// EXPECT: 42
// EXPECT: 7
// EXPECT: hello
// EXPECT: 10
// EXPECT: 20
// EXPECT: 99
// EXPECT: void_block_ok
// EXPECT: empty_block_ok
// EXPECT: nested_yield_ok
// EXPECT: All yield basic tests passed

// Test 1: yield in function body
let get_value() Int = {
    yield 42
}

// Test 2: yield with computation
let compute() Int = {
    let a = 3
    let b = 4
    yield a + b
}

// Test 3: yield with String
let get_greeting() String = {
    let name = "hello"
    yield name
}

// Test 4: yield in if/else branches
let pick(flag Bool) Int = {
    yield if flag then {
        yield 10
    } else {
        yield 20
    }
}

// Test 5: yield in when branches
type Color {
    Red(),
    Blue(),
}

let color_value(c Color) Int = {
    yield when c is {
        .Red then 99,
        .Blue then 0,
    }
}

// Test 6: block without yield produces Void (used as statement)
let void_block_test() Void = {
    let x = 1
    let y = 2
    let _ = x + y
    // no yield â€” block type is Void
}

// Test 7: empty block produces Void
let empty_block_test() Void = {
}

// Test 8: nested yield in let expression
let nested_yield() Int = {
    let x = {
        let a = 50
        yield a + 49
    }
    yield x
}

let main() Int = {
    println(get_value())
    println(compute())
    println(get_greeting())
    println(pick(true))
    println(pick(false))
    println(color_value(Color.Red()))

    void_block_test()
    println("void_block_ok")

    empty_block_test()
    println("empty_block_ok")

    // Nested yield
    if nested_yield() == 99 then {
        println("nested_yield_ok")
    }

    println("All yield basic tests passed")
    yield 0
}
