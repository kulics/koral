// std.convert float parsing tests
// EXPECT: f64_basic_ok
// EXPECT: f64_negative_ok
// EXPECT: f64_sci_ok
// EXPECT: f64_nan_ok
// EXPECT: f64_inf_ok
// EXPECT: f64_neg_inf_ok
// EXPECT: f64_frac_only_ok
// EXPECT: error_empty_ok
// EXPECT: error_trailing_ok
// EXPECT: f32_basic_ok

using std.convert

let main() Int = {
    // Basic Float64 parse
    when Float64.parse("3.14") is {
        .Ok(f) then {
            // Check approximate value: 3.14 should be > 3.13 and < 3.15
            if f > 3.13 and f < 3.15 then print_line("f64_basic_ok")
            else print_line("FAIL f64_basic")
        },
        .Error(e) then print_line("FAIL f64_basic: " + e.message()),
    }

    // Negative float
    when Float64.parse("-2.5") is {
        .Ok(f) then {
            if f < (0.0 - 2.4) and f > (0.0 - 2.6) then print_line("f64_negative_ok")
            else print_line("FAIL f64_negative")
        },
        .Error(e) then print_line("FAIL f64_negative: " + e.message()),
    }

    // Scientific notation
    when Float64.parse("1.5e2") is {
        .Ok(f) then {
            if f > 149.0 and f < 151.0 then print_line("f64_sci_ok")
            else print_line("FAIL f64_sci")
        },
        .Error(e) then print_line("FAIL f64_sci: " + e.message()),
    }

    // NaN
    when Float64.parse("NaN") is {
        .Ok(f) then {
            if f.is_nan() then print_line("f64_nan_ok")
            else print_line("FAIL f64_nan")
        },
        .Error(e) then print_line("FAIL f64_nan: " + e.message()),
    }

    // Inf
    when Float64.parse("Inf") is {
        .Ok(f) then {
            if f.is_inf() then print_line("f64_inf_ok")
            else print_line("FAIL f64_inf")
        },
        .Error(e) then print_line("FAIL f64_inf: " + e.message()),
    }

    // -Inf
    when Float64.parse("-Inf") is {
        .Ok(f) then {
            if f.is_inf() and f.is_sign_negative() then print_line("f64_neg_inf_ok")
            else print_line("FAIL f64_neg_inf")
        },
        .Error(e) then print_line("FAIL f64_neg_inf: " + e.message()),
    }

    // Fractional only (.5)
    when Float64.parse(".5") is {
        .Ok(f) then {
            if f > 0.49 and f < 0.51 then print_line("f64_frac_only_ok")
            else print_line("FAIL f64_frac_only")
        },
        .Error(e) then print_line("FAIL f64_frac_only: " + e.message()),
    }

    // Error: empty string
    when Float64.parse("") is {
        .Ok(f) then print_line("FAIL error_empty"),
        .Error(e) then print_line("error_empty_ok"),
    }

    // Error: trailing characters
    when Float64.parse("3.14abc") is {
        .Ok(f) then print_line("FAIL error_trailing"),
        .Error(e) then print_line("error_trailing_ok"),
    }

    // Float32 basic
    when Float32.parse("2.5") is {
        .Ok(f) then {
            if (Float64)f > 2.4 and (Float64)f < 2.6 then print_line("f32_basic_ok")
            else print_line("FAIL f32_basic")
        },
        .Error(e) then print_line("FAIL f32_basic: " + e.message()),
    }

    yield 0
}
