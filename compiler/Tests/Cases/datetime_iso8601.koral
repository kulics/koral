// EXPECT: utc_format_ok
// EXPECT: fixed_format_ok
// EXPECT: nanos_format_ok
// EXPECT: parse_roundtrip_ok
// EXPECT: parse_invalid_ok
// EXPECT: parse_empty_ok

using std.time.*

let main() Int = {
    // UTC format ends with Z
    let epoch = DateTime.epoch()
    let s1 = epoch.to_iso8601()
    // 1970-01-01T00:00:00Z
    assert(s1 == "1970-01-01T00:00:00Z", "utc format")
    print_line("utc_format_ok")

    // Fixed offset format
    let r1 = TimeZone.from_offset(Duration.from_secs(28800))
    if r1 is .Ok(tz) then {
        // 1970-01-01T00:00:00Z in +08:00 = 1970-01-01T08:00:00+08:00
        let dt = epoch.in_timezone(tz)
        let s = dt.to_iso8601()
        assert(s == "1970-01-01T08:00:00+08:00", "fixed format")
    } else {
        assert(false, "tz err")
    }
    print_line("fixed_format_ok")

    // Nanos format: trailing zeros trimmed
    let r2 = DateTime.from_components(2024, 1, 15, 10, 30, 0, 123_000_000, TimeZone.utc())
    if r2 is .Some(dt) then {
        let s = dt.to_iso8601()
        assert(s == "2024-01-15T10:30:00.123Z", "nanos format")
    } else {
        assert(false, "nanos should be Some")
    }
    print_line("nanos_format_ok")

    // parse roundtrip: parse(dt.to_iso8601()) preserves unix_secs
    let r3 = DateTime.from_components(2024, 6, 15, 14, 30, 45, 0, TimeZone.utc())
    if r3 is .Some(dt) then {
        let iso = dt.to_iso8601()
        let parsed = DateTime.parse_iso8601(iso)
        if parsed is .Some(dt2) then {
            assert(dt2.to_unix_secs() == dt.to_unix_secs(), "parse rt secs")
        } else {
            assert(false, "parse should be Some")
        }
    } else {
        assert(false, "rt should be Some")
    }
    print_line("parse_roundtrip_ok")

    // parse invalid string
    let r4 = DateTime.parse_iso8601("not-a-date")
    if r4 is .Some(_) then { assert(false, "invalid should be None") }
    print_line("parse_invalid_ok")

    // parse empty string
    let r5 = DateTime.parse_iso8601("")
    if r5 is .Some(_) then { assert(false, "empty should be None") }
    print_line("parse_empty_ok")

    0
}
