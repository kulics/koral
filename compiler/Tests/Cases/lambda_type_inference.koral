// Lambda type inference test
// EXPECT: 42

// Helper function for Test 5
let apply(f [Int, Int]Func, x Int) Int = f(x)

let main() Int = {
    // Test 1: Infer parameter types from variable type annotation
    let f1 [Int, Int]Func = (x) -> x * 2
    let r1 = f1(21)  // 42
    print_line(r1)
    
    // Test 2: Infer multiple parameter types
    let f2 [Int, Int, Int]Func = (x, y) -> x + y
    let r2 = f2(20, 22)  // 42
    print_line(r2)
    
    // Test 3: Infer return type from body
    let f3 [Int, Int]Func = (x Int) -> x * 2
    let r3 = f3(21)  // 42
    print_line(r3)
    
    // Test 4: Mixed - some params typed, some inferred
    let f4 [Int, Int, Int]Func = (x Int, y) -> x + y
    let r4 = f4(20, 22)  // 42
    print_line(r4)
    
    // Test 5: Infer from function parameter context
    let r5 = apply((x) -> x * 2, 21)  // 42
    print_line(r5)
    
    // Test 6: Infer with block body
    let f6 [Int, Int]Func = (x) -> {
        let y = x + 1
        y * 2
    }
    let r6 = f6(20)  // (20 + 1) * 2 = 42
    print_line(r6)
    
    // Test 7: Nested function type inference (with explicit inner type)
    let f7 [Int, [Int, Int]Func]Func = (x) -> (y Int) -> x + y
    let adder = f7(40)
    let r7 = adder(2)  // 40 + 2 = 42
    print_line(r7)
    
    r1
}
