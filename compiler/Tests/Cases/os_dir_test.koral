// EXPECT: create_read_remove_ok
// EXPECT: create_dir_all_ok
// EXPECT: read_dir_entries_ok
// EXPECT: walk_dir_ok
// EXPECT: create_temp_dir_ok

using std.os.*

type Counter(mut value Int)

let main() Void = {
    let base = join_path(temp_dir(), "os_dir_test")
    when remove_dir_all(base) is {
        .Ok(_) then {},
        .Error(_) then {},
    }
    create_dir_all(base).unwrap()

    // ========================================================================
    // Test 1: create_dir / remove_dir
    // ========================================================================
    let d1 = join_path(base, "single")
    create_dir(d1).unwrap()
    assert(is_dir(d1), "create_dir exists")
    assert(path_exists(d1), "create_dir path_exists")

    remove_dir(d1).unwrap()
    assert(not path_exists(d1), "remove_dir gone")

    print_line("create_read_remove_ok")

    // ========================================================================
    // Test 2: create_dir_all (nested)
    // ========================================================================
    let nested = join_path(base, "a/b/c")
    create_dir_all(nested).unwrap()
    assert(is_dir(nested), "create_dir_all nested")
    assert(is_dir(join_path(base, "a/b")), "create_dir_all parent")
    assert(is_dir(join_path(base, "a")), "create_dir_all grandparent")

    // remove_dir_all
    remove_dir_all(join_path(base, "a")).unwrap()
    assert(not path_exists(join_path(base, "a")), "remove_dir_all")

    print_line("create_dir_all_ok")

    // ========================================================================
    // Test 3: read_dir with DirEntry properties
    // ========================================================================
    let rd_dir = join_path(base, "readdir")
    create_dir(rd_dir).unwrap()

    write_text(join_path(rd_dir, "file1.txt"), "a").unwrap()
    write_text(join_path(rd_dir, "file2.txt"), "b").unwrap()
    create_dir(join_path(rd_dir, "subdir")).unwrap()

    let entries = read_dir(rd_dir).unwrap()
    assert(entries.count() == 3, "read_dir count")

    let mut found_file = false
    let mut found_dir = false
    for entry = entries then {
        if entry.name() == "file1.txt" then {
            assert(entry.is_file(), "entry is_file")
            assert(not entry.is_dir(), "entry not is_dir")
            assert(entry.file_type().to_string() == "file", "entry type string")
            // path should contain the parent dir
            assert(entry.path().contains("readdir"), "entry path contains parent")
            found_file = true
        }
        if entry.name() == "subdir" then {
            assert(entry.is_dir(), "subdir is_dir")
            assert(not entry.is_file(), "subdir not is_file")
            found_dir = true
        }
    }
    assert(found_file, "found file entry")
    assert(found_dir, "found dir entry")

    // DirEntry.to_string
    let first = entries[0]
    let s = first.to_string()
    assert(s.contains("DirEntry("), "DirEntry to_string prefix")

    print_line("read_dir_entries_ok")

    // ========================================================================
    // Test 4: walk_dir
    // ========================================================================
    let walk_base = join_path(base, "walk")
    create_dir_all(join_path(walk_base, "sub1")).unwrap()
    create_dir_all(join_path(walk_base, "sub2")).unwrap()
    write_text(join_path(walk_base, "root.txt"), "r").unwrap()
    write_text(join_path(walk_base, "sub1/a.txt"), "a").unwrap()
    write_text(join_path(walk_base, "sub2/b.txt"), "b").unwrap()

    // Count visited entries via a reference capture (stable across lambda copies)
    let walk_count = ref Counter(0)
    walk_dir(walk_base, (entry) -> {
        let _ = entry.name()
        walk_count.value += 1
        yield WalkAction.Continue()
    }).unwrap()
    // Should visit: sub1, sub2, root.txt, sub1/a.txt, sub2/b.txt = 5
    assert(walk_count.value == 5, "walk_dir count")

    // walk_dir with Stop - stop after two callbacks
    let stop_count = ref Counter(0)
    walk_dir(walk_base, (entry) -> {
        let _ = entry.name()
        stop_count.value += 1
        yield if stop_count.value == 2 then {
            yield WalkAction.Stop()
        } else {
            yield WalkAction.Continue()
        }
    }).unwrap()
    assert(stop_count.value == 2, "walk_dir stop count")

    print_line("walk_dir_ok")

    // ========================================================================
    // Test 5: create_temp_dir
    // ========================================================================
    let td = create_temp_dir(base, "test_").unwrap()
    assert(is_dir(td), "temp_dir exists")
    assert(td.contains("test_"), "temp_dir prefix")

    // Cleanup
    remove_dir_all(base).unwrap()

    print_line("create_temp_dir_ok")
}
