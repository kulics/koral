// EXPECT: create_read_remove_ok
// EXPECT: create_dir_all_ok
// EXPECT: read_dir_entries_ok
// EXPECT: walk_dir_ok
// EXPECT: create_temp_dir_ok

using std.os.*

type Counter(mut value Int)

let main() Void = {
    let base = temp_dir().join("os_dir_test")
    when remove_dir_all(base) is {
        .Ok(_) then {},
        .Error(_) then {},
    }
    create_dir_all(base).unwrap()

    // ========================================================================
    // Test 1: create_dir / remove_dir
    // ========================================================================
    let d1 = base.join("single")
    create_dir(d1).unwrap()
    assert(is_dir(d1), "create_dir exists")
    assert(path_exists(d1), "create_dir path_exists")

    remove_dir(d1).unwrap()
    assert(not path_exists(d1), "remove_dir gone")

    println("create_read_remove_ok")

    // ========================================================================
    // Test 2: create_dir_all (nested)
    // ========================================================================
    let nested = base.join("a/b/c")
    create_dir_all(nested).unwrap()
    assert(is_dir(nested), "create_dir_all nested")
    assert(is_dir(base.join("a/b")), "create_dir_all parent")
    assert(is_dir(base.join("a")), "create_dir_all grandparent")

    // remove_dir_all
    remove_dir_all(base.join("a")).unwrap()
    assert(not path_exists(base.join("a")), "remove_dir_all")

    println("create_dir_all_ok")

    // ========================================================================
    // Test 3: read_dir with DirEntry properties
    // ========================================================================
    let rd_dir = base.join("readdir")
    create_dir(rd_dir).unwrap()

    write_text_file(rd_dir.join("file1.txt"), "a").unwrap()
    write_text_file(rd_dir.join("file2.txt"), "b").unwrap()
    create_dir(rd_dir.join("subdir")).unwrap()

    let entries = read_dir(rd_dir).unwrap()
    assert(entries.count() == 3, "read_dir count")

    let mut found_file = false
    let mut found_dir = false
    for entry = entries then {
        if entry.name() == "file1.txt" then {
            assert(entry.is_file(), "entry is_file")
            assert(not entry.is_dir(), "entry not is_dir")
            assert(entry.file_type().to_string() == "file", "entry type string")
            // path should contain the parent dir
            assert(entry.path().to_string().contains("readdir"), "entry path contains parent")
            found_file = true
        }
        if entry.name() == "subdir" then {
            assert(entry.is_dir(), "subdir is_dir")
            assert(not entry.is_file(), "subdir not is_file")
            found_dir = true
        }
    }
    assert(found_file, "found file entry")
    assert(found_dir, "found dir entry")

    // DirEntry.to_string
    let first = entries.at(0)
    let s = first.to_string()
    assert(s.contains("DirEntry("), "DirEntry to_string prefix")

    println("read_dir_entries_ok")

    // ========================================================================
    // Test 4: walk_dir
    // ========================================================================
    let walk_base = base.join("walk")
    create_dir_all(walk_base.join("sub1")).unwrap()
    create_dir_all(walk_base.join("sub2")).unwrap()
    write_text_file(walk_base.join("root.txt"), "r").unwrap()
    write_text_file(walk_base.join("sub1/a.txt"), "a").unwrap()
    write_text_file(walk_base.join("sub2/b.txt"), "b").unwrap()

    // Count visited entries via a reference capture (stable across lambda copies)
    let walk_count = ref Counter(0)
    walk_dir(walk_base, (entry) -> {
        let _ = entry.name()
        walk_count.value += 1
        yield WalkAction.Continue()
    }).unwrap()
    // Should visit: sub1, sub2, root.txt, sub1/a.txt, sub2/b.txt = 5
    assert(walk_count.value == 5, "walk_dir count")

    // walk_dir with Stop - stop after two callbacks
    let stop_count = ref Counter(0)
    walk_dir(walk_base, (entry) -> {
        let _ = entry.name()
        stop_count.value += 1
        yield if stop_count.value == 2 then {
            yield WalkAction.Stop()
        } else {
            yield WalkAction.Continue()
        }
    }).unwrap()
    assert(stop_count.value == 2, "walk_dir stop count")

    println("walk_dir_ok")

    // ========================================================================
    // Test 5: create_temp_dir
    // ========================================================================
    let td = create_temp_dir(base, "test_").unwrap()
    assert(is_dir(td), "temp_dir exists")
    assert(td.to_string().contains("test_"), "temp_dir prefix")

    // Cleanup
    remove_dir_all(base).unwrap()

    println("create_temp_dir_ok")
}
