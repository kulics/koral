// Test implicit member expression syntax sugar
// EXPECT: === Union Case Construction Tests ===
// EXPECT: Some(42)
// EXPECT: None
// EXPECT: === Generic Union Tests ===
// EXPECT: Some(hello)
// EXPECT: None
// EXPECT: === Variable Declaration Tests ===
// EXPECT: Some(100)
// EXPECT: === Return Statement Tests ===
// EXPECT: Some(200)
// EXPECT: === Assignment Tests ===
// EXPECT: Some(300)
// EXPECT: === Conditional Expression Tests ===
// EXPECT: Some(1)
// EXPECT: Some(0)
// EXPECT: === When Expression Tests ===
// EXPECT: Some(10)
// EXPECT: Some(20)
// EXPECT: === Function Argument Tests ===
// EXPECT: Got Some: 42
// EXPECT: Got None
// EXPECT: === Static Method Tests ===
// EXPECT: List created with .new(): 3
// EXPECT: List created with .with_capacity(): 2
// EXPECT: Counter value: 10
// EXPECT: === Pattern Matching Compatibility ===
// EXPECT: Matched Some: 999
// EXPECT: Matched None
// EXPECT: All implicit member expression tests passed

// Helper function to print Option[Int]
let print_option(opt [Int]Option) Void = when opt is {
    .Some(v) then print_line("Some(" + v.to_string() + ")"),
    .None then print_line("None"),
}

// Helper function to print Option[String]
let print_string_option(opt [String]Option) Void = when opt is {
    .Some(v) then print_line("Some(" + v + ")"),
    .None then print_line("None"),
}

// Function that takes Option as parameter
let process_option(opt [Int]Option) Void = when opt is {
    .Some(v) then print_line("Got Some: " + v.to_string()),
    .None then print_line("Got None"),
}

// Function that returns Option using implicit member expression
let make_some(value Int) [Int]Option = {
    return .Some(value)
}

// Custom struct with static method returning Self
type Counter(mut value Int)

given Counter {
    public new(initial Int) Self = Counter(initial)
    
    public with_default() Self = Counter(0)
}

// Function that returns Counter using implicit static method
let make_list() Counter = {
    return .new(10)
}

let main() Void = {
    print_line("=== Union Case Construction Tests ===")
    
    // Basic union case construction with type annotation
    let opt1 [Int]Option = .Some(42)
    print_option(opt1)
    
    let opt2 [Int]Option = .None()
    print_option(opt2)
    
    print_line("=== Generic Union Tests ===")
    
    // Generic union with String type argument
    let str_opt [String]Option = .Some("hello")
    print_string_option(str_opt)
    
    let str_none [String]Option = .None()
    print_string_option(str_none)
    
    print_line("=== Variable Declaration Tests ===")
    
    // Variable declaration with implicit member expression
    let opt3 [Int]Option = .Some(100)
    print_option(opt3)
    
    print_line("=== Return Statement Tests ===")
    
    // Return statement with implicit member expression
    let opt4 = make_some(200)
    print_option(opt4)
    
    print_line("=== Assignment Tests ===")
    
    // Assignment with implicit member expression
    let mut opt5 [Int]Option = .None()
    opt5 = .Some(300)
    print_option(opt5)
    
    print_line("=== Conditional Expression Tests ===")
    
    // Conditional expression branches with implicit member expression
    let cond1 = true
    let opt6 [Int]Option = if cond1 then .Some(1) else .Some(0)
    print_option(opt6)
    
    let cond2 = false
    let opt7 [Int]Option = if cond2 then .Some(1) else .Some(0)
    print_option(opt7)
    
    print_line("=== When Expression Tests ===")
    
    // When expression branches with implicit member expression
    let x = 1
    let opt8 [Int]Option = when x is {
        1 then .Some(10),
        2 then .Some(20),
        _ then .None(),
    }
    print_option(opt8)
    
    let y = 2
    let opt9 [Int]Option = when y is {
        1 then .Some(10),
        2 then .Some(20),
        _ then .None(),
    }
    print_option(opt9)
    
    print_line("=== Function Argument Tests ===")
    
    // Function argument with implicit member expression
    process_option(.Some(42))
    process_option(.None())
    
    print_line("=== Static Method Tests ===")
    
    // Static method .new() with type annotation
    let list1 [Int]List = .new()
    list1.push(1)
    list1.push(2)
    list1.push(3)
    print_line("List created with .new(): " + list1.count().to_string())
    
    // Static method .with_capacity() with type annotation
    let list2 [String]List = .with_capacity(10)
    list2.push("hello")
    list2.push("world")
    print_line("List created with .with_capacity(): " + list2.count().to_string())
    
    // Static method in return statement
    let list3 = make_list()
    print_line("Counter value: " + list3.value.to_string())
    
    print_line("=== Pattern Matching Compatibility ===")
    
    // Ensure pattern matching syntax still works
    let test_opt = [Int]Option.Some(999)
    when test_opt is {
        .Some(v) then print_line("Matched Some: " + v.to_string()),
        .None then print_line("Matched None"),
    }
    
    let test_none = [Int]Option.None()
    when test_none is {
        .Some(v) then print_line("Matched Some: " + v.to_string()),
        .None then print_line("Matched None"),
    }
    
    print_line("All implicit member expression tests passed")
}
