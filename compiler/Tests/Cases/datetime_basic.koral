// EXPECT: epoch_ok
// EXPECT: from_unix_secs_ok
// EXPECT: invalid_month_ok
// EXPECT: invalid_day_ok
// EXPECT: invalid_hour_ok
// EXPECT: leap_year_ok
// EXPECT: non_leap_ok
// EXPECT: components_roundtrip_ok
// EXPECT: field_range_ok

using std.time.*

let main() Int = {
    // epoch
    let e = DateTime.epoch()
    assert(e.to_unix_secs() == (Int64)0, "epoch secs")
    assert(e.year() == 1970, "epoch year")
    assert(e.month() == 1, "epoch month")
    assert(e.day() == 1, "epoch day")
    assert(e.hour() == 0, "epoch hour")
    assert(e.minute() == 0, "epoch min")
    assert(e.second() == 0, "epoch sec")
    print_line("epoch_ok")

    // from_unix_secs(0) equals epoch
    let e2 = DateTime.from_unix_secs(0)
    assert(e2.equals(e), "from_unix_secs 0")
    print_line("from_unix_secs_ok")

    // invalid month 0
    let r1 = DateTime.from_components(2024, 0, 1, 0, 0, 0, 0, TimeZone.utc())
    if r1 is .Some(_) then { assert(false, "month 0") }
    // invalid month 13
    let r2 = DateTime.from_components(2024, 13, 1, 0, 0, 0, 0, TimeZone.utc())
    if r2 is .Some(_) then { assert(false, "month 13") }
    print_line("invalid_month_ok")

    // invalid day: Feb 30
    let r3 = DateTime.from_components(2024, 2, 30, 0, 0, 0, 0, TimeZone.utc())
    if r3 is .Some(_) then { assert(false, "feb 30") }
    print_line("invalid_day_ok")

    // invalid hour 24
    let r4 = DateTime.from_components(2024, 1, 1, 24, 0, 0, 0, TimeZone.utc())
    if r4 is .Some(_) then { assert(false, "hour 24") }
    print_line("invalid_hour_ok")

    // leap year: 2024-02-29 valid
    let r5 = DateTime.from_components(2024, 2, 29, 12, 0, 0, 0, TimeZone.utc())
    if r5 is .Some(dt) then {
        assert(dt.day() == 29, "leap day")
    } else {
        assert(false, "leap should be Some")
    }
    print_line("leap_year_ok")

    // non-leap year: 2023-02-29 invalid
    let r6 = DateTime.from_components(2023, 2, 29, 12, 0, 0, 0, TimeZone.utc())
    if r6 is .Some(_) then { assert(false, "non-leap") }
    print_line("non_leap_ok")

    // from_components roundtrip
    let r7 = DateTime.from_components(2024, 6, 15, 10, 30, 45, 123_000_000, TimeZone.utc())
    if r7 is .Some(dt) then {
        assert(dt.year() == 2024, "rt year")
        assert(dt.month() == 6, "rt month")
        assert(dt.day() == 15, "rt day")
        assert(dt.hour() == 10, "rt hour")
        assert(dt.minute() == 30, "rt min")
        assert(dt.second() == 45, "rt sec")
        assert(dt.nanosecond() == 123_000_000, "rt nanos")
    } else {
        assert(false, "rt should be Some")
    }
    print_line("components_roundtrip_ok")

    // field range check on a known date: 2000-12-31T23:59:59Z
    let r8 = DateTime.from_components(2000, 12, 31, 23, 59, 59, 0, TimeZone.utc())
    if r8 is .Some(dt) then {
        assert(dt.month() >= 1 and dt.month() <= 12, "month range")
        assert(dt.day() >= 1 and dt.day() <= 31, "day range")
        assert(dt.hour() >= 0 and dt.hour() <= 23, "hour range")
        assert(dt.minute() >= 0 and dt.minute() <= 59, "min range")
        assert(dt.second() >= 0 and dt.second() <= 59, "sec range")
    } else {
        assert(false, "range should be Some")
    }
    print_line("field_range_ok")

    yield 0
}
