// EXPECT: All List sort tests passed

let main() Void = {
    // === Test 1: Empty list sort ===
    let mut empty = [Int]List.new()
    empty.sort()
    assert(empty.count() == 0, "empty list sort")

    // === Test 2: Single element sort ===
    let mut single = [Int]List.new()
    single.push(42)
    single.sort()
    assert(single.count() == 1, "single element count")
    assert(single[0] == 42, "single element value")

    // === Test 3: Two elements sort ===
    let mut two = [Int]List.new()
    two.push(5)
    two.push(3)
    two.sort()
    assert(two[0] == 3, "two elements: first")
    assert(two[1] == 5, "two elements: second")

    // === Test 4: Already sorted list ===
    let mut sorted = [Int]List.new()
    sorted.push(1)
    sorted.push(2)
    sorted.push(3)
    sorted.sort()
    assert(sorted[0] == 1 and sorted[1] == 2 and sorted[2] == 3, "already sorted")

    // === Test 5: Reverse sorted list ===
    let mut reverse = [Int]List.new()
    reverse.push(5)
    reverse.push(4)
    reverse.push(3)
    reverse.push(2)
    reverse.push(1)
    reverse.sort()
    assert(reverse[0] == 1, "reverse: 0")
    assert(reverse[1] == 2, "reverse: 1")
    assert(reverse[2] == 3, "reverse: 2")
    assert(reverse[3] == 4, "reverse: 3")
    assert(reverse[4] == 5, "reverse: 4")

    // === Test 6: Random order with duplicates ===
    let mut random = [Int]List.new()
    random.push(3)
    random.push(1)
    random.push(4)
    random.push(1)
    random.push(5)
    random.push(9)
    random.push(2)
    random.push(6)
    random.sort()
    assert(random[0] == 1, "random: 0")
    assert(random[1] == 1, "random: 1")
    assert(random[2] == 2, "random: 2")
    assert(random[3] == 3, "random: 3")
    assert(random[4] == 4, "random: 4")
    assert(random[5] == 5, "random: 5")
    assert(random[6] == 6, "random: 6")
    assert(random[7] == 9, "random: 7")

    // === Test 7: sort_by with key function (ascending by key) ===
    let mut byKey = [Int]List.new()
    byKey.push(10)
    byKey.push(3)
    byKey.push(7)
    byKey.push(1)
    // Sort by identity key (same as sort())
    byKey.sort_by((x) -> x)
    assert(byKey[0] == 1, "byKey: 0")
    assert(byKey[1] == 3, "byKey: 1")
    assert(byKey[2] == 7, "byKey: 2")
    assert(byKey[3] == 10, "byKey: 3")

    // === Test 8: sort_by with custom key function ===
    let mut custom = [Int]List.new()
    custom.push(10)
    custom.push(3)
    custom.push(7)
    custom.push(1)
    // Sort by absolute difference from 5
    custom.sort_by((x) -> if x > 5 then x - 5 else 5 - x)
    // Expected order by diff from 5: 3 (diff=2), 7 (diff=2), 1 (diff=4), 10 (diff=5)
    assert(custom[0] == 3 or custom[0] == 7, "custom: closest to 5")
    assert(custom[3] == 10, "custom: farthest from 5")

    // === Test 9: Copy-on-Write with sort ===
    let mut original = [Int]List.new()
    original.push(3)
    original.push(1)
    original.push(2)
    
    let mut copy = original  // Shallow copy
    copy.sort()  // Should trigger COW
    
    // Original unchanged
    assert(original[0] == 3, "COW: original[0]")
    assert(original[1] == 1, "COW: original[1]")
    assert(original[2] == 2, "COW: original[2]")
    
    // Copy sorted
    assert(copy[0] == 1, "COW: copy[0]")
    assert(copy[1] == 2, "COW: copy[1]")
    assert(copy[2] == 3, "COW: copy[2]")

    // === Test 10: Idempotency ===
    let mut idem = [Int]List.new()
    idem.push(2)
    idem.push(1)
    idem.push(3)
    idem.sort()
    let first_0 = idem[0]
    let first_1 = idem[1]
    let first_2 = idem[2]
    idem.sort()  // Sort again
    assert(idem[0] == first_0 and idem[1] == first_1 and idem[2] == first_2, "idempotency")

    print_line("All List sort tests passed")
}
