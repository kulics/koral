// EXPECT: All List tests passed

let main() Void = {
    // === Basic Operations ===
    let mut list = [Int]List.new()
    assert(list.count() == 0, "new list count 0")
    assert(list.is_empty(), "new list is_empty")

    // === push / pop ===
    list.push(10)
    assert(list.count() == 1, "count after push")
    assert(not list.is_empty(), "not empty after push")
    
    list.push(20)
    list.push(30)
    assert(list.count() == 3, "count 3")

    let p1 = list.pop()
    assert(p1.unwrap() == 30, "pop value")
    assert(list.count() == 2, "count after pop")

    // === front / back (push_front/pop_front removed) ===
    list.insert(0, 5)  // Insert at front
    assert(list.count() == 3, "count after insert at front")
    assert(list[0] == 5, "insert at front at index 0")

    let p2 = list.remove(0)  // Remove from front
    assert(p2 == 5, "remove from front value")
    assert(list[0] == 10, "after remove from front")

    // === front / back ===
    assert(list.front().unwrap() == 10, "front")
    assert(list.back().unwrap() == 20, "back")

    let mut empty_list = [Int]List.new()
    let front_empty = empty_list.front()
    assert(front_empty.is_none(), "front on empty")
    let back_empty = empty_list.back()
    assert(back_empty.is_none(), "back on empty")

    // === get (safe access) ===
    assert(list.get(0).unwrap() == 10, "get(0)")
    assert(list.get(1).unwrap() == 20, "get(1)")
    let get_oob = list.get(999)
    assert(get_oob.is_none(), "get out of bounds")

    // === replace (returns old value) ===
    let old1 = list.replace(0, 100)
    assert(old1.unwrap() == 10, "replace returns old value")
    assert(list[0] == 100, "replace new value")

    let old2 = list.replace(999, 0)
    assert(old2.is_none(), "replace out of bounds")

    // === subscript (__at / __set_at) ===
    list[0] = 1
    list[1] = 2
    assert(list[0] == 1, "subscript read 0")
    assert(list[1] == 2, "subscript read 1")

    // === insert ===
    list.insert(1, 99)  // Insert 99 at index 1
    assert(list.count() == 3, "count after insert")
    assert(list[0] == 1, "insert: index 0")
    assert(list[1] == 99, "insert: index 1")
    assert(list[2] == 2, "insert: index 2")

    // === remove (returns removed value) ===
    let removed = list.remove(1)
    assert(removed == 99, "remove returns value")
    assert(list.count() == 2, "count after remove")

    // === clear ===
    list.clear()
    assert(list.count() == 0, "count after clear")
    assert(list.is_empty(), "is_empty after clear")

    // === pop on empty ===
    let pop_empty1 = list.pop()
    assert(pop_empty1.is_none(), "pop on empty")

    // === iterator ===
    let mut list2 = [Int]List.new()
    list2.push(1)
    list2.push(2)
    list2.push(3)

    let mut sum = 0
    let mut it = list2.iterator()
    while true then {
        when it.next() is {
            .Some(v) then { sum = sum + v; },
            .None then { break; },
        }
    }
    assert(sum == 6, "iterator sum")

    // === COW (Copy-On-Write) semantics ===
    let mut original = [Int]List.new()
    original.push(10)
    original.push(20)

    let mut copy = original  // Shallow copy, shares storage

    // Modify copy triggers COW
    copy.push(30)
    copy[0] = 99

    // Original unchanged
    assert(original.count() == 2, "original count unchanged")
    assert(original[0] == 10, "original[0] unchanged")
    assert(original[1] == 20, "original[1] unchanged")

    // Copy modified
    assert(copy.count() == 3, "copy count")
    assert(copy[0] == 99, "copy[0] modified")
    assert(copy[1] == 20, "copy[1]")
    assert(copy[2] == 30, "copy[2] added")

    // === String list (reference types) ===
    let mut strings = [String]List.new()
    strings.push("hello")
    strings.push("world")
    assert(strings[0] == "hello", "string list 0")
    assert(strings[1] == "world", "string list 1")

    // === slice ===
    let mut nums = [Int]List.new()
    nums.push(0)
    nums.push(1)
    nums.push(2)
    nums.push(3)
    nums.push(4)

    // ClosedRange: 1..3 -> [1, 2, 3]
    let s1 = nums.slice(1..3)
    assert(s1.count() == 3, "slice closed count")
    assert(s1[0] == 1 and s1[1] == 2 and s1[2] == 3, "slice closed values")

    // ClosedOpenRange: 1..<3 -> [1, 2]
    let s2 = nums.slice(1..<3)
    assert(s2.count() == 2, "slice closed-open count")
    assert(s2[0] == 1 and s2[1] == 2, "slice closed-open values")

    // FromRange: 3... -> [3, 4]
    let s3 = nums.slice(3...)
    assert(s3.count() == 2, "slice from count")
    assert(s3[0] == 3 and s3[1] == 4, "slice from values")

    // ToOpenRange: ...<3 -> [0, 1, 2]
    let s4 = nums.slice(...<3)
    assert(s4.count() == 3, "slice to-open count")
    assert(s4[0] == 0 and s4[1] == 1 and s4[2] == 2, "slice to-open values")

    // FullRange: .... -> [0, 1, 2, 3, 4]
    let s5 = nums.slice(....)
    assert(s5.count() == 5, "slice full count")

    // === insert_all ===
    let mut ia1 = [Int]List.new()
    ia1.push(1)
    ia1.push(2)
    ia1.push(5)
    let mut ia2 = [Int]List.new()
    ia2.push(3)
    ia2.push(4)
    ia1.insert_all(1, ia2)
    assert(ia1.count() == 5, "insert_all count")
    assert(ia1[0] == 1 and ia1[1] == 3 and ia1[2] == 4 and ia1[3] == 2 and ia1[4] == 5, "insert_all values")

    // insert_all at end
    let mut ia3 = [Int]List.new()
    ia3.push(1)
    let mut ia4 = [Int]List.new()
    ia4.push(2)
    ia4.push(3)
    ia3.insert_all(1, ia4)
    assert(ia3.count() == 3, "insert_all at end count")
    assert(ia3[0] == 1 and ia3[1] == 2 and ia3[2] == 3, "insert_all at end values")

    // insert_all empty list
    let mut ia5 = [Int]List.new()
    ia5.push(1)
    let ia_empty2 = [Int]List.new()
    ia5.insert_all(0, ia_empty2)
    assert(ia5.count() == 1, "insert_all empty no change")

    // === push_all ===
    let mut pa1 = [Int]List.new()
    pa1.push(1)
    pa1.push(2)
    let mut pa2 = [Int]List.new()
    pa2.push(3)
    pa2.push(4)
    pa1.push_all(pa2)
    assert(pa1.count() == 4, "push_all count")
    assert(pa1[0] == 1 and pa1[1] == 2 and pa1[2] == 3 and pa1[3] == 4, "push_all values")

    // push_all empty list
    let mut pa3 = [Int]List.new()
    pa3.push(10)
    let pa_empty = [Int]List.new()
    pa3.push_all(pa_empty)
    assert(pa3.count() == 1, "push_all empty no change")

    print_line("All List tests passed")
}
