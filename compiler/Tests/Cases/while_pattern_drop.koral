// Test drop of subject in while-pattern expressions (borrow semantics)
// With borrow semantics, bindings are aliases â€” no copy, single drop per iteration
// EXPECT: Creating iterator
// EXPECT: Iteration 0
// EXPECT: Drop Resource 0
// EXPECT: Iteration 1
// EXPECT: Drop Resource 1
// EXPECT: Iteration 2
// EXPECT: Drop Resource 2
// EXPECT: Loop ended
// EXPECT: Drop Iterator
// EXPECT: All while-pattern drop tests passed

type Resource(id Int)

given Resource {
    __drop(self ref) Void = {
        print("Drop Resource ")
        print_line(self.id)
    }
}

type MaybeResource {
    Some(r Resource),
    None(),
}

type ResourceIterator(mut current Int, max Int)

given ResourceIterator {
    __drop(self ref) Void = {
        print_line("Drop Iterator")
    }
    
    next(self ref) MaybeResource = {
        if self.current < self.max then {
            let id = self.current
            self.current = self.current + 1
            MaybeResource.Some(Resource(id))
        } else {
            MaybeResource.None()
        }
    }
}

let test_while_pattern() Void = {
    print_line("Creating iterator")
    let mut iter = ResourceIterator(0, 3)
    
    // Each iteration with borrow semantics:
    // - r is an alias into the subject's inner Resource (no copy)
    // - subject (MaybeResource) is dropped at end of iteration
    // When pattern doesn't match (None), subject is dropped before exit
    while iter.next() is .Some(r) then {
        print("Iteration ")
        print_line(r.id)
    }
    
    print_line("Loop ended")
}

let main() Int = {
    test_while_pattern()
    
    print_line("All while-pattern drop tests passed")
    0
}
