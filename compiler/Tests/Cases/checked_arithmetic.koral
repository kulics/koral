// Test normal (non-overflowing) checked arithmetic operations
// EXPECT: add_int:
// EXPECT: 300
// EXPECT: sub_int:
// EXPECT: 50
// EXPECT: mul_int:
// EXPECT: 200
// EXPECT: div_int:
// EXPECT: 50
// EXPECT: mod_int:
// EXPECT: 1
// EXPECT: add_i8:
// EXPECT: true
// EXPECT: sub_u8:
// EXPECT: true
// EXPECT: mul_i16:
// EXPECT: true
// EXPECT: div_u32:
// EXPECT: true
// EXPECT: neg_int:
// EXPECT: -42
// EXPECT: wrapping_add:
// EXPECT: true
// EXPECT: wrapping_sub:
// EXPECT: true
// EXPECT: wrapping_mul:
// EXPECT: true
// EXPECT: wrapping_div:
// EXPECT: true
// EXPECT: wrapping_mod:
// EXPECT: true
// EXPECT: wrapping_neg:
// EXPECT: true
// EXPECT: wrapping_shl:
// EXPECT: true
// EXPECT: wrapping_shr:
// EXPECT: true

let main() Int = {
    // Basic Int arithmetic
    print_line("add_int:")
    print_line(100 + 200)
    print_line("sub_int:")
    print_line(100 - 50)
    print_line("mul_int:")
    print_line(10 * 20)
    print_line("div_int:")
    print_line(100 / 2)
    print_line("mod_int:")
    print_line(10 % 3)

    // Different integer types
    let a8 Int8 = 5
    let b8 Int8 = 7
    print_line("add_i8:")
    print_line(a8 + b8 == 12)

    let ua8 UInt8 = 200
    let ub8 UInt8 = 10
    print_line("sub_u8:")
    print_line(ua8 - ub8 == 190)

    let a16 Int16 = 30
    let b16 Int16 = 20
    print_line("mul_i16:")
    print_line(a16 * b16 == 600)

    let ua32 UInt32 = 100
    let ub32 UInt32 = 20
    print_line("div_u32:")
    print_line(ua32 / ub32 == 5)

    // Unary negation (non-overflowing)
    let x = 42
    print_line("neg_int:")
    print_line(-x)

    // Wrapping methods (overflow cases that should NOT panic)
    let max8 Int8 = 127
    let one8 Int8 = 1
    print_line("wrapping_add:")
    print_line(max8.wrapping_add(one8) == -128)

    let min8 Int8 = -128
    print_line("wrapping_sub:")
    print_line(min8.wrapping_sub(one8) == 127)

    let big8 Int8 = 127
    let two8 Int8 = 2
    print_line("wrapping_mul:")
    print_line(big8.wrapping_mul(two8) == -2)

    // wrapping_div: INT8_MIN / -1 would overflow, wrapping gives INT8_MIN
    let neg1_8 Int8 = -1
    print_line("wrapping_div:")
    print_line(min8.wrapping_div(neg1_8) == -128)

    // wrapping_mod: INT8_MIN % -1 would overflow, wrapping gives 0
    print_line("wrapping_mod:")
    print_line(min8.wrapping_mod(neg1_8) == 0)

    // wrapping_neg: -INT8_MIN would overflow, wrapping gives INT8_MIN
    print_line("wrapping_neg:")
    print_line(min8.wrapping_neg() == -128)

    // wrapping_shl: shift amount masked to bit_width - 1
    let val8 Int8 = 1
    let shift8 Int8 = 9  // 9 & 7 = 1, so result is 1 << 1 = 2
    print_line("wrapping_shl:")
    print_line(val8.wrapping_shl(shift8) == 2)

    // wrapping_shr: shift amount masked to bit_width - 1
    let val8b Int8 = 64
    print_line("wrapping_shr:")
    print_line(val8b.wrapping_shr(shift8) == 32)  // 9 & 7 = 1, so 64 >> 1 = 32

    0
}
