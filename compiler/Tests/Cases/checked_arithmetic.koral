// Test normal (non-overflowing) checked arithmetic operations
// EXPECT: add_int:
// EXPECT: 300
// EXPECT: sub_int:
// EXPECT: 50
// EXPECT: mul_int:
// EXPECT: 200
// EXPECT: div_int:
// EXPECT: 50
// EXPECT: mod_int:
// EXPECT: 1
// EXPECT: add_i8:
// EXPECT: true
// EXPECT: sub_u8:
// EXPECT: true
// EXPECT: mul_i16:
// EXPECT: true
// EXPECT: div_u32:
// EXPECT: true
// EXPECT: neg_int:
// EXPECT: -42
// EXPECT: wrapping_add:
// EXPECT: true
// EXPECT: wrapping_sub:
// EXPECT: true
// EXPECT: wrapping_mul:
// EXPECT: true
// EXPECT: wrapping_div:
// EXPECT: true
// EXPECT: wrapping_rem:
// EXPECT: true
// EXPECT: wrapping_neg:
// EXPECT: true
// EXPECT: wrapping_shl:
// EXPECT: true
// EXPECT: wrapping_shr:
// EXPECT: true

let main() Int = {
    // Basic Int arithmetic
    println("add_int:")
    println(100 + 200)
    println("sub_int:")
    println(100 - 50)
    println("mul_int:")
    println(10 * 20)
    println("div_int:")
    println(100 / 2)
    println("mod_int:")
    println(10 % 3)

    // Different integer types
    let a8 Int8 = 5
    let b8 Int8 = 7
    println("add_i8:")
    println(a8 + b8 == 12)

    let ua8 UInt8 = 200
    let ub8 UInt8 = 10
    println("sub_u8:")
    println(ua8 - ub8 == 190)

    let a16 Int16 = 30
    let b16 Int16 = 20
    println("mul_i16:")
    println(a16 * b16 == 600)

    let ua32 UInt32 = 100
    let ub32 UInt32 = 20
    println("div_u32:")
    println(ua32 / ub32 == 5)

    // Unary negation (non-overflowing)
    let x = 42
    println("neg_int:")
    println(-x)

    // Wrapping methods (overflow cases that should NOT panic)
    let max8 Int8 = 127
    let one8 Int8 = 1
    println("wrapping_add:")
    println(max8.wrapping_add(one8) == -128)

    let min8 Int8 = -128
    println("wrapping_sub:")
    println(min8.wrapping_sub(one8) == 127)

    let big8 Int8 = 127
    let two8 Int8 = 2
    println("wrapping_mul:")
    println(big8.wrapping_mul(two8) == -2)

    // wrapping_div: INT8_MIN / -1 would overflow, wrapping gives INT8_MIN
    let neg1_8 Int8 = -1
    println("wrapping_div:")
    println(min8.wrapping_div(neg1_8) == -128)

    // wrapping_rem: INT8_MIN % -1 would overflow, wrapping gives 0
    println("wrapping_rem:")
    println(min8.wrapping_rem(neg1_8) == 0)

    // wrapping_neg: -INT8_MIN would overflow, wrapping gives INT8_MIN
    println("wrapping_neg:")
    println(min8.wrapping_neg() == -128)

    // wrapping_shl: shift amount masked to bit_width - 1
    let val8 Int8 = 1
    let shift8 Int8 = 9  // 9 & 7 = 1, so result is 1 << 1 = 2
    println("wrapping_shl:")
    println(val8.wrapping_shl(shift8) == 2)

    // wrapping_shr: shift amount masked to bit_width - 1
    let val8b Int8 = 64
    println("wrapping_shr:")
    println(val8b.wrapping_shr(shift8) == 32)  // 9 & 7 = 1, so 64 >> 1 = 32

    yield 0
}
