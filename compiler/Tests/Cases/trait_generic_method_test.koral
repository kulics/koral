// Test generic methods defined in traits and implemented in given blocks
// This tests that a trait can declare a generic method and types can implement it
// EXPECT: 84
// EXPECT: hello_world
// EXPECT: 42
// EXPECT: 100

// Define a trait with a generic method
trait Transformable {
    [U Any]transform(self, f [Self, U]Func) U
}

// A simple wrapper type
public type [T Any] Box {
    Value(inner T),
}

// Implement Transformable for Box (implicit trait implementation by providing the method)
given [T Any] [T]Box {
    public [U Any]transform(self, f [[T]Box, U]Func) U = f(self)
}

// Test using the trait as a constraint in a generic function
let [T Transformable] get_value(x T) Int = {
    yield x.[Int]transform((v) -> 42)
}

// Test using the trait as a constraint with a function parameter
let [T Transformable] apply_transform(x T, f [T, Int]Func) Int = {
    yield x.[Int]transform(f)
}

let main() Int = {
    // Test calling the generic method directly on Box[Int]
    let box1 = [Int]Box.Value(42)
    let result1 = box1.[Int]transform((b) -> {
        yield when b is {
            .Value(v) then v * 2,
        }
    })
    println(result1.to_string())
    
    // Test transforming to a different type (Int -> String)
    let box2 = [Int]Box.Value(42)
    let result2 = box2.[String]transform((b) -> {
        yield when b is {
            .Value(v) then {
                let mut s = "hello_"
                s.push_string("world")
                yield s
            },
        }
    })
    println(result2)
    
    // Test using the trait as a constraint (simple version)
    let box3 = [Int]Box.Value(50)
    let result3 = get_value(box3)
    println(result3.to_string())
    
    // Test using the trait as a constraint with a function parameter
    let box4 = [Int]Box.Value(50)
    let result4 = apply_transform(box4, (b [Int]Box) -> {
        yield when b is {
            .Value(v) then v * 2,
        }
    })
    println(result4.to_string())
    
    yield 0
}
