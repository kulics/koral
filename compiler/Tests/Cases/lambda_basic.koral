// Lambda basic syntax test
// EXPECT: 42

let main() Int = {
    // Test 1: Basic lambda with full type annotation
    let doubler [Int, Int]Func = (x Int) Int -> x * 2
    let r1 = doubler(21)  // 21 * 2 = 42
    print_line(r1)
    
    // Test 2: Lambda with type inference
    let tripler [Int, Int]Func = (x) -> x * 3
    let r2 = tripler(14)  // 14 * 3 = 42
    print_line(r2)
    
    // Test 3: Lambda with multiple parameters
    let add [Int, Int, Int]Func = (x, y) -> x + y
    let r3 = add(20, 22)  // 20 + 22 = 42
    print_line(r3)
    
    // Test 4: Lambda with no parameters
    let answer [Int]Func = () -> 42
    let r4 = answer()
    print_line(r4)
    
    // Test 5: Lambda with block body
    let compute [Int, Int]Func = (x) -> {
        let y = x * 2
        let z = y + 1
        z
    }
    let r5 = compute(20)  // 20 * 2 + 1 = 41
    print_line(r5)
    
    // Test 6: Lambda returning Void
    let printer [Int, Void]Func = (x) -> print_line(x)
    printer(42)
    
    // Test 7: Nested lambda calls
    let f [Int, Int]Func = (x) -> x + 1
    let g [Int, Int]Func = (x) -> x * 2
    let r7 = f(g(20))  // (20 * 2) + 1 = 41
    print_line(r7)
    
    r1
}
