// Test generic methods with method-level type parameters
// EXPECT: 84

public type [T Any] MyOption {
    None(),
    Some(value T),
}

given [T Any] [T]MyOption {
    public is_some(self) Bool = when self is {
        .Some(_) then true,
        .None then false,
    }

    public unwrap(self) T = when self is {
        .Some(v) then v,
        .None then panic("unwrap failed"),
    }

    // Generic method with method-level type parameter
    // Return type is just U, not [U]MyOption
    public [U Any]transform(self, f [T, U]Func) U = when self is {
        .Some(v) then f(v),
        .None then panic("transform on None"),
    }
}

let main() Int = {
    let opt = [Int]MyOption.Some(42)
    let doubled = opt.[Int]transform((x) -> x * 2)
    print_line(doubled.to_string())
    yield 0
}
