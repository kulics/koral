// Test basic Iterator extension API functionality

let main() Void = {
    // Test with List
    let mut list = [Int]List.new()
    list.push(1)
    list.push(2)
    list.push(3)
    list.push(4)
    list.push(5)
    
    // Test filter (chained)
    let filtered = list.iterator().filter((x) -> x > 2).to_list()
    print("Filtered (>2): ")
    print_list(filtered)
    
    // Test map (chained)
    let mapped = list.iterator().map((x) -> x * 2).to_list()
    print("Mapped (*2): ")
    print_list(mapped)
    
    // Test filter + map chain
    let chained = list.iterator().filter((x) -> x > 2).map((x) -> x * 10).to_list()
    print("Chained (>2, *10): ")
    print_list(chained)
    
    // Test take (chained)
    let taken = list.iterator().take(3).to_list()
    print("Take 3: ")
    print_list(taken)
    
    // Test skip (chained)
    let skipped = list.iterator().skip(2).to_list()
    print("Skip 2: ")
    print_list(skipped)
    
    // Test count
    let cnt = list.iterator().count()
    print("Count: ")
    println(cnt.to_string())
    
    // Test first
    when list.iterator().first() in {
        .Some(v) then { print("First: "); println(v.to_string()); },
        .None then { println("First: None"); },
    }
    
    // Test last
    when list.iterator().last() in {
        .Some(v) then { print("Last: "); println(v.to_string()); },
        .None then { println("Last: None"); },
    }
    
    // Test nth
    when list.iterator().nth(2) in {
        .Some(v) then { print("Nth 2: "); println(v.to_string()); },
        .None then { println("Nth 2: None"); },
    }
    
    // Test fold
    let sum = list.iterator().fold(0, (acc, x) -> acc + x)
    print("Sum (fold): ")
    println(sum.to_string())
    
    // Test reduce
    when list.iterator().reduce((a, b) -> a + b) in {
        .Some(v) then { print("Sum (reduce): "); println(v.to_string()); },
        .None then { println("Sum (reduce): None"); },
    }
    
    // Test step_by
    let stepped = list.iterator().step_by(2).to_list()
    print("Step 2: ")
    print_list(stepped)
    
    // Test enumerate
    let enumerated = list.iterator().enumerate().to_list()
    print("Enumerate: ")
    print_indexed_list(enumerated)
    
    // Test peek (just verify it doesn't modify elements)
    let peeked = list.iterator().peek((x) -> { print(""); }).to_list()
    print("Peek count: ")
    println(peeked.count().to_string())
    
    // Test take_while
    let taken_while = list.iterator().take_while((x) -> x < 4).to_list()
    print("TakeWhile (<4): ")
    print_list(taken_while)
    
    // Test skip_while
    let skipped_while = list.iterator().skip_while((x) -> x < 3).to_list()
    print("SkipWhile (<3): ")
    print_list(skipped_while)
    
    // Test intersperse
    let mut small_list = [Int]List.new()
    small_list.push(1)
    small_list.push(2)
    small_list.push(3)
    let interspersed = small_list.iterator().intersperse(0).to_list()
    print("Intersperse with 0: ")
    print_list(interspersed)
    
    println("All tests passed!")
}

let print_list(list [Int]List) Void = {
    print("[")
    let mut i UInt = 0
    while i < list.count() then {
        if i > 0 then { print(", "); }
        print(list[i].to_string())
        i += 1
    }
    println("]")
}

let print_indexed_list(list [[UInt, Int]Pair]List) Void = {
    print("[")
    let mut i UInt = 0
    while i < list.count() then {
        if i > 0 then { print(", "); }
        let item = list[i]
        print("(")
        print(item.first.to_string())
        print(", ")
        print(item.second.to_string())
        print(")")
        i += 1
    }
    println("]")
}

// EXPECT: Filtered (>2): [3, 4, 5]
// EXPECT: Mapped (*2): [2, 4, 6, 8, 10]
// EXPECT: Chained (>2, *10): [30, 40, 50]
// EXPECT: Take 3: [1, 2, 3]
// EXPECT: Skip 2: [3, 4, 5]
// EXPECT: Count: 5
// EXPECT: First: 1
// EXPECT: Last: 5
// EXPECT: Nth 2: 3
// EXPECT: Sum (fold): 15
// EXPECT: Sum (reduce): 15
// EXPECT: Step 2: [1, 3, 5]
// EXPECT: Enumerate: [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]
// EXPECT: Peek count: 5
// EXPECT: TakeWhile (<4): [1, 2, 3]
// EXPECT: SkipWhile (<3): [3, 4, 5]
// EXPECT: Intersperse with 0: [1, 0, 2, 0, 3]
// EXPECT: All tests passed!
