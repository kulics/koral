// std.math floating point unit tests
// EXPECT: sqrt_ok
// EXPECT: cbrt_ok
// EXPECT: pow_ok
// EXPECT: powi_ok
// EXPECT: trig_ok
// EXPECT: exp_log_ok
// EXPECT: rounding_ok
// EXPECT: sign_ok
// EXPECT: hypot_ok
// EXPECT: special_ok
// EXPECT: lerp_ok
// EXPECT: constants_ok
// EXPECT: angle_ok
// EXPECT: fmod_fma_ok

using std.math.*

let approx_eq(a Float64, b Float64, eps Float64) Bool = {
    let diff = a - b
    let d = if diff < 0.0 then -diff else diff
    d <= eps
}

let main() Int = {
    // sqrt, cbrt
    if sqrt(4.0) == 2.0 and sqrt(9.0) == 3.0 and approx_eq(cbrt(8.0), 2.0, 0.0000000001) then {
        print_line("sqrt_ok")
    }

    // cbrt negative
    if approx_eq(cbrt(-8.0), -2.0, 0.0000000001) then {
        print_line("cbrt_ok")
    }

    // pow
    if pow(2.0, 10.0) == 1024.0 then {
        print_line("pow_ok")
    }

    // powi
    if powi(2.0, 10) == 1024.0 then {
        print_line("powi_ok")
    }

    // trig: sin(0)=0, cos(0)=1, tan(0)=0
    if sin(0.0) == 0.0 and cos(0.0) == 1.0 and tan(0.0) == 0.0 then {
        print_line("trig_ok")
    }

    // exp(0)=1, ln(1)=0, log2(8)=3, log10(1000)=3
    if exp(0.0) == 1.0 and ln(1.0) == 0.0 and log2(8.0) == 3.0 and approx_eq(log10(1000.0), 3.0, 0.0000000001) then {
        print_line("exp_log_ok")
    }

    // floor, ceil, round, trunc
    if floor(2.7) == 2.0 and ceil(2.3) == 3.0 and round(2.5) == 3.0 and trunc(2.9) == 2.0 then {
        print_line("rounding_ok")
    }

    // fabs, signum
    if fabs(-3.14) == 3.14 and signum(-5.0) == -1.0 and signum(5.0) == 1.0 and signum(0.0) == 0.0 then {
        print_line("sign_ok")
    }

    // hypot
    if hypot(3.0, 4.0) == 5.0 then {
        print_line("hypot_ok")
    }

    // special functions: erf(0)=0, erfc(0)=1, tgamma(5)=24, lgamma(1)=0
    if erf(0.0) == 0.0 and erfc(0.0) == 1.0 and approx_eq(tgamma(5.0), 24.0, 0.0000000001) and approx_eq(lgamma(1.0), 0.0, 0.0000000001) then {
        print_line("special_ok")
    }

    // lerp
    if lerp(0.0, 10.0, 0.5) == 5.0 then {
        print_line("lerp_ok")
    }

    // constants: pi, e, tau, ln2, ln10, sqrt2
    let p = [Float64]pi()
    let ev = [Float64]e()
    if approx_eq(p, 3.141592653589793, 0.000000000000001) and approx_eq(ev, 2.718281828459045, 0.000000000000001) then {
        let t = [Float64]tau()
        let l2 = [Float64]ln2()
        let l10 = [Float64]ln10()
        let s2 = [Float64]sqrt2()
        if approx_eq(t, 6.283185307179586, 0.000000000000001) and approx_eq(l2, 0.6931471805599453, 0.000000000000001) and approx_eq(l10, 2.302585092994046, 0.000000000000001) and approx_eq(s2, 1.4142135623730951, 0.000000000000001) then {
            print_line("constants_ok")
        }
    }

    // angle conversion: to_radians(180) ~ pi, to_degrees(pi) ~ 180
    if approx_eq(to_radians(180.0), p, 0.0000000001) and approx_eq(to_degrees(p), 180.0, 0.0000000001) then {
        print_line("angle_ok")
    }

    // fmod, fma
    if approx_eq(fmod(5.5, 2.0), 1.5, 0.0000000001) and fma(2.0, 3.0, 4.0) == 10.0 then {
        print_line("fmod_fma_ok")
    }

    0
}
