// std.math floating point unit tests
// EXPECT: sqrt_ok
// EXPECT: cbrt_ok
// EXPECT: pow_ok
// EXPECT: powi_ok
// EXPECT: trig_ok
// EXPECT: exp_log_ok
// EXPECT: rounding_ok
// EXPECT: sign_ok
// EXPECT: hypot_ok
// EXPECT: special_ok
// EXPECT: lerp_ok
// EXPECT: constants_ok
// EXPECT: angle_ok
// EXPECT: fmod_fma_ok
// EXPECT: float32_trait_ok
// EXPECT: float64_trait_ok

using std.math.*

let approx_eq(a Float64, b Float64, eps Float64) Bool = {
    let diff = a - b
    let d = if diff < 0.0 then -diff else diff
    yield d <= eps
}

let main() Int = {
    // sqrt, cbrt
    if sqrt(4.0) == 2.0 and sqrt(9.0) == 3.0 and approx_eq(cbrt(8.0), 2.0, 0.0000000001) then {
        println("sqrt_ok")
    }

    // cbrt negative
    if approx_eq(cbrt(-8.0), -2.0, 0.0000000001) then {
        println("cbrt_ok")
    }

    // pow
    if 2.0.pow(10.0) == 1024.0 then {
        println("pow_ok")
    }

    // powi
    if 2.0.powi(10) == 1024.0 then {
        println("powi_ok")
    }

    // trig: sin(0)=0, cos(0)=1, tan(0)=0
    if sin(0.0) == 0.0 and cos(0.0) == 1.0 and tan(0.0) == 0.0 then {
        println("trig_ok")
    }

    // exp(0)=1, ln(1)=0, log2(8)=3, log10(1000)=3
    if exp(0.0) == 1.0 and ln(1.0) == 0.0 and log2(8.0) == 3.0 and approx_eq(log10(1000.0), 3.0, 0.0000000001) then {
        println("exp_log_ok")
    }

    // floor, ceil, round, trunc
    if 2.7.floor() == 2.0 and 2.3.ceil() == 3.0 and 2.5.round() == 3.0 and 2.9.trunc() == 2.0 then {
        println("rounding_ok")
    }

    // abs, signum
    if (-3.14).abs() == 3.14 and (-5.0).signum() == -1.0 and 5.0.signum() == 1.0 and 0.0.signum() == 0.0 then {
        println("sign_ok")
    }

    // hypot
    if hypot(3.0, 4.0) == 5.0 then {
        println("hypot_ok")
    }

    // special functions: erf(0)=0, erfc(0)=1, tgamma(5)=24, lgamma(1)=0
    if erf(0.0) == 0.0 and erfc(0.0) == 1.0 and approx_eq(tgamma(5.0), 24.0, 0.0000000001) and approx_eq(lgamma(1.0), 0.0, 0.0000000001) then {
        println("special_ok")
    }

    // lerp
    if lerp(0.0, 10.0, 0.5) == 5.0 then {
        println("lerp_ok")
    }

    // constants: Float64.pi/e/tau/ln2/ln10/sqrt2
    let p = Float64.pi()
    let ev = Float64.e()
    if approx_eq(p, 3.141592653589793, 0.000000000000001) and approx_eq(ev, 2.718281828459045, 0.000000000000001) then {
        let t = Float64.tau()
        let l2 = Float64.ln2()
        let l10 = Float64.ln10()
        let s2 = Float64.sqrt2()
        if approx_eq(t, 6.283185307179586, 0.000000000000001) and approx_eq(l2, 0.6931471805599453, 0.000000000000001) and approx_eq(l10, 2.302585092994046, 0.000000000000001) and approx_eq(s2, 1.4142135623730951, 0.000000000000001) then {
            println("constants_ok")
        }
    }

    // angle conversion: to_radians(180) ~ pi, to_degrees(pi) ~ 180
    if approx_eq(180.0.to_radians(), p, 0.0000000001) and approx_eq(p.to_degrees(), 180.0, 0.0000000001) then {
        println("angle_ok")
    }

    // fmod, fma
    if approx_eq(5.5.fmod(2.0), 1.5, 0.0000000001) and fma(2.0, 3.0, 4.0) == 10.0 then {
        println("fmod_fma_ok")
    }

    // explicit trait-bound function calls on Float32
    let fsq = sqrt((Float32)4.0)
    let fex = exp((Float32)1.0)
    let fco = cos((Float32)0.0)
    let ffm = fma((Float32)2.0, (Float32)3.0, (Float32)4.0)
    if fsq == (Float32)2.0 and approx_eq((Float64)fex, 2.7182817, 0.00001) and fco == (Float32)1.0 and ffm == (Float32)10.0 then {
        println("float32_trait_ok")
    }

    // explicit trait-bound function calls on Float64
    let dsq = sqrt((Float64)4.0)
    let dex = exp((Float64)1.0)
    let dco = cos((Float64)0.0)
    let dfm = fma((Float64)2.0, (Float64)3.0, (Float64)4.0)
    if dsq == (Float64)2.0 and approx_eq(dex, 2.718281828459045, 0.0000000001) and dco == (Float64)1.0 and dfm == (Float64)10.0 then {
        println("float64_trait_ok")
    }

    yield 0
}
