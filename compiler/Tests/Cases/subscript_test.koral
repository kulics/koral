// EXPECT: 10
// EXPECT: 20
// EXPECT: 30
// EXPECT: 100
// EXPECT: 100
// EXPECT: 200

public type SubscriptPair(mut x Int, mut y Int)

given SubscriptPair {
    public new(x Int, y Int) Self = SubscriptPair(x, y)
}

public let main() Void = {
    let list = [Int]List.new()
    list.push(10)
    list.push(20)
    list.push(30)

    println(list[0])
    println(list[1])
    println(list[2])

    list[0] = 100
    println(list[0])
    let a = list[0]
    println(list[0])

    // Test struct mutation
    // [SubscriptPair]List might fail if SubscriptPair doesn't satisfy Copy trait, if it is enforced. 
    // But Int satisfies it so let's stick to Int if strict.
    // If [T Copy] is interpreted loosely, SubscriptPair should work.
    
    let pairs = [SubscriptPair]List.new()
    pairs.push(SubscriptPair.new(1, 2))
    
    // Member access on subscript returns a copy, so direct mutation affects the copy.
    // To update, we must use read-modify-write.
    let mut p = pairs[0]
    p.x = 200
    pairs[0] = p
    
    println(pairs[0].x)
}
