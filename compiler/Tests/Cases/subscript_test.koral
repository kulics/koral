// EXPECT: 10
// EXPECT: 20
// EXPECT: 30
// EXPECT: 100
// EXPECT: 100
// EXPECT: 200

public type Pair(mut x Int, mut y Int) Copy;

given Pair {
    public new(x Int, y Int) Self = Pair(x, y);
};

public let main() Void = {
    let list = [Int]List.new();
    list.push_back(10);
    list.push_back(20);
    list.push_back(30);

    print_int(list[0]);
    print_int(list[1]);
    print_int(list[2]);

    list[0] = 100;
    print_int(list[0]);
    let a = list[0];
    print_int(list[0]);

    // Test struct mutation
    // [Pair]List might fail if Pair doesn't satisfy Copy trait, if it is enforced. 
    // But Int satisfies it so let's stick to Int if strict.
    // If [T Copy] is interpreted loosely, Pair should work.
    
    let pairs = [Pair]List.new();
    pairs.push_back(Pair.new(1, 2));
    
    // Member access on subscript returns a copy, so direct mutation affects the copy.
    // To update, we must use read-modify-write.
    let mut p = pairs[0];
    p.x = 200;
    pairs[0] = p;
    
    print_int(pairs[0].x);
}
