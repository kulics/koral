// EXPECT: 10
// EXPECT: 20
// EXPECT: 30
// EXPECT: 100
// EXPECT: 100
// EXPECT: 200

public type SubscriptPair(mut x Int, mut y Int)

given SubscriptPair {
    public new(x Int, y Int) Self = SubscriptPair(x, y)
}

public let main() Void = {
    let list = [Int]List.new()
    list.push_back(10)
    list.push_back(20)
    list.push_back(30)

    print_line(list[0])
    print_line(list[1])
    print_line(list[2])

    list[0] = 100
    print_line(list[0])
    let a = list[0]
    print_line(list[0])

    // Test struct mutation
    // [SubscriptPair]List might fail if SubscriptPair doesn't satisfy Copy trait, if it is enforced. 
    // But Int satisfies it so let's stick to Int if strict.
    // If [T Copy] is interpreted loosely, SubscriptPair should work.
    
    let pairs = [SubscriptPair]List.new()
    pairs.push_back(SubscriptPair.new(1, 2))
    
    // Member access on subscript returns a copy, so direct mutation affects the copy.
    // To update, we must use read-modify-write.
    let mut p = pairs[0]
    p.x = 200
    pairs[0] = p
    
    print_line(pairs[0].x)
}
