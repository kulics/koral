// Test defer with control flow: return, break, continue

// Test 1: defer executes before early return
// EXPECT: test_defer_return:
// EXPECT: before return
// EXPECT: defer A
// EXPECT: returned early

// Test 2: defer executes only those declared before return
// EXPECT: test_defer_partial_return:
// EXPECT: start
// EXPECT: defer B
// EXPECT: defer A
// EXPECT: got early

// Test 3: defer executes when break exits a while loop
// EXPECT: test_defer_break_while:
// EXPECT: i=1
// EXPECT: defer cleanup 1
// EXPECT: i=2
// EXPECT: defer cleanup 2
// EXPECT: i=3
// EXPECT: defer cleanup 3
// EXPECT: after loop

// Test 4: defer executes on continue iterations in a while loop
// EXPECT: test_defer_continue_while:
// EXPECT: i=1 process
// EXPECT: defer iter 1
// EXPECT: i=2 skip
// EXPECT: defer iter 2
// EXPECT: i=3 process
// EXPECT: defer iter 3
// EXPECT: after loop

// Test 5: defer with break in a for loop
// EXPECT: test_defer_break_for:
// EXPECT: item=10
// EXPECT: defer for 10
// EXPECT: item=20
// EXPECT: defer for 20
// EXPECT: done

// Test 6: defer with continue in a for loop
// EXPECT: test_defer_continue_for:
// EXPECT: process 10
// EXPECT: defer for 10
// EXPECT: skip 20
// EXPECT: defer for 20
// EXPECT: process 30
// EXPECT: defer for 30
// EXPECT: done

let test_defer_return() Int = {
    println("test_defer_return:")
    println("before return")
    defer println("defer A")
    return 1
}

let test_defer_partial_return(x Int) Int = {
    println("start")
    defer println("defer A")
    if x > 0 then {
        defer println("defer B")
        return 42
    }
    yield 0
}

let test_defer_break_while() Void = {
    println("test_defer_break_while:")
    let mut i = 0
    while i < 10 then {
        i = i + 1
        defer {
            print("defer cleanup ")
            println(i)
        }
        print("i=")
        println(i)
        if i == 3 then {
            break
        }
    }
    println("after loop")
}

let test_defer_continue_while() Void = {
    println("test_defer_continue_while:")
    let mut i = 0
    while i < 3 then {
        i = i + 1
        defer {
            print("defer iter ")
            println(i)
        }
        if i == 2 then {
            print("i=")
            print(i)
            println(" skip")
            continue
        }
        print("i=")
        print(i)
        println(" process")
    }
    println("after loop")
}

let test_defer_break_for() Void = {
    println("test_defer_break_for:")
    let mut list = [Int]List.new()
    list.push(10)
    list.push(20)
    list.push(30)

    for x in list then {
        defer {
            print("defer for ")
            println(x)
        }
        print("item=")
        println(x)
        if x == 20 then {
            break
        }
    }
    println("done")
}

let test_defer_continue_for() Void = {
    println("test_defer_continue_for:")
    let mut list = [Int]List.new()
    list.push(10)
    list.push(20)
    list.push(30)

    for x in list then {
        defer {
            print("defer for ")
            println(x)
        }
        if x == 20 then {
            print("skip ")
            println(x)
            continue
        }
        print("process ")
        println(x)
    }
    println("done")
}

public let main() Int = {
    let r = test_defer_return()
    println("returned early")

    println("test_defer_partial_return:")
    let r2 = test_defer_partial_return(5)
    print("got ")
    println("early")

    test_defer_break_while()
    test_defer_continue_while()
    test_defer_break_for()
    test_defer_continue_for()
    yield 0
}
