// EXPECT: area:
// EXPECT: 200
// EXPECT: getX:
// EXPECT: 10
// EXPECT: access_member:
// EXPECT: 3
// EXPECT: member_assignment:
// EXPECT: 2

type Point(x Int, y Int);

given Point {
    area(self) Int = self.x * self.y;

    getX(self ref) Int = self.x;
};

type Foo(x Int, mut y Int);
type Bar(mut a Foo, mut b Foo);

let member_assignment_test() Int = {
    let mut bar = Bar(Foo(1, 1), Foo(2, 2));
    // bar.a.y = 2; // Nested assignment not fully supported/tested yet in this simple case?
    // The original test had:
    // let c Foo = a.b; a.b = c; a.b = a.b; a.a.y = 2;
    // Let's simplify to verify mutable member access
    bar.a.y = 2;
    bar.a.y
};

let main() Int = {
    let p = Point(10, 20);
    print_string("area:");
    print_int(p.area());
    
    print_string("getX:");
    print_int(p.getX());
    
    let f = Foo(1, 2);
    print_string("access_member:");
    print_int(f.x + f.y);
    
    print_string("member_assignment:");
    print_int(member_assignment_test());
    
    0
}
