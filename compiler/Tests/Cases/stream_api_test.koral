// Comprehensive test for Iterator extension API

let test_filter_map() Void = {
    let mut list = [Int]List.new()
    list.push(1)
    list.push(2)
    list.push(3)
    list.push(4)
    list.push(5)
    
    // Test filter (eager)
    let filtered = list.filter((x) -> x > 2)
    if filtered.count() <> 3 then { panic("filter count failed"); }
    if filtered[0] <> 3 then { panic("filter[0] failed"); }
    
    // Test map (eager)
    let mapped = list.map((x) -> x * 2)
    if mapped.count() <> 5 then { panic("map count failed"); }
    if mapped[0] <> 2 then { panic("map[0] failed"); }
    if mapped[4] <> 10 then { panic("map[4] failed"); }
    
    println("test_filter_map passed")
}

let test_stream_terminal_ops() Void = {
    let mut list = [Int]List.new()
    list.push(1)
    list.push(2)
    list.push(3)
    list.push(4)
    list.push(5)
    
    // Test any_match
    if not list.iterator().any((x) -> x > 3) then { panic("any failed"); }
    
    // Test all_match
    if not list.iterator().all((x) -> x > 0) then { panic("all failed"); }
    
    // Test none_match
    if list.iterator().any((x) -> x > 10) then { panic("not any failed"); }
    
    // Test find_index
    when list.iterator().position((x) -> x == 3) in {
        .Some(pos) then {
            if pos <> 2 then { panic("find_index value failed"); }
        },
        .None then { panic("find_index failed"); },
    }
    
    // Test is_empty
    let mut empty_list = [Int]List.new()
    if not empty_list.iterator().is_empty() then { panic("is_empty failed"); }
    
    println("test_stream_terminal_ops passed")
}

let test_stream_comparable_ops() Void = {
    let mut list = [Int]List.new()
    list.push(3)
    list.push(1)
    list.push(4)
    list.push(1)
    list.push(5)
    
    // Test max
    when list.iterator().max() in {
        .Some(m) then {
            if m <> 5 then { panic("max value failed"); }
        },
        .None then { panic("max failed"); },
    }
    
    // Test min
    when list.iterator().min() in {
        .Some(m) then {
            if m <> 1 then { panic("min value failed"); }
        },
        .None then { panic("min failed"); },
    }
    
    println("test_stream_comparable_ops passed")
}

let test_stream_equatable_ops() Void = {
    let mut list = [Int]List.new()
    list.push(1)
    list.push(2)
    list.push(3)
    
    // Test contains
    if not list.iterator().contains(2) then { panic("contains failed"); }
    if list.iterator().contains(99) then { panic("contains should not find 99"); }
    
    println("test_stream_equatable_ops passed")
}

let test_stream_intermediate_ops() Void = {
    let mut list = [Int]List.new()
    list.push(1)
    list.push(2)
    list.push(3)
    list.push(4)
    list.push(5)
    
    // Test stream filter + to_list
    let filtered = list.iterator().filter((x) -> x > 2).to_list()
    if filtered.count() <> 3 then { panic("stream filter count failed"); }
    if filtered[0] <> 3 then { panic("stream filter[0] failed"); }
    
    // Test stream map + to_list
    let mapped = list.iterator().map((x) -> x * 2).to_list()
    if mapped.count() <> 5 then { panic("stream map count failed"); }
    if mapped[0] <> 2 then { panic("stream map[0] failed"); }
    
    // Test stream take + to_list
    let taken = list.iterator().take(3).to_list()
    if taken.count() <> 3 then { panic("stream take count failed"); }
    if taken[2] <> 3 then { panic("stream take[2] failed"); }
    
    // Test stream skip + to_list
    let skipped = list.iterator().skip(2).to_list()
    if skipped.count() <> 3 then { panic("stream skip count failed"); }
    if skipped[0] <> 3 then { panic("stream skip[0] failed"); }
    
    // Test chained operations: filter + map + to_list
    let chained = list.iterator().filter((x) -> x > 1).map((x) -> x * 10).to_list()
    if chained.count() <> 4 then { panic("chained count failed"); }
    if chained[0] <> 20 then { panic("chained[0] failed"); }
    if chained[3] <> 50 then { panic("chained[3] failed"); }
    
    println("test_stream_intermediate_ops passed")
}

let test_stream_fold_reduce() Void = {
    let mut list = [Int]List.new()
    list.push(1)
    list.push(2)
    list.push(3)
    list.push(4)
    list.push(5)
    
    // Test fold - sum
    let sum = list.iterator().fold(0, (acc, x) -> acc + x)
    if sum <> 15 then { panic("fold sum failed"); }
    
    // Test reduce - sum
    when list.iterator().reduce((acc, x) -> acc + x) in {
        .Some(s) then {
            if s <> 15 then { panic("reduce sum value failed"); }
        },
        .None then { panic("reduce failed"); },
    }
    
    println("test_stream_fold_reduce passed")
}

let test_map_keys_values() Void = {
    let mut m = [Int, String]Map.new()
    m.insert(1, "one");
    m.insert(2, "two");
    m.insert(3, "three");
    
    // Test keys
    let mut key_count = 0
    for _ in m.keys() then {
        key_count += 1
    }
    if key_count <> 3 then { panic("keys count failed"); }
    
    // Test values
    let mut val_count = 0
    for _ in m.values() then {
        val_count += 1
    }
    if val_count <> 3 then { panic("values count failed"); }
    
    println("test_map_keys_values passed")
}

let test_string_iterators() Void = {
    // Test split
    let s = "a,b,c"
    let mut count = 0
    for _ in s.split(",") then {
        count += 1
    }
    if count <> 3 then { panic("split count failed"); }
    
    // Test lines
    let lines_str = "line1\nline2\nline3"
    let mut line_count = 0
    for _ in lines_str.lines() then {
        line_count += 1
    }
    if line_count <> 3 then { panic("lines count failed"); }
    
    // Test split_ascii_whitespace
    let ws_str = "  a  b  c  "
    let mut ws_count = 0
    for _ in ws_str.split_ascii_whitespace() then {
        ws_count += 1
    }
    if ws_count <> 3 then { panic("split_ascii_whitespace count failed"); }
    
    println("test_string_iterators passed")
}

let test_set_filter_map() Void = {
    let mut set = [Int]Set.new()
    set.insert(1);
    set.insert(2);
    set.insert(3);
    set.insert(4);
    set.insert(5);
    
    // Test filter
    let filtered = set.filter((x) -> x > 2)
    if filtered.count() <> 3 then { panic("set filter count failed"); }
    
    // Test map
    let mapped = set.map((x) -> x * 10)
    if mapped.count() <> 5 then { panic("set map count failed"); }
    if not mapped.contains(10) then { panic("set map contains 10 failed"); }
    if not mapped.contains(50) then { panic("set map contains 50 failed"); }
    
    println("test_set_filter_map passed")
}

let main() Int = {
    test_filter_map()
    test_stream_terminal_ops()
    test_stream_comparable_ops()
    test_stream_equatable_ops()
    test_stream_intermediate_ops()
    test_stream_fold_reduce()
    test_map_keys_values()
    test_string_iterators()
    test_set_filter_map()
    
    println("All Iterator API tests passed!")
    yield 0
}
