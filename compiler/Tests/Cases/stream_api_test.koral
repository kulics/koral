// Comprehensive test for Stream API

let test_filter_map() Void = {
    let mut list = [Int]List.new()
    list.push(1)
    list.push(2)
    list.push(3)
    list.push(4)
    list.push(5)
    
    // Test filter (eager)
    let filtered = list.filter((x) -> x > 2)
    if filtered.count() <> 3 then { panic("filter count failed"); }
    if filtered[0] <> 3 then { panic("filter[0] failed"); }
    
    // Test map (eager)
    let mapped = list.map((x) -> x * 2)
    if mapped.count() <> 5 then { panic("map count failed"); }
    if mapped[0] <> 2 then { panic("map[0] failed"); }
    if mapped[4] <> 10 then { panic("map[4] failed"); }
    
    print_line("test_filter_map passed")
}

let test_stream_terminal_ops() Void = {
    let mut list = [Int]List.new()
    list.push(1)
    list.push(2)
    list.push(3)
    list.push(4)
    list.push(5)
    
    // Test any_match - using stream() function with explicit type params
    if not stream(list).any_match((x) -> x > 3) then { panic("any_match failed"); }
    
    // Test all_match
    if not stream(list).all_match((x) -> x > 0) then { panic("all_match failed"); }
    
    // Test none_match
    if not stream(list).none_match((x) -> x > 10) then { panic("none_match failed"); }
    
    // Test find_index
    when stream(list).find_index((x) -> x == 3) is {
        .Some(pos) then {
            if pos <> 2 then { panic("find_index value failed"); }
        },
        .None then { panic("find_index failed"); },
    }
    
    // Test is_empty
    let mut empty_list = [Int]List.new()
    if not stream(empty_list).is_empty() then { panic("is_empty failed"); }
    
    print_line("test_stream_terminal_ops passed")
}

let test_stream_comparable_ops() Void = {
    let mut list = [Int]List.new()
    list.push(3)
    list.push(1)
    list.push(4)
    list.push(1)
    list.push(5)
    
    // Test max
    when stream(list).max() is {
        .Some(m) then {
            if m <> 5 then { panic("max value failed"); }
        },
        .None then { panic("max failed"); },
    }
    
    // Test min
    when stream(list).min() is {
        .Some(m) then {
            if m <> 1 then { panic("min value failed"); }
        },
        .None then { panic("min failed"); },
    }
    
    print_line("test_stream_comparable_ops passed")
}

let test_stream_equatable_ops() Void = {
    let mut list = [Int]List.new()
    list.push(1)
    list.push(2)
    list.push(3)
    
    // Test contains
    if not stream(list).contains(2) then { panic("contains failed"); }
    if stream(list).contains(99) then { panic("contains should not find 99"); }
    
    print_line("test_stream_equatable_ops passed")
}

let test_stream_intermediate_ops() Void = {
    let mut list = [Int]List.new()
    list.push(1)
    list.push(2)
    list.push(3)
    list.push(4)
    list.push(5)
    
    // Test stream filter + to_list
    let filtered = stream(list).filter((x) -> x > 2).to_list()
    if filtered.count() <> 3 then { panic("stream filter count failed"); }
    if filtered[0] <> 3 then { panic("stream filter[0] failed"); }
    
    // Test stream map + to_list
    let mapped = stream(list).map((x) -> x * 2).to_list()
    if mapped.count() <> 5 then { panic("stream map count failed"); }
    if mapped[0] <> 2 then { panic("stream map[0] failed"); }
    
    // Test stream take + to_list
    let taken = stream(list).take(3).to_list()
    if taken.count() <> 3 then { panic("stream take count failed"); }
    if taken[2] <> 3 then { panic("stream take[2] failed"); }
    
    // Test stream skip + to_list
    let skipped = stream(list).skip(2).to_list()
    if skipped.count() <> 3 then { panic("stream skip count failed"); }
    if skipped[0] <> 3 then { panic("stream skip[0] failed"); }
    
    // Test chained operations: filter + map + to_list
    let chained = stream(list).filter((x) -> x > 1).map((x) -> x * 10).to_list()
    if chained.count() <> 4 then { panic("chained count failed"); }
    if chained[0] <> 20 then { panic("chained[0] failed"); }
    if chained[3] <> 50 then { panic("chained[3] failed"); }
    
    print_line("test_stream_intermediate_ops passed")
}

let test_stream_fold_reduce() Void = {
    let mut list = [Int]List.new()
    list.push(1)
    list.push(2)
    list.push(3)
    list.push(4)
    list.push(5)
    
    // Test fold - sum
    let sum = stream(list).fold(0, (acc, x) -> acc + x)
    if sum <> 15 then { panic("fold sum failed"); }
    
    // Test reduce - sum
    when stream(list).reduce((acc, x) -> acc + x) is {
        .Some(s) then {
            if s <> 15 then { panic("reduce sum value failed"); }
        },
        .None then { panic("reduce failed"); },
    }
    
    print_line("test_stream_fold_reduce passed")
}

let test_map_keys_values() Void = {
    let mut m = [Int, String]Map.new()
    m.insert(1, "one");
    m.insert(2, "two");
    m.insert(3, "three");
    
    // Test keys
    let keys = m.keys()
    let mut key_it = keys.iterator()
    let mut key_count = 0
    while key_it.next() is .Some(_) then {
        key_count += 1
    }
    if key_count <> 3 then { panic("keys count failed"); }
    
    // Test values
    let values = m.values()
    let mut val_it = values.iterator()
    let mut val_count = 0
    while val_it.next() is .Some(_) then {
        val_count += 1
    }
    if val_count <> 3 then { panic("values count failed"); }
    
    print_line("test_map_keys_values passed")
}

let test_string_iterators() Void = {
    // Test split
    let s = "a,b,c"
    let split = s.split(",")
    let mut it = split.iterator()
    let mut count = 0
    while it.next() is .Some(_) then {
        count += 1
    }
    if count <> 3 then { panic("split count failed"); }
    
    // Test lines
    let lines_str = "line1\nline2\nline3"
    let lines = lines_str.lines()
    let mut lit = lines.iterator()
    let mut line_count = 0
    while lit.next() is .Some(_) then {
        line_count += 1
    }
    if line_count <> 3 then { panic("lines count failed"); }
    
    // Test split_ascii_whitespace
    let ws_str = "  a  b  c  "
    let ws = ws_str.split_ascii_whitespace()
    let mut wit = ws.iterator()
    let mut ws_count = 0
    while wit.next() is .Some(_) then {
        ws_count += 1
    }
    if ws_count <> 3 then { panic("split_ascii_whitespace count failed"); }
    
    print_line("test_string_iterators passed")
}

let test_set_filter_map() Void = {
    let mut set = [Int]Set.new()
    set.insert(1);
    set.insert(2);
    set.insert(3);
    set.insert(4);
    set.insert(5);
    
    // Test filter
    let filtered = set.filter((x) -> x > 2)
    if filtered.count() <> 3 then { panic("set filter count failed"); }
    
    // Test map
    let mapped = set.map((x) -> x * 10)
    if mapped.count() <> 5 then { panic("set map count failed"); }
    if not mapped.contains(10) then { panic("set map contains 10 failed"); }
    if not mapped.contains(50) then { panic("set map contains 50 failed"); }
    
    print_line("test_set_filter_map passed")
}

let main() Int = {
    test_filter_map()
    test_stream_terminal_ops()
    test_stream_comparable_ops()
    test_stream_equatable_ops()
    test_stream_intermediate_ops()
    test_stream_fold_reduce()
    test_map_keys_values()
    test_string_iterators()
    test_set_filter_map()
    
    print_line("All Stream API tests passed!")
    yield 0
}
