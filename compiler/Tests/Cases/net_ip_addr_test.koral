// EXPECT: ipv4_new_octets_ok
// EXPECT: ipv4_static_ok
// EXPECT: ipv4_from_string_ok
// EXPECT: ipv4_from_string_invalid_ok
// EXPECT: ipv4_to_string_ok
// EXPECT: ipv4_classify_ok
// EXPECT: ipv4_equals_ok
// EXPECT: ipv6_new_segments_ok
// EXPECT: ipv6_static_ok
// EXPECT: ipv6_from_string_ok
// EXPECT: ipv6_from_string_invalid_ok
// EXPECT: ipv6_to_string_ok
// EXPECT: ipv6_classify_ok
// EXPECT: ipv6_equals_ok
// EXPECT: ipaddr_from_string_ok
// EXPECT: ipaddr_delegate_ok
// EXPECT: ipaddr_equals_ok

using * in "std/net"

let is_ok(r [Ipv4Addr]Result) Bool = when r in { .Ok(_) then true, .Error(_) then false }
let is_err_v4(r [Ipv4Addr]Result) Bool = when r in { .Ok(_) then false, .Error(_) then true }
let is_ok_v6(r [Ipv6Addr]Result) Bool = when r in { .Ok(_) then true, .Error(_) then false }
let is_err_v6(r [Ipv6Addr]Result) Bool = when r in { .Ok(_) then false, .Error(_) then true }
let is_ok_ip(r [IpAddr]Result) Bool = when r in { .Ok(_) then true, .Error(_) then false }
let is_err_ip(r [IpAddr]Result) Bool = when r in { .Ok(_) then false, .Error(_) then true }

let main() Void = {
    // ========================================================================
    // Ipv4Addr: new + octets roundtrip
    // ========================================================================
    let a1 = Ipv4Addr.new(192, 168, 1, 100)
    let octs = a1.octets()
    assert(octs.count() == 4, "octets count")
    assert(octs[0] == (UInt8)192, "octet a")
    assert(octs[1] == (UInt8)168, "octet b")
    assert(octs[2] == (UInt8)1, "octet c")
    assert(octs[3] == (UInt8)100, "octet d")
    println("ipv4_new_octets_ok")

    // ========================================================================
    // Ipv4Addr: static constructors
    // ========================================================================
    let lo = Ipv4Addr.localhost()
    assert(lo.to_string() == "127.0.0.1", "localhost")
    let un = Ipv4Addr.unspecified()
    assert(un.to_string() == "0.0.0.0", "unspecified")
    let bc = Ipv4Addr.broadcast()
    assert(bc.to_string() == "255.255.255.255", "broadcast")
    println("ipv4_static_ok")

    // ========================================================================
    // Ipv4Addr: from_string valid inputs
    // ========================================================================
    let p1 = Ipv4Addr.parse("192.168.1.1")
    when p1 in {
        .Ok(addr) then {
            let o = addr.octets()
            assert(o[0] == (UInt8)192, "parse octet a")
            assert(o[1] == (UInt8)168, "parse octet b")
            assert(o[2] == (UInt8)1, "parse octet c")
            assert(o[3] == (UInt8)1, "parse octet d")
        },
        .Error(_) then assert(false, "from_string should succeed"),
    }
    assert(is_ok(Ipv4Addr.parse("0.0.0.0")), "parse 0.0.0.0")
    assert(is_ok(Ipv4Addr.parse("255.255.255.255")), "parse 255.255.255.255")
    println("ipv4_from_string_ok")

    // ========================================================================
    // Ipv4Addr: from_string invalid inputs
    // ========================================================================
    assert(is_err_v4(Ipv4Addr.parse("01.02.03.04")), "leading zeros")
    assert(is_err_v4(Ipv4Addr.parse("256.0.0.0")), "out of range")
    assert(is_err_v4(Ipv4Addr.parse("192.168.1")), "incomplete")
    assert(is_err_v4(Ipv4Addr.parse("")), "empty")
    assert(is_err_v4(Ipv4Addr.parse("1.2.3.4.5")), "too many octets")
    assert(is_err_v4(Ipv4Addr.parse("abc")), "non-numeric")
    assert(is_err_v4(Ipv4Addr.parse("1..2.3")), "consecutive dots")
    println("ipv4_from_string_invalid_ok")

    // ========================================================================
    // Ipv4Addr: to_string + roundtrip
    // ========================================================================
    let rt1 = Ipv4Addr.new(10, 0, 0, 1)
    let s1 = rt1.to_string()
    assert(s1 == "10.0.0.1", "to_string")
    let rt1_back = Ipv4Addr.parse(s1).unwrap()
    assert(rt1.equals(rt1_back), "roundtrip")
    println("ipv4_to_string_ok")

    // ========================================================================
    // Ipv4Addr: classification methods
    // ========================================================================
    assert(Ipv4Addr.new(127, 0, 0, 1).is_loopback(), "127.0.0.1 loopback")
    assert(Ipv4Addr.new(127, 255, 0, 0).is_loopback(), "127.255.0.0 loopback")
    assert(not Ipv4Addr.new(128, 0, 0, 1).is_loopback(), "128.0.0.1 not loopback")

    assert(Ipv4Addr.new(0, 0, 0, 0).is_unspecified(), "0.0.0.0 unspecified")
    assert(not Ipv4Addr.new(0, 0, 0, 1).is_unspecified(), "0.0.0.1 not unspecified")

    assert(Ipv4Addr.new(255, 255, 255, 255).is_broadcast(), "broadcast")
    assert(not Ipv4Addr.new(255, 255, 255, 0).is_broadcast(), "not broadcast")

    assert(Ipv4Addr.new(224, 0, 0, 1).is_multicast(), "224.0.0.1 multicast")
    assert(Ipv4Addr.new(239, 255, 255, 255).is_multicast(), "239.x multicast")
    assert(not Ipv4Addr.new(240, 0, 0, 1).is_multicast(), "240.x not multicast")

    assert(Ipv4Addr.new(10, 0, 0, 1).is_private(), "10.x private")
    assert(Ipv4Addr.new(172, 16, 0, 1).is_private(), "172.16.x private")
    assert(Ipv4Addr.new(172, 31, 255, 255).is_private(), "172.31.x private")
    assert(not Ipv4Addr.new(172, 32, 0, 0).is_private(), "172.32.x not private")
    assert(Ipv4Addr.new(192, 168, 0, 1).is_private(), "192.168.x private")
    assert(not Ipv4Addr.new(8, 8, 8, 8).is_private(), "8.8.8.8 not private")
    println("ipv4_classify_ok")

    // ========================================================================
    // Ipv4Addr: equals
    // ========================================================================
    assert(Ipv4Addr.new(1, 2, 3, 4).equals(Ipv4Addr.new(1, 2, 3, 4)), "equal")
    assert(not Ipv4Addr.new(1, 2, 3, 4).equals(Ipv4Addr.new(1, 2, 3, 5)), "not equal")
    println("ipv4_equals_ok")

    // ========================================================================
    // Ipv6Addr: new + segments roundtrip
    // ========================================================================
    let v6a = Ipv6Addr.new(8193, 3512, 0, 0, 0, 0, 0, 1)
    let segs = v6a.segments()
    assert(segs.count() == 8, "segments count")
    assert(segs[0] == (UInt16)8193, "seg a")
    assert(segs[1] == (UInt16)3512, "seg b")
    assert(segs[7] == (UInt16)1, "seg h")
    println("ipv6_new_segments_ok")

    // ========================================================================
    // Ipv6Addr: static constructors
    // ========================================================================
    let v6lo = Ipv6Addr.localhost()
    assert(v6lo.to_string() == "::1", "ipv6 localhost")
    let v6un = Ipv6Addr.unspecified()
    assert(v6un.to_string() == "::", "ipv6 unspecified")
    println("ipv6_static_ok")

    // ========================================================================
    // Ipv6Addr: from_string valid inputs
    // ========================================================================
    assert(is_ok_v6(Ipv6Addr.parse("::1")), "parse ::1")
    when Ipv6Addr.parse("::1") in {
        .Ok(addr) then assert(addr.is_loopback(), "::1 is loopback"),
        .Error(_) then {},
    }
    assert(is_ok_v6(Ipv6Addr.parse("2001:db8::1")), "parse 2001:db8::1")
    assert(is_ok_v6(Ipv6Addr.parse("fe80::1")), "parse fe80::1")
    assert(is_ok_v6(Ipv6Addr.parse("::")), "parse ::")
    assert(is_ok_v6(Ipv6Addr.parse("1:2:3:4:5:6:7:8")), "parse full form")
    println("ipv6_from_string_ok")

    // ========================================================================
    // Ipv6Addr: from_string invalid inputs
    // ========================================================================
    assert(is_err_v6(Ipv6Addr.parse("::1::2")), "multiple ::")
    assert(is_err_v6(Ipv6Addr.parse("")), "empty")
    assert(is_err_v6(Ipv6Addr.parse("1:2:3:4:5:6:7:8:9")), "too many groups")
    assert(is_err_v6(Ipv6Addr.parse("gggg::1")), "invalid hex")
    println("ipv6_from_string_invalid_ok")

    // ========================================================================
    // Ipv6Addr: to_string + roundtrip
    // ========================================================================
    let v6rt = Ipv6Addr.new(8193, 3512, 0, 0, 0, 0, 0, 1)
    let v6s = v6rt.to_string()
    assert(v6s == "2001:db8::1", "ipv6 to_string")
    let v6rt_back = Ipv6Addr.parse(v6s).unwrap()
    assert(v6rt.equals(v6rt_back), "ipv6 roundtrip")
    println("ipv6_to_string_ok")

    // ========================================================================
    // Ipv6Addr: classification methods
    // ========================================================================
    assert(Ipv6Addr.new(0, 0, 0, 0, 0, 0, 0, 1).is_loopback(), "::1 loopback")
    assert(not Ipv6Addr.new(0, 0, 0, 0, 0, 0, 0, 2).is_loopback(), "::2 not loopback")
    assert(Ipv6Addr.new(0, 0, 0, 0, 0, 0, 0, 0).is_unspecified(), ":: unspecified")
    assert(not Ipv6Addr.new(0, 0, 0, 0, 0, 0, 0, 1).is_unspecified(), "::1 not unspecified")
    assert(Ipv6Addr.new(65280, 0, 0, 0, 0, 0, 0, 0).is_multicast(), "ff00:: multicast")
    assert(Ipv6Addr.new(65535, 0, 0, 0, 0, 0, 0, 0).is_multicast(), "ffff:: multicast")
    assert(not Ipv6Addr.new(65279, 0, 0, 0, 0, 0, 0, 0).is_multicast(), "feff:: not multicast")
    println("ipv6_classify_ok")

    // ========================================================================
    // Ipv6Addr: equals
    // ========================================================================
    assert(Ipv6Addr.localhost().equals(Ipv6Addr.new(0, 0, 0, 0, 0, 0, 0, 1)), "ipv6 equal")
    assert(not Ipv6Addr.localhost().equals(Ipv6Addr.unspecified()), "ipv6 not equal")
    println("ipv6_equals_ok")

    // ========================================================================
    // IpAddr: from_string auto-detect
    // ========================================================================
    let ip1 = IpAddr.parse("192.168.1.1")
    assert(is_ok_ip(ip1), "ipaddr parse v4")
    when ip1 in {
        .Ok(addr) then assert(addr.is_ipv4(), "should be v4"),
        .Error(_) then {},
    }
    let ip2 = IpAddr.parse("::1")
    assert(is_ok_ip(ip2), "ipaddr parse v6")
    when ip2 in {
        .Ok(addr) then assert(addr.is_ipv6(), "should be v6"),
        .Error(_) then {},
    }
    assert(is_err_ip(IpAddr.parse("not_an_ip")), "ipaddr invalid")
    assert(is_err_ip(IpAddr.parse("")), "ipaddr empty")
    println("ipaddr_from_string_ok")

    // ========================================================================
    // IpAddr: delegation methods
    // ========================================================================
    let ipv4_lo = IpAddr.V4(Ipv4Addr.localhost())
    assert(ipv4_lo.is_loopback(), "v4 loopback delegate")
    assert(not ipv4_lo.is_unspecified(), "v4 not unspecified delegate")
    assert(not ipv4_lo.is_multicast(), "v4 not multicast delegate")
    assert(ipv4_lo.is_ipv4(), "is_ipv4")
    assert(not ipv4_lo.is_ipv6(), "not is_ipv6")
    assert(ipv4_lo.to_string() == "127.0.0.1", "v4 to_string delegate")

    let ipv6_lo = IpAddr.V6(Ipv6Addr.localhost())
    assert(ipv6_lo.is_loopback(), "v6 loopback delegate")
    assert(not ipv6_lo.is_unspecified(), "v6 not unspecified delegate")
    assert(ipv6_lo.is_ipv6(), "is_ipv6")
    assert(not ipv6_lo.is_ipv4(), "not is_ipv4")
    assert(ipv6_lo.to_string() == "::1", "v6 to_string delegate")

    let ip_rt = IpAddr.parse("10.0.0.1").unwrap()
    let ip_rt_back = IpAddr.parse(ip_rt.to_string()).unwrap()
    assert(ip_rt.equals(ip_rt_back), "ipaddr roundtrip")
    println("ipaddr_delegate_ok")

    // ========================================================================
    // IpAddr: equals
    // ========================================================================
    let eq1 = IpAddr.V4(Ipv4Addr.new(1, 2, 3, 4))
    let eq2 = IpAddr.V4(Ipv4Addr.new(1, 2, 3, 4))
    let eq3 = IpAddr.V6(Ipv6Addr.localhost())
    assert(eq1.equals(eq2), "ipaddr v4 equal")
    assert(not eq1.equals(eq3), "ipaddr v4 != v6")
    assert(eq3.equals(IpAddr.V6(Ipv6Addr.new(0, 0, 0, 0, 0, 0, 0, 1))), "ipaddr v6 equal")
    println("ipaddr_equals_ok")
}
