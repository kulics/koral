// Test pattern combinators: and, or, not
// EXPECT: test_or_literals: PASS
// EXPECT: test_and_comparison: PASS
// EXPECT: test_not_literal: PASS
// EXPECT: test_combined_patterns: PASS
// EXPECT: test_or_with_binding: PASS
// EXPECT: test_and_with_binding: PASS
// EXPECT: test_precedence: PASS
// EXPECT: test_negative_literal: PASS
// EXPECT: All pattern combinator tests passed!

type MyOption {
    None(),
    Some(val Int),
}

// Test or pattern with literals
let test_or_literals() Int = {
    let x = 2
    yield when x in {
        1 or 2 or 3 then 1,
        _ then 0,
    }
}

// Test and pattern with comparison
let test_and_comparison() Int = {
    let x = 5
    yield when x in {
        > 0 and < 10 then 1,
        _ then 0,
    }
}

// Test not pattern
let test_not_literal() Int = {
    let x = 5
    yield when x in {
        not 0 then 1,
        _ then 0,
    }
}

// Test combined patterns
let test_combined_patterns() Int = {
    let x = 15
    // Match: x is (< 0) or (> 10 and < 20)
    yield when x in {
        < 0 or > 10 and < 20 then 1,
        _ then 0,
    }
}

// Test or pattern with variable binding (both branches bind same variable)
let test_or_with_binding() Int = {
    let opt = MyOption.Some(42)
    // Note: or patterns require both branches to bind the same variables
    // So we test with literals instead
    let x = 2
    yield when x in {
        1 or 2 or 3 then 1,
        _ then 0,
    }
}

// Test and pattern with variable binding
let test_and_with_binding() Int = {
    let x = 5
    yield when x in {
        n and > 0 then n,  // n binds to x, and x > 0
        _ then 0,
    }
}

// Test precedence: not > and > or
let test_precedence() Int = {
    let x = 5
    // This should parse as: (not 0) or ((> 10) and (< 20))
    // For x = 5: (not 0) is true (5 != 0), so result is 1
    yield when x in {
        not 0 or > 10 and < 20 then 1,
        _ then 0,
    }
}

// Test negative integer literal pattern
let test_negative_literal() Int = {
    let x = 0 - 5  // x = -5
    yield when x in {
        -5 then 1,
        _ then 0,
    }
}

let main() Int = {
    // Test or pattern with literals
    if test_or_literals() == 1 then {
        println("test_or_literals: PASS")
    } else {
        println("test_or_literals: FAIL")
        return 1
    }
    
    // Test and pattern with comparison
    if test_and_comparison() == 1 then {
        println("test_and_comparison: PASS")
    } else {
        println("test_and_comparison: FAIL")
        return 1
    }
    
    // Test not pattern
    if test_not_literal() == 1 then {
        println("test_not_literal: PASS")
    } else {
        println("test_not_literal: FAIL")
        return 1
    }
    
    // Test combined patterns
    if test_combined_patterns() == 1 then {
        println("test_combined_patterns: PASS")
    } else {
        println("test_combined_patterns: FAIL")
        return 1
    }
    
    // Test or with binding
    if test_or_with_binding() == 1 then {
        println("test_or_with_binding: PASS")
    } else {
        println("test_or_with_binding: FAIL")
        return 1
    }
    
    // Test and with binding
    if test_and_with_binding() == 5 then {
        println("test_and_with_binding: PASS")
    } else {
        println("test_and_with_binding: FAIL")
        return 1
    }
    
    // Test precedence
    if test_precedence() == 1 then {
        println("test_precedence: PASS")
    } else {
        println("test_precedence: FAIL")
        return 1
    }
    
    // Test negative literal
    if test_negative_literal() == 1 then {
        println("test_negative_literal: PASS")
    } else {
        println("test_negative_literal: FAIL")
        return 1
    }
    
    println("All pattern combinator tests passed!")
    yield 0
}
