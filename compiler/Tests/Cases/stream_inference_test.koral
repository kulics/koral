// Test for Iterator API type inference without explicit type annotations

let test_stream_inference() Void = {
    let mut list = [Int]List.new()
    list.push(1)
    list.push(2)
    list.push(3)
    list.push(4)
    list.push(5)
    
    // Test: iterator() method should infer T=Int, R=[Int]ListIterator
    // Without explicit type annotations
    let s = list.iterator()
    
    // Test filter - should work without type annotations
    let filtered = list.iterator().filter((x) -> x > 2).to_list()
    if filtered.count() <> 3 then { panic("filter count failed"); }
    if filtered[0] <> 3 then { panic("filter[0] failed"); }
    
    // Test any_match
    if not list.iterator().any((x) -> x > 3) then { panic("any failed"); }
    
    // Test all_match
    if not list.iterator().all((x) -> x > 0) then { panic("all failed"); }
    
    // Test none_match
    if list.iterator().any((x) -> x > 10) then { panic("not any failed"); }
    
    // Test fold - sum
    let sum = list.iterator().fold(0, (acc, x) -> acc + x)
    if sum <> 15 then { panic("fold sum failed"); }
    
    // Test take
    let taken = list.iterator().take(3).to_list()
    if taken.count() <> 3 then { panic("take count failed"); }
    
    // Test skip
    let skipped = list.iterator().skip(2).to_list()
    if skipped.count() <> 3 then { panic("skip count failed"); }
    
    println("stream_inference_test passed")
}

let main() Int = {
    test_stream_inference()
    yield 0
}
