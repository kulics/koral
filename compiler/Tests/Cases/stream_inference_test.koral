// Test for Stream API type inference without explicit type annotations

let test_stream_inference() Void = {
    let mut list = [Int]List.new()
    list.push(1)
    list.push(2)
    list.push(3)
    list.push(4)
    list.push(5)
    
    // Test: stream() should infer T=Int, R=[Int]ListIterator, C=[Int]List
    // Without explicit type annotations
    let s = stream(list)
    
    // Test filter - should work without type annotations
    let filtered = stream(list).filter((x) -> x > 2).to_list()
    if filtered.count() <> 3 then { panic("filter count failed"); }
    if filtered[0] <> 3 then { panic("filter[0] failed"); }
    
    // Test any_match
    if not stream(list).any_match((x) -> x > 3) then { panic("any_match failed"); }
    
    // Test all_match
    if not stream(list).all_match((x) -> x > 0) then { panic("all_match failed"); }
    
    // Test none_match
    if not stream(list).none_match((x) -> x > 10) then { panic("none_match failed"); }
    
    // Test fold - sum
    let sum = stream(list).fold(0, (acc, x) -> acc + x)
    if sum <> 15 then { panic("fold sum failed"); }
    
    // Test take
    let taken = stream(list).take(3).to_list()
    if taken.count() <> 3 then { panic("take count failed"); }
    
    // Test skip
    let skipped = stream(list).skip(2).to_list()
    if skipped.count() <> 3 then { panic("skip count failed"); }
    
    print_line("stream_inference_test passed")
}

let main() Int = {
    test_stream_inference()
    0
}
