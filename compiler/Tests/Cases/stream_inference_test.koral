// Test for Stream API type inference without explicit type annotations

let test_stream_inference() Void = {
    let mut list = [Int]List.new()
    list.push_back(1)
    list.push_back(2)
    list.push_back(3)
    list.push_back(4)
    list.push_back(5)
    
    // Test: stream() should infer T=Int, R=[Int]ListIterator, C=[Int]List
    // Without explicit type annotations
    let s = stream(list)
    
    // Test filter - should work without type annotations
    let filtered = stream(list).filter((x) -> x > 2).to_list()
    if filtered.count() <> 3 then { panic("filter count failed"); }
    if filtered[0] <> 3 then { panic("filter[0] failed"); }
    
    // Test any
    if not stream(list).any((x) -> x > 3) then { panic("any failed"); }
    
    // Test all
    if not stream(list).all((x) -> x > 0) then { panic("all failed"); }
    
    // Test none
    if not stream(list).none((x) -> x > 10) then { panic("none failed"); }
    
    // Test fold - sum
    let sum = stream(list).fold(0, (acc, x) -> acc + x)
    if sum <> 15 then { panic("fold sum failed"); }
    
    // Test take
    let taken = stream(list).take(3).to_list()
    if taken.count() <> 3 then { panic("take count failed"); }
    
    // Test skip
    let skipped = stream(list).skip(2).to_list()
    if skipped.count() <> 3 then { panic("skip count failed"); }
    
    print_line("stream_inference_test passed")
}

let main() Int = {
    test_stream_inference()
    0
}
