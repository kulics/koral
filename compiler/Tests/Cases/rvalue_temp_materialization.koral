// EXPECT: Rvalue temporary materialization tests passed

// Test 1: String literal method call with self ref
// "hello".hash() should work - hash takes self ref
let test_string_literal_hash() Void = {
    let h1 = "hello".hash()
    let h2 = "hello".hash()
    assert(h1 == h2, "same string same hash")
    
    let h3 = "world".hash()
    // Different strings should have different hashes (with high probability)
    // We just check they compute without error
    assert(h1 > 0 or h1 == 0, "hash computed")
    assert(h3 > 0 or h3 == 0, "hash computed 2")
}

// Test 2: Constructor return value method call
// [Int]Option.Some(42).is_some() should work - is_some takes self ref
let test_constructor_method_call() Void = {
    let result = [Int]Option.Some(42).is_some()
    assert(result, "Some is_some")
    
    let result2 = [Int]Option.None().is_none()
    assert(result2, "None is_none")
}

// Test 3: Chain method calls on rvalue
// "  hello  ".trim_ascii_whitespace().hash() should work
let test_chain_method_call() Void = {
    // trim_ascii_whitespace returns a new String (rvalue)
    // then we call hash on it (which takes self ref)
    let h = "  hello  ".trim_ascii_whitespace().hash()
    let expected = "hello".hash()
    assert(h == expected, "chain method hash")
}

// Test 4: Integer literal hash
// 42.hash() should work - hash takes self ref
let test_int_literal_hash() Void = {
    let x Int = 42
    let h1 = x.hash()
    let h2 = x.hash()
    assert(h1 == h2, "same int same hash")
}

// Test 5: Bool literal hash
let test_bool_literal_hash() Void = {
    let h_true = true.hash()
    let h_false = false.hash()
    // true and false should have different hashes
    assert(h_true <> h_false, "bool hash different")
}

// Test 6: List method call on constructor result
let test_list_constructor_method() Void = {
    // [Int]List.new() returns rvalue, count takes self ref
    let c = [Int]List.new().count()
    assert(c == 0, "new list count")
    
    let empty = [Int]List.new().is_empty()
    assert(empty, "new list is_empty")
}

// Test 7: Result type method call
let test_result_method_call() Void = {
    let ok_result = [Int, String]Result.Ok(42).is_ok()
    assert(ok_result, "Ok is_ok")
    
    let err_result = [Int, String]Result.Err("error").is_err()
    assert(err_result, "Err is_err")
}

// Test 8: Nested temporary materialization
let test_nested_temp() Void = {
    // Create Option containing a value, check is_some
    let opt = [Int]Option.Some(100)
    let is_some = opt.is_some()
    assert(is_some, "nested is_some")
}

let main() Void = {
    test_string_literal_hash()
    test_constructor_method_call()
    test_chain_method_call()
    test_int_literal_hash()
    test_bool_literal_hash()
    test_list_constructor_method()
    test_result_method_call()
    test_nested_temp()
    print_string("Rvalue temporary materialization tests passed")
}
