// Test case for legal indirect recursion through ref
// This should compile successfully because ref breaks the cycle
// EXPECT: OK

// Two types that reference each other through ref
// This is legal because ref is a fixed-size pointer
type Person(
    name String,
    friend Person ref  // ref breaks the cycle
)

type TreeNode(
    value Int,
    left [TreeNode ref]Option,
    right [TreeNode ref]Option
)

// Mutual recursion through ref is also OK
type Parent(
    name String,
    child Child ref
)

type Child(
    name String,
    parent Parent ref
)

let main() Int = {
    println("OK")
    yield 0
}
