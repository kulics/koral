// Test basic trait object creation, method call, and reference counting
// EXPECT: hello from Greeter
// EXPECT: hello from Greeter2
// EXPECT: hello from wrapped(GenericGreeter)
// EXPECT: converted: 42

trait Greet {
    greet(self) String
}

type Greeter(name String)

given Greeter {
    public greet(self) String = "hello from " + self.name
}

type Greeter2(name String)

given Greeter2 {
    public greet(self) String = "hello from " + self.name
}

// Scenario 3: Generic type implementing a non-generic trait
type [T ToString]Wrapper(value T, label String)

given[T ToString] [T]Wrapper {
    public greet(self) String = "hello from wrapped(" + self.label + ")"
}

// Scenario 4: Generic trait used as trait object
trait [T Any]Converter {
    convert(self) T
}

type IntToString(value Int)

given IntToString {
    public convert(self) String = "converted: " + self.value.to_string()
}

let main() Int = {
    // Basic trait object creation from T ref
    let g1 = ref Greeter("Greeter")
    let g Greet ref = g1
    print_line(g.greet())

    // Different concrete type through same trait interface
    let g3 = ref Greeter2("Greeter2")
    let g2 Greet ref = g3
    print_line(g2.greet())

    // Scenario 3: Generic type as trait object
    let w = ref [String]Wrapper("test", "GenericGreeter")
    let w2 Greet ref = w
    print_line(w2.greet())

    // Scenario 4: Generic trait as trait object
    let c = ref IntToString(42)
    let c2 [String]Converter ref = c
    print_line(c2.convert())

    0
}
