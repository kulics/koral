// EXPECT: open_write_read_ok
// EXPECT: seek_ok
// EXPECT: append_mode_ok
// EXPECT: file_info_ok
// EXPECT: file_path_ok

using std.os.*
using std.io.*

let main() Void = {
    let test_dir = temp_dir().join("os_file_test")
    when remove_dir_all(test_dir) is {
        .Ok(_) then {},
        .Error(_) then {},
    }
    create_dir_all(test_dir).unwrap()

    // ========================================================================
    // Test 1: Open file for writing, then read back
    // ========================================================================
    let write_path = test_dir.join("write_test.txt")
    let wf = open_file(write_path, OpenMode.Write()).unwrap()
    let wbuf = "hello file".to_bytes()
    wf.write(wbuf, ....).unwrap()
    // wf goes out of scope, fd closed via drop

    let rf = open_file(write_path, OpenMode.Read()).unwrap()
    let mut rbuf = make_bytes(64)
    let n = rf.read(ref rbuf, ....).unwrap()
    assert(n == 10, "read count")
    let content = String.from_utf8_ptr(rbuf.borrow_ptr(), n)
    assert(content == "hello file", "read content")

    println("open_write_read_ok")

    // ========================================================================
    // Test 2: Seek operations
    // ========================================================================
    let sf = open_file(write_path, OpenMode.Read()).unwrap()
    // Seek to offset 6 from start
    let pos = sf.seek(SeekPos.Start(6)).unwrap()
    assert(pos == (UInt64)6, "seek start pos")

    let mut sbuf = make_bytes(64)
    let sn = sf.read(ref sbuf, ....).unwrap()
    let tail = String.from_utf8_ptr(sbuf.borrow_ptr(), sn)
    assert(tail == "file", "seek read tail")

    // Seek back to beginning
    sf.seek(SeekPos.Start(0)).unwrap()
    let mut sbuf2 = make_bytes(64)
    let sn2 = sf.read(ref sbuf2, ....).unwrap()
    assert(String.from_utf8_ptr(sbuf2.borrow_ptr(), sn2) == "hello file", "seek rewind")

    println("seek_ok")

    // ========================================================================
    // Test 3: Append mode
    // ========================================================================
    let append_path = test_dir.join("append_test.txt")
    write_text_file(append_path, "first").unwrap()

    let af = open_file(append_path, OpenMode.Append()).unwrap()
    let abuf = "_second".to_bytes()
    af.write(abuf, ....).unwrap()

    let appended = read_text_file(append_path).unwrap()
    assert(appended == "first_second", "append content")

    println("append_mode_ok")

    // ========================================================================
    // Test 4: File.info() via fd
    // ========================================================================
    let info_path = test_dir.join("info_test.txt")
    write_text_file(info_path, "12345").unwrap()
    let inf = open_file(info_path, OpenMode.Read()).unwrap()
    let fi = inf.info().unwrap()
    assert(fi.file_size() == (UInt64)5, "file info size")
    assert(fi.is_file(), "file info is_file")
    assert(not fi.is_dir(), "file info not is_dir")

    println("file_info_ok")

    // ========================================================================
    // Test 5: File.path() returns the path used to open
    // ========================================================================
    let pf = open_file(info_path, OpenMode.Read()).unwrap()
    let fp = pf.path()
    assert(fp.to_string().contains("info_test.txt"), "file path contains name")

    println("file_path_ok")

    // Cleanup
    when remove_dir_all(test_dir) is {
        .Ok(_) then {},
        .Error(_) then {},
    }
}
