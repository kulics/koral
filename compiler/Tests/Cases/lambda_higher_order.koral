// Lambda higher-order functions test
// EXPECT: 42

// Helper functions moved to global scope (local functions not supported)
let apply(f [Int, Int]Func, x Int) Int = f(x)

let make_adder(n Int) [Int, Int]Func = (x Int) -> x + n

let compose(f [Int, Int]Func, g [Int, Int]Func) [Int, Int]Func = {
    yield (x Int) -> f(g(x))
}

let twice(f [Int, Int]Func) [Int, Int]Func = (x Int) -> f(f(x))

let identity(f [Int, Int]Func) [Int, Int]Func = f

let choose(cond Bool, f [Int, Int]Func, g [Int, Int]Func) [Int, Int]Func = {
    yield if cond then f else g
}

let ops(f [Int, Int]Func, g [Int, Int]Func) [Int, Int]Func = compose(f, g)

let main() Int = {
    // Test 1: Function as parameter
    let doubler [Int, Int]Func = (x Int) -> x * 2
    let r1 = apply(doubler, 21)  // 21 * 2 = 42
    println(r1)
    
    // Test 2: Function as return value
    let add10 = make_adder(10)
    let r2 = add10(32)  // 32 + 10 = 42
    println(r2)
    
    // Test 3: Function composition
    let add1 [Int, Int]Func = (x Int) -> x + 1
    let times2 [Int, Int]Func = (x Int) -> x * 2
    let add1_then_times2 = compose(times2, add1)
    let r3 = add1_then_times2(20)  // (20 + 1) * 2 = 42
    println(r3)
    
    // Test 4: Apply twice
    let add5 [Int, Int]Func = (x Int) -> x + 5
    let add10_v2 = twice(add5)
    let r4 = add10_v2(32)  // 32 + 5 + 5 = 42
    println(r4)
    
    // Test 5: Identity function
    let r5 = identity(doubler)(21)  // 21 * 2 = 42
    println(r5)
    
    // Test 6: Conditional function selection
    let selected = choose(true, doubler, add1)
    let r6 = selected(21)  // 21 * 2 = 42
    println(r6)
    
    // Test 7: Function stored in variable and passed around
    let combined = ops(times2, add1)
    let r7 = combined(20)  // (20 + 1) * 2 = 42
    println(r7)
    
    yield r1
}
