// Full API test for std.random module
// Tests: next, next_int_in, next_uint_in, shuffle, choose, ref state sharing

// EXPECT: All random API tests passed

using std.random.*

let main() Void = {
    // =========================================================================
    // 1. Basic construction and next()
    // =========================================================================
    let rng = DefaultRandomSource.from_seed(42, 43, 44, 45)
    let r = [DefaultRandomSource]Random.new(rng)

    // next[Bool] should return a Bool (just verify it doesn't crash)
    let b Bool = r.[Bool]next()
    // next[Int] should return an Int
    let i Int = r.next()
    // next[UInt] should return a UInt
    let u UInt = r.next()
    // next[Float64] should be in [0.0, 1.0)
    let f = r.[Float64]next()
    assert(f >= 0.0 and f < 1.0, "Float64 in [0, 1)")
    // next[Float32] should be in [0.0, 1.0)
    let f32 = r.[Float32]next()
    assert((Float64)f32 >= 0.0 and (Float64)f32 < 1.0, "Float32 in [0, 1)")

    // Direct static Randomizable call syntax on concrete types
    // - explicit method type arg on static call target
    // - method type arg inferred from return type on static call target
    let direct_bool Bool = Bool.[DefaultRandomSource]random(rng)
    let direct_int Int = Int.random(rng)

    // =========================================================================
    // 2. next_int_in — various range variants
    // =========================================================================
    let rng2 = DefaultRandomSource.from_seed(10, 20, 30, 40)
    let r2 = Random.new(rng2)

    // ClosedRange
    let mut count = 0
    while count < 20 then {
        let v = r2.next_int_in(1..10)
        assert(v >= 1 and v <= 10, "ClosedRange [1,10]")
        count = count + 1
    }

    // ClosedOpenRange
    count = 0
    while count < 20 then {
        let v = r2.next_int_in(0..<100)
        assert(v >= 0 and v < 100, "ClosedOpenRange [0,100)")
        count = count + 1
    }

    // OpenClosedRange
    count = 0
    while count < 20 then {
        let v = r2.next_int_in(0<..10)
        assert(v > 0 and v <= 10, "OpenClosedRange (0,10]")
        count = count + 1
    }

    // OpenRange
    count = 0
    while count < 20 then {
        let v = r2.next_int_in(0<..<10)
        assert(v > 0 and v < 10, "OpenRange (0,10)")
        count = count + 1
    }

    // Single-element range
    let single = r2.next_int_in(42..42)
    assert(single == 42, "single element range")

    // Negative range
    count = 0
    while count < 20 then {
        let v = r2.next_int_in(-10..10)
        assert(v >= -10 and v <= 10, "negative range [-10,10]")
        count = count + 1
    }

    // =========================================================================
    // 3. next_uint_in — various range variants
    // =========================================================================
    let rng3 = DefaultRandomSource.from_seed(100, 200, 300, 400)
    let r3 = [DefaultRandomSource]Random.new(rng3)

    count = 0
    while count < 20 then {
        let v = r3.next_uint_in(5..15)
        assert(v >= 5 and v <= 15, "UInt ClosedRange [5,15]")
        count = count + 1
    }

    count = 0
    while count < 20 then {
        let v = r3.next_uint_in(0..<50)
        assert(v < 50, "UInt ClosedOpenRange [0,50)")
        count = count + 1
    }

    // Single-element UInt range
    let usingle = r3.next_uint_in(7..7)
    assert(usingle == 7, "UInt single element range")

    // =========================================================================
    // 4. shuffle — Fisher-Yates
    // =========================================================================
    let rng4 = DefaultRandomSource.from_seed(7, 8, 9, 10)
    let r4 = [DefaultRandomSource]Random.new(rng4)

    // Shuffle a list and verify all elements are preserved
    let mut list = [Int]List.new()
    list.push(1)
    list.push(2)
    list.push(3)
    list.push(4)
    list.push(5)

    r4.shuffle(ref list)

    // All original elements must still be present (check sum and count)
    assert(list.count() == 5, "shuffle preserves count")
    let mut sum = 0
    let mut idx UInt = 0
    while idx < list.count() then {
        sum = sum + list.at(idx)
        idx = idx + 1
    }
    assert(sum == 15, "shuffle preserves elements (sum)")

    // Shuffle empty list — should not panic
    let mut empty = [Int]List.new()
    r4.shuffle(ref empty)
    assert(empty.count() == 0, "shuffle empty list")

    // Shuffle single-element list
    let mut single_list = [Int]List.new()
    single_list.push(42)
    r4.shuffle(ref single_list)
    assert(single_list.count() == 1, "shuffle single count")
    assert(single_list.at(0) == 42, "shuffle single value")

    // =========================================================================
    // 5. choose — random element selection
    // =========================================================================
    let rng5 = DefaultRandomSource.from_seed(11, 12, 13, 14)
    let r5 = [DefaultRandomSource]Random.new(rng5)

    let mut items = [Int]List.new()
    items.push(10)
    items.push(20)
    items.push(30)

    count = 0
    while count < 20 then {
        when r5.choose(items) in {
            .Some(v) then {
                assert(v == 10 or v == 20 or v == 30, "choose returns valid element")
            },
            .None then {
                assert(false, "choose on non-empty should not be None")
            },
        }
        count = count + 1
    }

    // choose on empty list returns None
    let empty_items = [Int]List.new()
    when r5.choose(empty_items) in {
        .Some(_) then assert(false, "choose on empty should be None"),
        .None then {},
    }

    // =========================================================================
    // 6. Ref state sharing — copying DefaultRandomSource shares state
    // =========================================================================
    let src_a = DefaultRandomSource.from_seed(99, 98, 97, 96)
    let src_b = src_a  // copy by value — should share state via internal ref

    // a.generate() advances the shared state
    let v1 = src_a.generate()
    // b.generate() should return the NEXT value, not the same as v1
    let v2 = src_b.generate()
    assert(v1 <> v2, "ref sharing: a and b advance same state")

    // Further: create a third copy and verify all three share state
    let src_c = src_b
    let v3 = src_c.generate()
    let v4 = src_a.generate()
    // v3 and v4 should be consecutive values from the same sequence
    assert(v3 <> v4, "ref sharing: three copies share state")

    // =========================================================================
    // 7. Reproducibility — same seed produces same sequence
    // =========================================================================
    let rng_a = DefaultRandomSource.from_seed(1, 2, 3, 4)
    let rng_b = DefaultRandomSource.from_seed(1, 2, 3, 4)

    let ra1 = rng_a.generate()
    let rb1 = rng_b.generate()
    assert(ra1 == rb1, "reproducibility: first value")

    let ra2 = rng_a.generate()
    let rb2 = rng_b.generate()
    assert(ra2 == rb2, "reproducibility: second value")

    let ra3 = rng_a.generate()
    let rb3 = rng_b.generate()
    assert(ra3 == rb3, "reproducibility: third value")

    // =========================================================================
    // 8. default_random() — just verify it works without panic
    // =========================================================================
    let sr = default_random()
    let sv Int = sr.[Int]next()
    // Can't assert value, just verify it runs

    println("All random API tests passed")
}
