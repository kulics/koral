// EXPECT: now_ok
// EXPECT: elapsed_ok
// EXPECT: equals_ok
// EXPECT: compare_ok
// EXPECT: sub_point_ok
// EXPECT: add_vector_ok
// EXPECT: sub_vector_ok

using std.time.*

let main() Int = {
    // MonoTime.now() returns non-negative values
    let t1 = MonoTime.now()
    let t2 = MonoTime.now()
    assert(t2.compare(t1) >= 0, "monotonic")
    println("now_ok")

    // elapsed() returns non-negative Duration
    let e = t1.elapsed()
    assert(e.secs >= (Int64)0, "elapsed secs")
    assert(e.nanos >= (Int64)0, "elapsed nanos")
    println("elapsed_ok")

    // equals: same timestamp
    let epoch_a = MonoTime.now()
    assert(epoch_a.equals(epoch_a), "self equals")
    println("equals_ok")

    // compare: earlier <= later
    let a = MonoTime.now()
    let mut sum = 0
    let mut i = 0
    while i < 1000 then {
        sum = sum + i
        i = i + 1
    }
    let b = MonoTime.now()
    assert(a.compare(b) <= 0, "a <= b")
    println("compare_ok")

    // sub_point: b - a >= 0
    let diff = b.sub_point(a)
    assert(diff.secs >= (Int64)0, "sub_point secs")
    assert(diff.nanos >= (Int64)0, "sub_point nanos")
    println("sub_point_ok")

    // add_vector: t + d then sub_point gives back d
    let t = MonoTime.now()
    let d = Duration.from_milliseconds(500)
    let t_plus = t + d
    let got = t_plus - t
    assert(got.secs == d.secs, "add_vector secs")
    assert(got.nanos == d.nanos, "add_vector nanos")
    println("add_vector_ok")

    // sub_vector: (t + d) - d == t
    let t_back = t_plus - d
    assert(t_back.equals(t), "sub_vector roundtrip")
    println("sub_vector_ok")

    yield 0
}
