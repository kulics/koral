// Lambda with generics test
// EXPECT: 42

// Generic identity function that takes a function
let [T Any] apply_func(f [T, T]Func, x T) T = f(x)

// Generic map-like function
let [T Any, U Any] transform(f [T, U]Func, x T) U = f(x)

// Generic function returning function type
let [T Any] make_const(val T) [Int, T]Func = (x Int) -> val

let main() Int = {
    // Test 1: Generic function with lambda
    let doubler [Int, Int]Func = (x Int) -> x * 2
    let r1 = apply_func(doubler, 21)  // 21 * 2 = 42
    print_line(r1)
    
    // Test 2: Generic transform with different types
    let int_to_bool [Int, Bool]Func = (x Int) -> x > 40
    let r2_bool = transform(int_to_bool, 42)  // true
    let r2 = if r2_bool then 42 else 0
    print_line(r2)
    
    // Test 3: Lambda with generic instantiation
    let add1 [Int, Int]Func = (x Int) -> x + 1
    let r3 = [Int]apply_func(add1, 41)  // 41 + 1 = 42
    print_line(r3)
    
    // Test 4: Chained generic calls
    let times3 [Int, Int]Func = (x Int) -> x * 3
    let r4 = apply_func(times3, apply_func(add1, 13))  // (13 + 1) * 3 = 42
    print_line(r4)
    
    // Test 5: Generic function returning function type
    let always42 = make_const(42)
    let r5 = always42(0)  // 42
    print_line(r5)
    
    yield r1
}
