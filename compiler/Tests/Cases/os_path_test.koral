// EXPECT: is_absolute_ok
// EXPECT: join_path_ok
// EXPECT: base_name_ok
// EXPECT: dir_name_ok
// EXPECT: ext_name_ok
// EXPECT: normalize_idempotent_ok
// EXPECT: relative_path_ok
// EXPECT: glob_match_ok

using std.os.*

let main() Void = {
    // ========================================================================
    // is_absolute
    // ========================================================================
    assert(Path.new("/usr/bin").is_absolute(), "abs /usr/bin")
    assert(not Path.new("relative/path").is_absolute(), "rel relative/path")
    assert(not Path.new("").is_absolute(), "abs empty")
    assert(Path.new("\\windows").is_absolute(), "abs backslash")

    print_line("is_absolute_ok")

    // ========================================================================
    // join_path
    // ========================================================================
    // join with empty
    assert(Path.new("").join("b").to_string() == "b", "join empty base")
    assert(Path.new("a").join("").to_string() == "a", "join empty name")

    // join with absolute name returns name
    assert(Path.new("a").join("/b").to_string() == "/b", "join absolute name")

    // basic join
    let joined = Path.new("a").join("b")
    assert(joined.to_string().contains("a"), "join contains a")
    assert(joined.to_string().contains("b"), "join contains b")

    print_line("join_path_ok")

    // ========================================================================
    // base_name
    // ========================================================================
    assert(Path.new("/path/to/file.txt").base_name().unwrap() == "file.txt", "base_name file")
    assert(Path.new("file.txt").base_name().unwrap() == "file.txt", "base_name no dir")
    assert(Path.new("/single").base_name().unwrap() == "single", "base_name single")
    assert(Path.new("").base_name().is_none(), "base_name empty")

    print_line("base_name_ok")

    // ========================================================================
    // dir_name
    // ========================================================================

    assert(Path.new("/path/to/file.txt").dir_name().unwrap().to_string() == "/path/to", "dir_name nested")
    assert(Path.new("/file").dir_name().unwrap().to_string() == "/", "dir_name root")
    assert(Path.new("file.txt").dir_name().is_none(), "dir_name no dir")
    assert(Path.new("").dir_name().is_none(), "dir_name empty")

    print_line("dir_name_ok")

    // ========================================================================
    // ext_name
    // ========================================================================
    assert(Path.new("file.txt").ext_name().unwrap() == "txt", "ext_name txt")
    assert(Path.new("archive.tar.gz").ext_name().unwrap() == "gz", "ext_name double")
    assert(Path.new("noext").ext_name().is_none(), "ext_name none")
    assert(Path.new(".hidden").ext_name().is_none(), "ext_name dotfile")

    print_line("ext_name_ok")

    // ========================================================================
    // normalize_path idempotency
    // ========================================================================
    let p1 = Path.new("/a/b/c").normalize().to_string()
    let p2 = Path.new(p1).normalize().to_string()
    assert(p1 == p2, "normalize idempotent")

    print_line("normalize_idempotent_ok")

    // ========================================================================
    // relative_path
    // ========================================================================
    // Same path
    let rp_same = Path.new("/a/b").relative_to(Path.new("/a/b")).unwrap().to_string()
    assert(rp_same == ".", "relative same")

    // Child path
    let rp_child = Path.new("/a/b/c").relative_to(Path.new("/a")).unwrap().to_string()
    assert(rp_child == "b/c", "relative child")

    // Parent path
    let rp_parent = Path.new("/a").relative_to(Path.new("/a/b/c")).unwrap().to_string()
    assert(rp_parent == "../..", "relative parent")

    // Sibling path
    let rp_sibling = Path.new("/a/c").relative_to(Path.new("/a/b")).unwrap().to_string()
    assert(rp_sibling == "../c", "relative sibling")

    // Error on empty
    assert(Path.new("/a").relative_to(Path.new("")).is_error(), "relative empty from")
    assert(Path.new("").relative_to(Path.new("/a")).is_error(), "relative empty to")

    print_line("relative_path_ok")

    // ========================================================================
    // glob_match
    // ========================================================================
    // Star wildcard
    assert(glob_match("*.txt", "file.txt"), "glob star.txt")
    assert(not glob_match("*.txt", "file.rs"), "glob star.txt neg")
    assert(glob_match("*", "anything"), "glob star all")
    assert(glob_match("hello*", "hello world"), "glob star suffix")

    // Question mark
    assert(glob_match("?.txt", "a.txt"), "glob ? match")
    assert(not glob_match("?.txt", "ab.txt"), "glob ? no match")

    // Character class
    assert(glob_match("[abc].txt", "a.txt"), "glob [abc] match")
    assert(not glob_match("[abc].txt", "d.txt"), "glob [abc] no match")

    // Range in character class
    assert(glob_match("[a-z].txt", "m.txt"), "glob [a-z] match")
    assert(not glob_match("[a-z].txt", "5.txt"), "glob [a-z] no match")

    // Negated character class
    assert(glob_match("[!a].txt", "b.txt"), "glob [!a] match")
    assert(not glob_match("[!a].txt", "a.txt"), "glob [!a] no match")

    // Literal match
    assert(glob_match("exact", "exact"), "glob exact")
    assert(not glob_match("exact", "other"), "glob exact neg")

    // Empty
    assert(glob_match("", ""), "glob empty both")
    assert(not glob_match("", "x"), "glob empty pattern")

    print_line("glob_match_ok")
}
