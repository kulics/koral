// EXPECT: is_absolute_ok
// EXPECT: join_path_ok
// EXPECT: base_ok
// EXPECT: dir_ok
// EXPECT: ext_ok
// EXPECT: normalize_idempotent_ok
// EXPECT: relative_path_ok

using * in "std/os"

let main() Void = {
    // ========================================================================
    // is_absolute
    // ========================================================================
    assert(Path.new("/usr/bin").is_absolute(), "abs /usr/bin")
    assert(not Path.new("relative/path").is_absolute(), "rel relative/path")
    assert(not Path.new("").is_absolute(), "abs empty")
    assert(Path.new("\\windows").is_absolute(), "abs backslash")

    println("is_absolute_ok")

    // ========================================================================
    // join_path
    // ========================================================================
    // join with empty
    assert(Path.new("").join("b").to_string() == "b", "join empty base")
    assert(Path.new("a").join("").to_string() == "a", "join empty name")

    // join with absolute name returns name
    assert(Path.new("a").join("/b").to_string() == "/b", "join absolute name")

    // basic join
    let joined = Path.new("a").join("b")
    assert(joined.to_string().contains("a"), "join contains a")
    assert(joined.to_string().contains("b"), "join contains b")

    println("join_path_ok")

    // ========================================================================
    // base_name
    // ========================================================================
    assert(Path.new("/path/to/file.txt").base_name() == "file.txt", "base file")
    assert(Path.new("file.txt").base_name() == "file.txt", "base no dir")
    assert(Path.new("/single").base_name() == "single", "base single")
    assert(Path.new("").base_name() == ".", "base empty")

    println("base_ok")

    // ========================================================================
    // dir_name
    // ========================================================================

    assert(Path.new("/path/to/file.txt").dir_name().to_string() == "/path/to", "dir nested")
    assert(Path.new("/file").dir_name().to_string() == "/", "dir root")
    assert(Path.new("file.txt").dir_name().to_string() == ".", "dir no dir")
    assert(Path.new("").dir_name().to_string() == ".", "dir empty")

    println("dir_ok")

    // ========================================================================
    // ext_name
    // ========================================================================
    assert(Path.new("file.txt").ext_name() == ".txt", "ext txt")
    assert(Path.new("archive.tar.gz").ext_name() == ".gz", "ext double")
    assert(Path.new("noext").ext_name().is_empty(), "ext none")
    assert(Path.new(".hidden").ext_name().is_empty(), "ext dotfile")

    println("ext_ok")

    // ========================================================================
    // normalize_path idempotency
    // ========================================================================
    let p1 = Path.new("/a/b/c").normalize().to_string()
    let p2 = Path.new(p1).normalize().to_string()
    assert(p1 == p2, "normalize idempotent")

    println("normalize_idempotent_ok")

    // ========================================================================
    // relative_path
    // ========================================================================
    // Same path
    let rp_same = Path.new("/a/b").relative_to(Path.new("/a/b")).unwrap().to_string()
    assert(rp_same == ".", "relative same")

    // Child path
    let rp_child = Path.new("/a/b/c").relative_to(Path.new("/a")).unwrap().to_string()
    assert(rp_child == "b/c", "relative child")

    // Parent path
    let rp_parent = Path.new("/a").relative_to(Path.new("/a/b/c")).unwrap().to_string()
    assert(rp_parent == "../..", "relative parent")

    // Sibling path
    let rp_sibling = Path.new("/a/c").relative_to(Path.new("/a/b")).unwrap().to_string()
    assert(rp_sibling == "../c", "relative sibling")

    // Error on empty
    assert(Path.new("/a").relative_to(Path.new("")).is_error(), "relative empty from")
    assert(Path.new("").relative_to(Path.new("/a")).is_error(), "relative empty to")

    println("relative_path_ok")

}
