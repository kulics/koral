// Test basic Rune type functionality
// EXPECT: All Rune basic tests passed!

let main() Int = {
    // Test 1: Rune construction and value extraction
    let r1 = Rune.from_uint32((UInt32)65)  // 'A'
    assert(r1.to_uint32() == (UInt32)65, "Rune value should be 65")
    
    // Test 2: Rune equality
    let r2 = Rune((UInt32)65)
    assert(r1 == r2, "Runes with same value should be equal")
    
    let r3 = Rune((UInt32)66)  // 'B'
    assert(r1 <> r3, "Runes with different values should not be equal")
    
    // Test 3: Rune comparison
    assert(r1 < r3, "A should be less than B")
    assert(r3 > r1, "B should be greater than A")
    
    // Test 4: is_valid
    let valid_rune = Rune((UInt32)20013)  // Chinese character 'ä¸­' (0x4E2D)
    assert(valid_rune.is_valid(), "Valid Unicode code point should be valid")
    
    let invalid_rune = Rune((UInt32)55296)  // Surrogate (0xD800)
    assert(not invalid_rune.is_valid(), "Surrogate should be invalid")
    
    let too_large = Rune((UInt32)1114112)  // Beyond Unicode range (0x110000)
    assert(not too_large.is_valid(), "Code point beyond 0x10FFFF should be invalid")
    
    // Test 5: byte_count
    let ascii = Rune((UInt32)65)  // 'A'
    assert(ascii.byte_count() == 1, "ASCII should be 1 byte")
    
    let latin = Rune((UInt32)233)  // 'Ã©' (0x00E9)
    assert(latin.byte_count() == 2, "Latin extended should be 2 bytes")
    
    let cjk = Rune((UInt32)20013)  // 'ä¸­' (0x4E2D)
    assert(cjk.byte_count() == 3, "CJK should be 3 bytes")
    
    let emoji = Rune((UInt32)128512)  // ðŸ˜€ (0x1F600)
    assert(emoji.byte_count() == 4, "Emoji should be 4 bytes")
    
    // Test 6: to_string
    let a_str = Rune((UInt32)65).to_string()
    assert(a_str == "A", "Rune 'A' to_string should be 'A'")
    assert(a_str.count() == 1, "ASCII string should be 1 byte")
    
    // Test 7: is_ascii
    assert(Rune((UInt32)65).is_ascii(), "ASCII char should be ASCII")
    assert(not Rune((UInt32)20013).is_ascii(), "CJK char should not be ASCII")
    
    // Test 8: is_ascii_digit
    assert(Rune((UInt32)48).is_ascii_digit(), "'0' should be digit")
    assert(Rune((UInt32)57).is_ascii_digit(), "'9' should be digit")
    assert(not Rune((UInt32)65).is_ascii_digit(), "'A' should not be digit")
    
    // Test 9: is_ascii_whitespace
    assert(Rune((UInt32)32).is_ascii_whitespace(), "Space should be whitespace")
    assert(Rune((UInt32)10).is_ascii_whitespace(), "LF should be whitespace")
    assert(not Rune((UInt32)65).is_ascii_whitespace(), "'A' should not be whitespace")
    
    // Test 10: is_letter
    assert(Rune((UInt32)65).is_letter(), "'A' should be letter")
    assert(Rune((UInt32)97).is_letter(), "'a' should be letter")
    assert(Rune((UInt32)20013).is_letter(), "CJK char should be letter")
    assert(not Rune((UInt32)48).is_letter(), "'0' should not be letter")
    
    // Test 11: is_identifier_start
    assert(Rune((UInt32)65).is_identifier_start(), "'A' can start identifier")
    assert(Rune((UInt32)95).is_identifier_start(), "'_' can start identifier")
    assert(not Rune((UInt32)48).is_identifier_start(), "'0' cannot start identifier")
    
    // Test 12: is_identifier_continue
    assert(Rune((UInt32)65).is_identifier_continue(), "'A' can continue identifier")
    assert(Rune((UInt32)48).is_identifier_continue(), "'0' can continue identifier")
    assert(Rune((UInt32)95).is_identifier_continue(), "'_' can continue identifier")
    assert(not Rune((UInt32)32).is_identifier_continue(), "Space cannot continue identifier")
    
    // Test 13: is_newline
    assert(Rune((UInt32)10).is_newline(), "LF should be newline")
    assert(Rune((UInt32)13).is_newline(), "CR should be newline")
    assert(not Rune((UInt32)32).is_newline(), "Space should not be newline")
    
    print_line("All Rune basic tests passed!")
    0
}
