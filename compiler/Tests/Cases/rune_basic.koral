// Test basic Rune type functionality
// EXPECT: All Rune basic tests passed!

let main() Int = {
    // Test 1: Rune construction and value extraction
    let r1 = Rune.from_uint32(65u32)  // 'A'
    assert(r1.to_uint32() == 65u32, "Rune value should be 65")
    
    // Test 2: Rune equality
    let r2 = Rune(65u32)
    assert(r1 == r2, "Runes with same value should be equal")
    
    let r3 = Rune(66u32)  // 'B'
    assert(r1 <> r3, "Runes with different values should not be equal")
    
    // Test 3: Rune comparison
    assert(r1 < r3, "A should be less than B")
    assert(r3 > r1, "B should be greater than A")
    
    // Test 4: is_valid
    let valid_rune = Rune(20013u32)  // Chinese character 'ä¸­' (0x4E2D)
    assert(valid_rune.is_valid(), "Valid Unicode code point should be valid")
    
    let invalid_rune = Rune(55296u32)  // Surrogate (0xD800)
    assert(not invalid_rune.is_valid(), "Surrogate should be invalid")
    
    let too_large = Rune(1114112u32)  // Beyond Unicode range (0x110000)
    assert(not too_large.is_valid(), "Code point beyond 0x10FFFF should be invalid")
    
    // Test 5: utf8_len
    let ascii = Rune(65u32)  // 'A'
    assert(ascii.utf8_len() == 1, "ASCII should be 1 byte")
    
    let latin = Rune(233u32)  // 'Ã©' (0x00E9)
    assert(latin.utf8_len() == 2, "Latin extended should be 2 bytes")
    
    let cjk = Rune(20013u32)  // 'ä¸­' (0x4E2D)
    assert(cjk.utf8_len() == 3, "CJK should be 3 bytes")
    
    let emoji = Rune(128512u32)  // ðŸ˜€ (0x1F600)
    assert(emoji.utf8_len() == 4, "Emoji should be 4 bytes")
    
    // Test 6: to_string
    let a_str = Rune(65u32).to_string()
    assert(a_str == "A", "Rune 'A' to_string should be 'A'")
    assert(a_str.count() == 1, "ASCII string should be 1 byte")
    
    // Test 7: is_ascii
    assert(Rune(65u32).is_ascii(), "ASCII char should be ASCII")
    assert(not Rune(20013u32).is_ascii(), "CJK char should not be ASCII")
    
    // Test 8: is_ascii_digit
    assert(Rune(48u32).is_ascii_digit(), "'0' should be digit")
    assert(Rune(57u32).is_ascii_digit(), "'9' should be digit")
    assert(not Rune(65u32).is_ascii_digit(), "'A' should not be digit")
    
    // Test 9: is_ascii_whitespace
    assert(Rune(32u32).is_ascii_whitespace(), "Space should be whitespace")
    assert(Rune(10u32).is_ascii_whitespace(), "LF should be whitespace")
    assert(not Rune(65u32).is_ascii_whitespace(), "'A' should not be whitespace")
    
    // Test 10: is_letter
    assert(Rune(65u32).is_letter(), "'A' should be letter")
    assert(Rune(97u32).is_letter(), "'a' should be letter")
    assert(Rune(20013u32).is_letter(), "CJK char should be letter")
    assert(not Rune(48u32).is_letter(), "'0' should not be letter")
    
    // Test 11: is_identifier_start
    assert(Rune(65u32).is_identifier_start(), "'A' can start identifier")
    assert(Rune(95u32).is_identifier_start(), "'_' can start identifier")
    assert(not Rune(48u32).is_identifier_start(), "'0' cannot start identifier")
    
    // Test 12: is_identifier_continue
    assert(Rune(65u32).is_identifier_continue(), "'A' can continue identifier")
    assert(Rune(48u32).is_identifier_continue(), "'0' can continue identifier")
    assert(Rune(95u32).is_identifier_continue(), "'_' can continue identifier")
    assert(not Rune(32u32).is_identifier_continue(), "Space cannot continue identifier")
    
    // Test 13: is_newline
    assert(Rune(10u32).is_newline(), "LF should be newline")
    assert(Rune(13u32).is_newline(), "CR should be newline")
    assert(not Rune(32u32).is_newline(), "Space should not be newline")
    
    print_line("All Rune basic tests passed!")
    0
}
