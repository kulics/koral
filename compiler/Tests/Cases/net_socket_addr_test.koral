// EXPECT: sockaddr_new_ok
// EXPECT: sockaddr_from_ipv4_ok
// EXPECT: sockaddr_from_ipv6_ok
// EXPECT: sockaddr_from_string_ok
// EXPECT: sockaddr_from_string_invalid_ok
// EXPECT: sockaddr_to_string_ok
// EXPECT: sockaddr_equals_ok
// EXPECT: shutdown_ok

using std.net.*

let is_ok_sa(r [SocketAddr]Result) Bool = when r in { .Ok(_) then true, .Error(_) then false }
let is_err_sa(r [SocketAddr]Result) Bool = when r in { .Ok(_) then false, .Error(_) then true }

let main() Void = {
    // ========================================================================
    // SocketAddr: new + field access
    // ========================================================================
    let ip = IpAddr.V4(Ipv4Addr.new(127, 0, 0, 1))
    let sa = SocketAddr.new(ip, (UInt16)8080)
    assert(sa.port() == (UInt16)8080, "port")
    assert(sa.is_ipv4(), "is_ipv4")
    assert(not sa.is_ipv6(), "not is_ipv6")
    assert(sa.ip().is_loopback(), "ip is loopback")
    println("sockaddr_new_ok")

    // ========================================================================
    // SocketAddr: from_ipv4
    // ========================================================================
    let sa4 = SocketAddr.from_ipv4(Ipv4Addr.new(10, 0, 0, 1), (UInt16)3000)
    assert(sa4.port() == (UInt16)3000, "from_ipv4 port")
    assert(sa4.is_ipv4(), "from_ipv4 is_ipv4")
    assert(sa4.ip().to_string() == "10.0.0.1", "from_ipv4 ip")
    println("sockaddr_from_ipv4_ok")

    // ========================================================================
    // SocketAddr: from_ipv6
    // ========================================================================
    let sa6 = SocketAddr.from_ipv6(Ipv6Addr.localhost(), (UInt16)9090)
    assert(sa6.port() == (UInt16)9090, "from_ipv6 port")
    assert(sa6.is_ipv6(), "from_ipv6 is_ipv6")
    assert(not sa6.is_ipv4(), "from_ipv6 not is_ipv4")
    assert(sa6.ip().to_string() == "::1", "from_ipv6 ip")
    println("sockaddr_from_ipv6_ok")

    // ========================================================================
    // SocketAddr: from_string valid inputs
    // ========================================================================
    let ps1 = SocketAddr.parse("127.0.0.1:8080")
    when ps1 in {
        .Ok(addr) then {
            assert(addr.port() == (UInt16)8080, "parse v4 port")
            assert(addr.is_ipv4(), "parse v4 is_ipv4")
            assert(addr.ip().to_string() == "127.0.0.1", "parse v4 ip")
        },
        .Error(_) then assert(false, "from_string v4 should succeed"),
    }
    let ps2 = SocketAddr.parse("[::1]:8080")
    when ps2 in {
        .Ok(addr) then {
            assert(addr.port() == (UInt16)8080, "parse v6 port")
            assert(addr.is_ipv6(), "parse v6 is_ipv6")
            assert(addr.ip().to_string() == "::1", "parse v6 ip")
        },
        .Error(_) then assert(false, "from_string v6 should succeed"),
    }
    assert(is_ok_sa(SocketAddr.parse("0.0.0.0:0")), "parse 0.0.0.0:0")
    assert(is_ok_sa(SocketAddr.parse("255.255.255.255:65535")), "parse max")
    println("sockaddr_from_string_ok")

    // ========================================================================
    // SocketAddr: from_string invalid inputs
    // ========================================================================
    assert(is_err_sa(SocketAddr.parse("")), "empty")
    assert(is_err_sa(SocketAddr.parse("127.0.0.1")), "no port")
    assert(is_err_sa(SocketAddr.parse(":8080")), "no ip")
    assert(is_err_sa(SocketAddr.parse("127.0.0.1:99999")), "port out of range")
    assert(is_err_sa(SocketAddr.parse("[::1]")), "v6 no port")
    assert(is_err_sa(SocketAddr.parse("[::1]:")), "v6 empty port")
    assert(is_err_sa(SocketAddr.parse("127.0.0.1:08080")), "leading zero port")
    println("sockaddr_from_string_invalid_ok")

    // ========================================================================
    // SocketAddr: to_string + roundtrip
    // ========================================================================
    let ts1 = SocketAddr.from_ipv4(Ipv4Addr.new(192, 168, 1, 1), (UInt16)443)
    assert(ts1.to_string() == "192.168.1.1:443", "v4 to_string")
    let ts1_back = SocketAddr.parse(ts1.to_string()).unwrap()
    assert(ts1.equals(ts1_back), "v4 roundtrip")

    let ts2 = SocketAddr.from_ipv6(Ipv6Addr.localhost(), (UInt16)80)
    assert(ts2.to_string() == "[::1]:80", "v6 to_string")
    let ts2_back = SocketAddr.parse(ts2.to_string()).unwrap()
    assert(ts2.equals(ts2_back), "v6 roundtrip")
    println("sockaddr_to_string_ok")

    // ========================================================================
    // SocketAddr: equals
    // ========================================================================
    let e1 = SocketAddr.from_ipv4(Ipv4Addr.new(1, 2, 3, 4), (UInt16)80)
    let e2 = SocketAddr.from_ipv4(Ipv4Addr.new(1, 2, 3, 4), (UInt16)80)
    let e3 = SocketAddr.from_ipv4(Ipv4Addr.new(1, 2, 3, 4), (UInt16)81)
    assert(e1.equals(e2), "equal")
    assert(not e1.equals(e3), "not equal different port")
    println("sockaddr_equals_ok")

    // ========================================================================
    // Shutdown: enum variants exist
    // ========================================================================
    let s1 = Shutdown.Read()
    let s2 = Shutdown.Write()
    let s3 = Shutdown.Both()
    when s1 in {
        .Read then {},
        .Write then assert(false, "should be Read"),
        .Both then assert(false, "should be Read"),
    }
    when s2 in {
        .Read then assert(false, "should be Write"),
        .Write then {},
        .Both then assert(false, "should be Write"),
    }
    when s3 in {
        .Read then assert(false, "should be Both"),
        .Write then assert(false, "should be Both"),
        .Both then {},
    }
    println("shutdown_ok")
}
