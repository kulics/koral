// Test String Rune methods
// EXPECT: All String Rune tests passed!

let main() Int = {
    // Test 1: runes() iterator on ASCII string
    let ascii_str = "Hello"
    let mut iter = ascii_str.runes().iterator()
    let mut count = 0
    while iter.next() is .Some(r) then {
        count = count + 1
    }
    assert(count == 5, "ASCII string should have 5 runes")
    
    // Test 2: count_rune() on ASCII string
    assert(ascii_str.count_rune() == 5, "count_rune should return 5 for 'Hello'")
    
    // Test 3: get_rune() on ASCII string
    when ascii_str.get_rune(0) is {
        .Some(r) then assert(r.to_uint32() == 72u32, "First rune should be 'H' (72)"),
        .None then assert(false, "get_rune(0) should return Some"),
    }
    when ascii_str.get_rune(4) is {
        .Some(r) then assert(r.to_uint32() == 111u32, "Last rune should be 'o' (111)"),
        .None then assert(false, "get_rune(4) should return Some"),
    }
    when ascii_str.get_rune(5) is {
        .Some(_) then assert(false, "get_rune(5) should return None"),
        .None then {},
    }
    when ascii_str.get_rune(0 - 1) is {
        .Some(_) then assert(false, "get_rune(-1) should return None"),
        .None then {},
    }
    
    // Test 4: push_rune() with ASCII
    let mut s1 = String.empty()
    s1.push_rune(Rune(65u32))  // 'A'
    s1.push_rune(Rune(66u32))  // 'B'
    s1.push_rune(Rune(67u32))  // 'C'
    assert(s1 == "ABC", "push_rune should build 'ABC'")
    assert(s1.count() == 3, "ABC should be 3 bytes")
    
    // Test 5: push_rune() with multi-byte characters
    let mut s2 = String.empty()
    s2.push_rune(Rune(233u32))  // 'Ã©' (2 bytes)
    assert(s2.count() == 2, "Ã© should be 2 bytes")
    assert(s2.count_rune() == 1, "Ã© should be 1 rune")
    
    // Test 6: push_rune() with CJK character
    let mut s3 = String.empty()
    s3.push_rune(Rune(20013u32))  // 'ä¸­' (3 bytes)
    assert(s3.count() == 3, "ä¸­ should be 3 bytes")
    assert(s3.count_rune() == 1, "ä¸­ should be 1 rune")
    
    // Test 7: push_rune() with emoji
    let mut s4 = String.empty()
    s4.push_rune(Rune(128512u32))  // ðŸ˜€ (4 bytes)
    assert(s4.count() == 4, "ðŸ˜€ should be 4 bytes")
    assert(s4.count_rune() == 1, "ðŸ˜€ should be 1 rune")
    
    // Test 8: Rune.to_string() consistency with push_rune()
    let rune_a = Rune(65u32)
    let str_from_to_string = rune_a.to_string()
    let mut str_from_push = String.empty()
    str_from_push.push_rune(rune_a)
    assert(str_from_to_string == str_from_push, "to_string and push_rune should produce same result")
    
    // Test 9: utf8_len consistency with actual encoding
    let rune_cjk = Rune(20013u32)  // 'ä¸­'
    let str_cjk = rune_cjk.to_string()
    assert(rune_cjk.utf8_len() == str_cjk.count(), "utf8_len should match actual byte count")
    
    // Test 10: Empty string
    let empty = ""
    assert(empty.count_rune() == 0, "Empty string should have 0 runes")
    when empty.get_rune(0) is {
        .Some(_) then assert(false, "get_rune(0) on empty should return None"),
        .None then {},
    }
    
    print_line("All String Rune tests passed!")
    0
}
