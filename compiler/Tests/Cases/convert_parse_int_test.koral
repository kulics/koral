// std.convert integer parsing tests
// EXPECT: parse_ok
// EXPECT: negative_ok
// EXPECT: zero_ok
// EXPECT: trim_ok
// EXPECT: underscore_ok
// EXPECT: radix_bin_ok
// EXPECT: radix_oct_ok
// EXPECT: radix_hex_ok
// EXPECT: radix_prefix_ok
// EXPECT: error_empty_ok
// EXPECT: error_invalid_ok
// EXPECT: error_radix_ok
// EXPECT: uint_ok
// EXPECT: uint_reject_neg_ok
// EXPECT: int8_ok
// EXPECT: uint8_ok

using std.convert

let main() Int = {
    // Basic Int.parse
    when Int.parse("42") in {
        .Ok(n) then if n == 42 then println("parse_ok") else println("FAIL parse"),
        .Error(e) then println("FAIL parse: " + e.message()),
    }

    // Negative
    when Int.parse("-123") in {
        .Ok(n) then if n == (0 - 123) then println("negative_ok") else println("FAIL negative"),
        .Error(e) then println("FAIL negative: " + e.message()),
    }

    // Zero
    when Int.parse("0") in {
        .Ok(n) then if n == 0 then println("zero_ok") else println("FAIL zero"),
        .Error(e) then println("FAIL zero: " + e.message()),
    }

    // Trim whitespace
    when Int.parse("  99  ") in {
        .Ok(n) then if n == 99 then println("trim_ok") else println("FAIL trim"),
        .Error(e) then println("FAIL trim: " + e.message()),
    }

    // Underscore separator
    when Int.parse("1_000") in {
        .Ok(n) then if n == 1000 then println("underscore_ok") else println("FAIL underscore"),
        .Error(e) then println("FAIL underscore: " + e.message()),
    }

    // Radix: binary
    when Int.parse_radix("1010", 2) in {
        .Ok(n) then if n == 10 then println("radix_bin_ok") else println("FAIL radix_bin"),
        .Error(e) then println("FAIL radix_bin: " + e.message()),
    }

    // Radix: octal
    when Int.parse_radix("77", 8) in {
        .Ok(n) then if n == 63 then println("radix_oct_ok") else println("FAIL radix_oct"),
        .Error(e) then println("FAIL radix_oct: " + e.message()),
    }

    // Radix: hex
    when Int.parse_radix("ff", 16) in {
        .Ok(n) then if n == 255 then println("radix_hex_ok") else println("FAIL radix_hex"),
        .Error(e) then println("FAIL radix_hex: " + e.message()),
    }

    // Radix: hex with prefix
    when Int.parse_radix("0xFF", 16) in {
        .Ok(n) then if n == 255 then println("radix_prefix_ok") else println("FAIL radix_prefix"),
        .Error(e) then println("FAIL radix_prefix: " + e.message()),
    }

    // Error: empty string
    when Int.parse("") in {
        .Ok(n) then println("FAIL error_empty"),
        .Error(e) then println("error_empty_ok"),
    }

    // Error: invalid character
    when Int.parse("12abc") in {
        .Ok(n) then println("FAIL error_invalid"),
        .Error(e) then println("error_invalid_ok"),
    }

    // Error: invalid radix
    when Int.parse_radix("10", 1) in {
        .Ok(n) then println("FAIL error_radix"),
        .Error(e) then println("error_radix_ok"),
    }

    // UInt.parse
    when UInt.parse("255") in {
        .Ok(n) then if n == 255 then println("uint_ok") else println("FAIL uint"),
        .Error(e) then println("FAIL uint: " + e.message()),
    }

    // UInt rejects negative
    when UInt.parse("-1") in {
        .Ok(n) then println("FAIL uint_reject_neg"),
        .Error(e) then println("uint_reject_neg_ok"),
    }

    // Int8 boundary
    when Int8.parse("127") in {
        .Ok(n) then if (Int)n == 127 then println("int8_ok") else println("FAIL int8"),
        .Error(e) then println("FAIL int8: " + e.message()),
    }

    // UInt8 boundary
    when UInt8.parse("255") in {
        .Ok(n) then if (UInt)n == 255 then println("uint8_ok") else println("FAIL uint8"),
        .Error(e) then println("FAIL uint8: " + e.message()),
    }

    yield 0
}
