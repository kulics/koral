// std.convert integer parsing tests
// EXPECT: parse_ok
// EXPECT: negative_ok
// EXPECT: zero_ok
// EXPECT: trim_ok
// EXPECT: underscore_ok
// EXPECT: radix_bin_ok
// EXPECT: radix_oct_ok
// EXPECT: radix_hex_ok
// EXPECT: radix_prefix_ok
// EXPECT: error_empty_ok
// EXPECT: error_invalid_ok
// EXPECT: error_radix_ok
// EXPECT: uint_ok
// EXPECT: uint_reject_neg_ok
// EXPECT: int8_ok
// EXPECT: uint8_ok

using std.convert

let main() Int = {
    // Basic Int.parse
    when Int.parse("42") is {
        .Ok(n) then if n == 42 then print_line("parse_ok") else print_line("FAIL parse"),
        .Error(e) then print_line("FAIL parse: " + e.message()),
    }

    // Negative
    when Int.parse("-123") is {
        .Ok(n) then if n == (0 - 123) then print_line("negative_ok") else print_line("FAIL negative"),
        .Error(e) then print_line("FAIL negative: " + e.message()),
    }

    // Zero
    when Int.parse("0") is {
        .Ok(n) then if n == 0 then print_line("zero_ok") else print_line("FAIL zero"),
        .Error(e) then print_line("FAIL zero: " + e.message()),
    }

    // Trim whitespace
    when Int.parse("  99  ") is {
        .Ok(n) then if n == 99 then print_line("trim_ok") else print_line("FAIL trim"),
        .Error(e) then print_line("FAIL trim: " + e.message()),
    }

    // Underscore separator
    when Int.parse("1_000") is {
        .Ok(n) then if n == 1000 then print_line("underscore_ok") else print_line("FAIL underscore"),
        .Error(e) then print_line("FAIL underscore: " + e.message()),
    }

    // Radix: binary
    when Int.parse_radix("1010", 2) is {
        .Ok(n) then if n == 10 then print_line("radix_bin_ok") else print_line("FAIL radix_bin"),
        .Error(e) then print_line("FAIL radix_bin: " + e.message()),
    }

    // Radix: octal
    when Int.parse_radix("77", 8) is {
        .Ok(n) then if n == 63 then print_line("radix_oct_ok") else print_line("FAIL radix_oct"),
        .Error(e) then print_line("FAIL radix_oct: " + e.message()),
    }

    // Radix: hex
    when Int.parse_radix("ff", 16) is {
        .Ok(n) then if n == 255 then print_line("radix_hex_ok") else print_line("FAIL radix_hex"),
        .Error(e) then print_line("FAIL radix_hex: " + e.message()),
    }

    // Radix: hex with prefix
    when Int.parse_radix("0xFF", 16) is {
        .Ok(n) then if n == 255 then print_line("radix_prefix_ok") else print_line("FAIL radix_prefix"),
        .Error(e) then print_line("FAIL radix_prefix: " + e.message()),
    }

    // Error: empty string
    when Int.parse("") is {
        .Ok(n) then print_line("FAIL error_empty"),
        .Error(e) then print_line("error_empty_ok"),
    }

    // Error: invalid character
    when Int.parse("12abc") is {
        .Ok(n) then print_line("FAIL error_invalid"),
        .Error(e) then print_line("error_invalid_ok"),
    }

    // Error: invalid radix
    when Int.parse_radix("10", 1) is {
        .Ok(n) then print_line("FAIL error_radix"),
        .Error(e) then print_line("error_radix_ok"),
    }

    // UInt.parse
    when UInt.parse("255") is {
        .Ok(n) then if n == 255 then print_line("uint_ok") else print_line("FAIL uint"),
        .Error(e) then print_line("FAIL uint: " + e.message()),
    }

    // UInt rejects negative
    when UInt.parse("-1") is {
        .Ok(n) then print_line("FAIL uint_reject_neg"),
        .Error(e) then print_line("uint_reject_neg_ok"),
    }

    // Int8 boundary
    when Int8.parse("127") is {
        .Ok(n) then if (Int)n == 127 then print_line("int8_ok") else print_line("FAIL int8"),
        .Error(e) then print_line("FAIL int8: " + e.message()),
    }

    // UInt8 boundary
    when UInt8.parse("255") is {
        .Ok(n) then if (UInt)n == 255 then print_line("uint8_ok") else print_line("FAIL uint8"),
        .Error(e) then print_line("FAIL uint8: " + e.message()),
    }

    yield 0
}
