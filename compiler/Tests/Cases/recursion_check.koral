// EXPECT: Function: 
// EXPECT: 120
// EXPECT: Struct: 
// EXPECT: 10
// EXPECT: Union: 
// EXPECT: 20
// EXPECT: Generic Function: 
// EXPECT: 24
// EXPECT: Generic Struct: 
// EXPECT: 1
// EXPECT: Generic Union: 
// EXPECT: 1

// 1. Function Recursion
let factorial(n Int) Int = {
    yield if n <= 1 then 1 else n * factorial(n - 1)
}

// 2. Struct Recursion (Indirect via Option of Ref)
// Struct uses parenthesis syntax
type Node(
    val Int,
    // Uses Option to break cycle but relies on Node being defined (recursive reference)
    // Using [Node ref]Option because [Node]Option (value) would be infinite size.
    next [Node ref]Option
)

let sum_node(n Node ref) Int = {
    yield n.val + { yield when n.next is {
        .Some(next_node_ref) then sum_node(next_node_ref),
        .None then 0,
    } }
}

// 3. Union Recursion (Direct)
type IntList {
    Cons(head Int, tail IntList ref),
    Nil(),
}

let sum_list(l IntList) Int = {
    yield when l is {
        .Cons(h, t) then h + sum_list(deref t),
        .Nil then 0,
    }
}

// 4. Generic Function Recursion
let [T Any]generic_fact(n Int, val T) T = {
    // Recursive call without [T] prefix (inference)
    yield if n <= 0 then val else generic_fact(n - 1, val)
}
let [T Any]generic_identity(val T) T = val

// 5. Generic Struct Recursion
type [T Any]GenNode(
    val T,
    next [[T]GenNode ref]Option
)

let [T Any]count_gen_node(n [T]GenNode ref) Int = {
    yield 1 + { yield when n.next is {
        .Some(next_ref) then [T]count_gen_node(next_ref),
        .None then 0,
    } }
}

let identity(x Int) Int = x

// 6. Generic Union Recursion
type [T Any]GenList {
    Cons(head T, tail [T]GenList ref),
    Nil(),
}

let [T Deref]count_gen_list(l [T]GenList) Int = {
    yield when l is {
        .Cons(h, t) then 1 + [T]count_gen_list(deref t),
        .Nil then 0,
    }
}

let main() Int = {
    // 1
    println("Function: ")
    println(factorial(5))
    println("\n")

    // 2
    // Create Node(10, None)
    let n2 = Node(10, [Node ref]Option.None())
    let n2_ref = ref n2
    println("Struct: ")
    println(sum_node(n2_ref))
    println("\n")

    // 3
    let nil_l3 = IntList.Nil()
    let l3 = IntList.Cons(20, ref nil_l3)
    println("Union: ")
    println(sum_list(l3))
    println("\n")

    // 4
    println("Generic Function: ")
    // returns 24
    println(generic_identity(24))
    println("\n")

    // 5
    let gn5 = [Int]GenNode(30, [[Int]GenNode ref]Option.None())
    let gn5_ref = ref gn5
    println("Generic Struct: ")
    println([Int]count_gen_node(gn5_ref))
    println("\n")

    // 6
    let nil_gl6 = [Int]GenList.Nil()
    let gl6 = [Int]GenList.Cons(40, ref nil_gl6)
    println("Generic Union: ")
    println([Int]count_gen_list(gl6))
    println("\n")

    yield 0
}
