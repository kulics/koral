// EXPECT: Status.describe called
// EXPECT: Status dropped
// EXPECT: --- Scope 1 ---
// EXPECT: Status dropped
// EXPECT: --- Scope 1 End ---
// EXPECT: Box.is_empty called
// EXPECT: Box dropped
// EXPECT: --- Scope 2 ---
// EXPECT: Box dropped
// EXPECT: --- Scope 2 End ---
// EXPECT: Box dropped
// EXPECT: Status dropped

type Status {
    Active(),
    Inactive(val Int),
}

given Status {
    describe(self) Int = {
        println("Status.describe called")
        yield 0
    }
    
    __drop(self ref) Void = {
        println("Status dropped")
    }
}

type [T Any]Box {
    Full(val T),
    Empty(),
}

given [T Any] [T]Box {
    is_empty(self) Bool = {
        println("Box.is_empty called")
        yield true
    }
    // Drop for generic union is handled by template instantiation?
    // Let's add one to check.
    __drop(self ref) Void = {
        println("Box dropped")
    }
}

let main() Int = {
    let s = Status.Active()
    s.describe()
    
    println("--- Scope 1 ---")
    {
        let s2 = Status.Inactive(10)
        // s2 drops here -> "Status dropped"
    }
    println("--- Scope 1 End ---")
    
    let b = [Int]Box.Full(42)
    b.is_empty()
    
    println("--- Scope 2 ---")
    {
        let b2 = [Int]Box.Empty()
        // b2 drops here -> "Box dropped"
    }
    println("--- Scope 2 End ---")
    
    // s and b drop here at end of main
    yield 0
}
