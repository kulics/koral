// Lambda parsing test
// EXPECT: 42

let main() Int = {
    // Test 3.3: Full type annotation form (x Int, y Int) Int -> expr
    let f1 [Int, Int, Int]Func = (x Int, y Int) Int -> x + y
    
    // Test 3.4: Type inference form (x, y) -> expr
    let f2 [Int, Int, Int]Func = (x, y) -> x + y
    
    // Test 3.5: No params form () -> expr
    let f3 [Int]Func = () -> 42
    
    // Test 3.6: Block body (x) -> { ... }
    let f4 [Int, Int]Func = (x Int) -> {
        let y = x * 2
        yield y + 1
    }
    
    // Test single param with type
    let f5 [Int, Int]Func = (x Int) -> x * 2
    
    // Test single param with type inference
    let f6 [Int, Int]Func = (x) -> x * 2
    
    // Test closure calls
    let r1 = f1(20, 22)      // 20 + 22 = 42
    let r2 = f2(40, 2)       // 40 + 2 = 42
    let r3 = f3()            // 42
    let r4 = f4(20)          // 20 * 2 + 1 = 41
    let r5 = f5(21)          // 21 * 2 = 42
    let r6 = f6(21)          // 21 * 2 = 42
    
    // Verify results
    println(r1)           // 42
    println(r2)           // 42
    println(r3)           // 42
    println(r4)           // 41
    println(r5)           // 42
    println(r6)           // 42
    
    yield r3
}
