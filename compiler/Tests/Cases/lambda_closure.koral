// Lambda closure test - tests closures that capture variables
// EXPECT: 42

// Helper function for Test 3
let make_adder(base Int) Int = {
    let adder [Int, Int]Func = (y) -> base + y
    adder(2)
}

// Helper function for Test 6
let make_multiplier(factor Int) [Int, Int]Func = {
    (x Int) -> x * factor
}

let main() Int = {
    // Test 1: Closure capturing a local variable
    let x = 10
    let add_x [Int, Int]Func = (y) -> x + y
    let r1 = add_x(32)  // 10 + 32 = 42
    print_line(r1)
    
    // Test 2: Closure capturing multiple variables
    let a = 20
    let b = 22
    let add_ab [Int]Func = () -> a + b
    let r2 = add_ab()  // 20 + 22 = 42
    print_line(r2)
    
    // Test 3: Closure capturing a function parameter
    let r3 = make_adder(40)  // 40 + 2 = 42
    print_line(r3)
    
    // Test 4: Nested closures with multi-level capture
    let outer = 10
    let f [Int]Func = () -> {
        let inner = 32
        let g [Int]Func = () -> outer + inner
        g()
    }
    let r4 = f()  // 10 + 32 = 42
    print_line(r4)
    
    // Test 5: Multiple closures capturing same variable
    let shared = 21
    let double_it [Int]Func = () -> shared * 2
    let add_one [Int]Func = () -> shared + 21
    let r5a = double_it()  // 21 * 2 = 42
    let r5b = add_one()    // 21 + 21 = 42
    print_line(r5a)
    print_line(r5b)
    
    // Test 6: Closure returned from function (escaping)
    let times2 = make_multiplier(2)
    let r6 = times2(21)  // 21 * 2 = 42
    print_line(r6)
    
    r1
}
