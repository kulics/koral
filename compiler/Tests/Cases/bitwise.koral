// EXPECT: bitand:
// EXPECT: 1
// EXPECT: bitor:
// EXPECT: 3
// EXPECT: bitxor:
// EXPECT: 2
// EXPECT: bitnot:
// EXPECT: -1
// EXPECT: bitshl:
// EXPECT: 4
// EXPECT: bitshr:
// EXPECT: 2
// EXPECT: precedence_add_shl:
// EXPECT: 8
// EXPECT: precedence_shl_and:
// EXPECT: 2
// EXPECT: precedence_and_or:
// EXPECT: 4
// EXPECT: count_ok
// EXPECT: leading_trailing_ok
// EXPECT: rotate_ok
// EXPECT: reverse_swap_ok
// EXPECT: power_of_two_ok
// EXPECT: int_bitops_ok
// EXPECT: small_types_ok

let main() Int = {
    print_line("bitand:")
    print_line(3 & 1)
    
    print_line("bitor:")
    print_line(1 | 2)
    
    print_line("bitxor:")
    print_line(3 ^ 1)
    
    print_line("bitnot:")
    print_line(~0)
    
    print_line("bitshl:")
    print_line(1 << 2)
    
    print_line("bitshr:")
    print_line(4 >> 1)
    
    print_line("precedence_add_shl:")
    print_line(1 << 2 + 1)// 1 << 3 = 8
    
    print_line("precedence_shl_and:")
    print_line(2 & 1 << 1)// 2 & (1 << 1) -> 2 & 2 -> 2
    
    print_line("precedence_and_or:")
    print_line(4 | 2 & 1)// 4 | (2 & 1) -> 4 | 0 -> 4

    // --- UInt bit operation tests ---
    let u UInt = 0b1010110
    // count_ones: 1+0+1+0+1+1+0 = 4
    // count_zeros: 64 - 4 = 60
    if u.count_ones() == 4 and u.count_zeros() == 60 then {
        print_line("count_ok")
    }

    let zero UInt = 0
    let one UInt = 1
    let high UInt = (UInt)1 << 63
    // leading_zeros(0) = 64, trailing_zeros(0) = 64
    // leading_zeros(1) = 63, trailing_zeros(1) = 0
    // leading_zeros(1<<63) = 0, trailing_zeros(1<<63) = 63
    if zero.leading_zeros() == 64 and zero.trailing_zeros() == 64 and one.leading_zeros() == 63 and one.trailing_zeros() == 0 and high.leading_zeros() == 0 and high.trailing_zeros() == 63 then {
        print_line("leading_trailing_ok")
    }

    // rotate_left / rotate_right
    let val UInt = 1
    let rotl = val.rotate_left(3)  // 8
    let rotr = rotl.rotate_right(3) // 1
    if rotl == 8 and rotr == 1 then {
        print_line("rotate_ok")
    }

    // swap_bytes: 0x0102030405060708 -> 0x0807060504030201
    let sw UInt = 0x0102030405060708
    let swapped = sw.swap_bytes()
    if swapped == 0x0807060504030201 then {
        print_line("reverse_swap_ok")
    }

    // is_power_of_two / next_power_of_two
    let p1 UInt = 1
    let p2 UInt = 16
    let p3 UInt = 15
    let p4 UInt = 0
    if p1.is_power_of_two() and p2.is_power_of_two() and not p3.is_power_of_two() and not p4.is_power_of_two() and p3.next_power_of_two() == 16 and p4.next_power_of_two() == 1 then {
        print_line("power_of_two_ok")
    }

    // --- Int (signed) bit operations ---
    let si = 0b1010110
    // count_ones same as unsigned
    let si_lz = (1).leading_zeros()  // 63
    let si_tz = (4).trailing_zeros() // 2
    if si.count_ones() == 4 and si_lz == 63 and si_tz == 2 then {
        print_line("int_bitops_ok")
    }

    // --- Smaller types ---
    let u32 UInt32 = 0xFF
    let u8 UInt8 = 0b10101010
    if u32.count_ones() == 8 and u32.leading_zeros() == 24 and u8.count_ones() == 4 and u8.leading_zeros() == 0 and u8.trailing_zeros() == 1 then {
        print_line("small_types_ok")
    }

    yield 0
}
