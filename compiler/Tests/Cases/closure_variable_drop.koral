// Test drop of closure variables when they go out of scope
// EXPECT: Creating Resource 1
// EXPECT: Closure variable created
// EXPECT: Calling closure
// EXPECT: Result: 1
// EXPECT: Drop Resource 1
// EXPECT: Creating Resource 2
// EXPECT: Passing closure as argument
// EXPECT: Inside function, calling closure
// EXPECT: Result: 2
// EXPECT: Drop Resource 2
// EXPECT: All closure variable drop tests passed

type Resource(id Int)

given Resource {
    __drop(self ref) Void = {
        print("Drop Resource ")
        println(self.id)
    }
}

let call_closure(f [Int]Func) Void = {
    println("Inside function, calling closure")
    let result = f()
    print("Result: ")
    println(result)
}

let test_closure_scope_exit() Void = {
    let r = Resource(1)
    println("Creating Resource 1")
    
    let closure [Int]Func = () -> r.id
    println("Closure variable created")
    
    println("Calling closure")
    let result = closure()
    print("Result: ")
    println(result)
    
    // closure goes out of scope here, should drop captured Resource
}

let test_closure_as_argument() Void = {
    let r = Resource(2)
    println("Creating Resource 2")
    
    let closure [Int]Func = () -> r.id
    println("Passing closure as argument")
    
    call_closure(closure)
    
    // closure goes out of scope here, should drop captured Resource
}

let main() Int = {
    test_closure_scope_exit()
    test_closure_as_argument()
    
    println("All closure variable drop tests passed")
    yield 0
}
