// Test defer block scope semantics
// Defer binds to the block scope where it is declared, not the function scope.

// Test 1: defer in if then/else branches
// EXPECT: test_defer_if_branches:
// EXPECT: entering then
// EXPECT: defer in then
// EXPECT: after if

// Test 2: defer in if-pattern then/else branches
// EXPECT: test_defer_if_pattern:
// EXPECT: matched value 42
// EXPECT: defer in then
// EXPECT: no match
// EXPECT: defer in else
// EXPECT: done

// Test 3: defer in while loop body (executes each iteration)
// EXPECT: test_defer_while:
// EXPECT: iter 1
// EXPECT: defer while 1
// EXPECT: iter 2
// EXPECT: defer while 2
// EXPECT: iter 3
// EXPECT: defer while 3
// EXPECT: after while

// Test 4: defer in while-pattern loop body
// EXPECT: test_defer_while_pattern:
// EXPECT: got 0
// EXPECT: defer wp 0
// EXPECT: got 1
// EXPECT: defer wp 1
// EXPECT: got 2
// EXPECT: defer wp 2
// EXPECT: after while-pattern

// Test 5: defer in for loop body
// EXPECT: test_defer_for:
// EXPECT: item 10
// EXPECT: defer for 10
// EXPECT: item 20
// EXPECT: defer for 20
// EXPECT: item 30
// EXPECT: defer for 30
// EXPECT: after for

// Test 6: defer in when (match) branches
// EXPECT: test_defer_when:
// EXPECT: matched Some 7
// EXPECT: defer when branch
// EXPECT: matched None
// EXPECT: defer when none
// EXPECT: done

// Test 7: defer in blockExpression
// EXPECT: test_defer_block_expr:
// EXPECT: inside block
// EXPECT: defer in block
// EXPECT: after block

// Test 8: nested scopes (inner defer before outer defer)
// EXPECT: test_defer_nested:
// EXPECT: outer start
// EXPECT: inner start
// EXPECT: defer inner
// EXPECT: defer outer

type MyOption {
    None(),
    Some(val Int),
}

type MyIterator(mut current Int, max Int)

given MyIterator {
    next(self ref) MyOption = {
        yield if self.current < self.max then {
            let v = self.current
            self.current = self.current + 1
            yield MyOption.Some(v)
        } else {
            yield MyOption.None()
        }
    }
}

// Test 1: defer in if then/else branches
let test_defer_if_branches() Void = {
    println("test_defer_if_branches:")
    let x = 1
    if x > 0 then {
        println("entering then")
        defer println("defer in then")
    }
    println("after if")
}

// Test 2: defer in if-pattern then/else branches
let test_defer_if_pattern() Void = {
    println("test_defer_if_pattern:")
    let a = MyOption.Some(42)
    if a is .Some(v) then {
        print("matched value ")
        println(v)
        defer println("defer in then")
    } else {
        defer println("defer in else")
    }
    let b = MyOption.None()
    if b is .Some(v2) then {
        defer println("defer in then2")
    } else {
        println("no match")
        defer println("defer in else")
    }
    println("done")
}

// Test 3: defer in while loop body (executes each iteration)
let test_defer_while() Void = {
    println("test_defer_while:")
    let mut i = 0
    while i < 3 then {
        i = i + 1
        defer {
            print("defer while ")
            println(i)
        }
        print("iter ")
        println(i)
    }
    println("after while")
}

// Test 4: defer in while-pattern loop body
let test_defer_while_pattern() Void = {
    println("test_defer_while_pattern:")
    let mut iter = MyIterator(0, 3)
    while iter.next() is .Some(v) then {
        defer {
            print("defer wp ")
            println(v)
        }
        print("got ")
        println(v)
    }
    println("after while-pattern")
}

// Test 5: defer in for loop body
let test_defer_for() Void = {
    println("test_defer_for:")
    let mut list = [Int]List.new()
    list.push(10)
    list.push(20)
    list.push(30)

    for x = list then {
        defer {
            print("defer for ")
            println(x)
        }
        print("item ")
        println(x)
    }
    println("after for")
}

// Test 6: defer in when (match) branches
let test_defer_when() Void = {
    println("test_defer_when:")
    let opt1 = MyOption.Some(7)
    when opt1 is {
        .Some(v) then {
            print("matched Some ")
            println(v)
            defer println("defer when branch")
        },
        .None then {
            defer println("defer when none")
        },
    }
    let opt2 = MyOption.None()
    when opt2 is {
        .Some(v2) then {
            defer println("defer when some2")
        },
        .None then {
            println("matched None")
            defer println("defer when none")
        },
    }
    println("done")
}

// Test 7: defer in blockExpression
let test_defer_block_expr() Void = {
    println("test_defer_block_expr:")
    {
        println("inside block")
        defer println("defer in block")
    }
    println("after block")
}

// Test 8: nested scopes (inner defer before outer defer)
let test_defer_nested() Void = {
    println("test_defer_nested:")
    println("outer start")
    defer println("defer outer")
    {
        println("inner start")
        defer println("defer inner")
    }
}

public let main() Int = {
    test_defer_if_branches()
    test_defer_if_pattern()
    test_defer_while()
    test_defer_while_pattern()
    test_defer_for()
    test_defer_when()
    test_defer_block_expr()
    test_defer_nested()
    yield 0
}
