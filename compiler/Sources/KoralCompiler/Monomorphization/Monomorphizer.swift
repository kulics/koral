// Monomorphizer.swift
// Implements the monomorphization phase that processes instantiation requests
// and generates concrete types and functions from generic templates.

import Foundation

/// The output from the Monomorphizer phase.
/// Contains only concrete (non-generic) declarations ready for code generation.
public struct MonomorphizedProgram {
    /// The global nodes containing all concrete declarations.
    public let globalNodes: [TypedGlobalNode]
    
    /// 静态方法查找表：(类型名, 方法名) -> DefId
    /// 用于 CodeGen 查找标准库函数的正确 C 标识符
    public let staticMethodLookup: [String: DefId]
    
    /// Trait declarations indexed by trait name.
    /// Used by CodeGen for vtable struct generation.
    public let traits: [String: TraitDeclInfo]
    
    /// Vtable generation requests collected during monomorphization.
    /// Each entry represents a (concreteType, trait) combination that needs
    /// a vtable struct, wrapper functions, and vtable instance generated by CodeGen.
    public let vtableRequests: Set<VtableRequest>

    /// Receiver-style method dispatch metadata keyed by method DefId.
    public let receiverMethodDispatch: [DefId: ReceiverMethodDispatchInfo]
    
    /// Creates a new MonomorphizedProgram.
    public init(
        globalNodes: [TypedGlobalNode],
        staticMethodLookup: [String: DefId] = [:],
        traits: [String: TraitDeclInfo] = [:],
        vtableRequests: Set<VtableRequest> = [],
        receiverMethodDispatch: [DefId: ReceiverMethodDispatchInfo] = [:]
    ) {
        self.globalNodes = globalNodes
        self.staticMethodLookup = staticMethodLookup
        self.traits = traits
        self.vtableRequests = vtableRequests
        self.receiverMethodDispatch = receiverMethodDispatch
    }
    
    /// 查找静态方法的完整限定名
    /// - Parameters:
    ///   - typeName: 类型名（如 "String", "Rune"）
    ///   - methodName: 方法名（如 "empty", "from_utf8_ptr_unchecked"）
    /// - Returns: 对应的 DefId，如果未找到则返回 nil
    public func lookupStaticMethod(typeName: String, methodName: String) -> DefId? {
        let key = "\(typeName).\(methodName)"
        return staticMethodLookup[key]
    }
}

/// The Monomorphizer processes instantiation requests collected during type checking
/// and generates concrete types and functions from generic templates.
public class Monomorphizer {
    internal struct ConcreteMethodEntry {
        let symbol: Symbol
        let trait: TypedTraitConformance?
    }
    // MARK: - Input
    
    /// The output from the TypeChecker phase
    internal let input: TypeCheckerOutput
    
    // MARK: - Caches
    
    /// Cache for instantiated types: "TemplateName<Arg1,Arg2>" -> Type
    internal var instantiatedTypes: [String: Type] = [:]
    
    /// Cache for instantiated functions: "TemplateName<Arg1,Arg2>" -> (SpecializedSymbolName, Type)
    internal var instantiatedFunctions: [String: (String, Type)] = [:]

    /// Cache for instantiated function symbols by instantiation key.
    /// Keeps DefId stable across rewrites and avoids detached call symbols.
    internal var instantiatedFunctionSymbols: [String: Symbol] = [:]
    
    /// Track which layout names have been generated to avoid duplicates
    internal var generatedLayouts: Set<String> = []
    // MARK: - Output
    
    /// Generated global nodes for instantiated types and functions
    internal var generatedNodes: [TypedGlobalNode] = []
    
    /// Cache of defIds whose members have already been resolved
    internal var resolvedStructUnionDefIds: Set<UInt64> = []
    
    // MARK: - State
    
    /// Mapping from Layout Name to Template Info (Base Name + Args)
    internal var layoutToTemplateInfo: [String: (base: String, args: [Type])] = [:]
    
    /// Extension methods indexed by type name (from registry)
    internal var extensionMethods: [String: [String: ConcreteMethodEntry]] = [:]

    /// Inherent given method names indexed by receiver type stableKey.
    /// Used to detect name conflicts with `given Type Trait` methods and
    /// disambiguate specialized emitted symbols only when necessary.
    internal var inherentGivenMethodNamesByTypeKey: [String: Set<String>] = [:]

    
    /// Current source line for error reporting
    internal var currentLine: Int = 1 {
        didSet {
            SemanticErrorContext.currentSpan = SourceSpan(location: SourceLocation(line: currentLine, column: 1))
        }
    }

    /// Current source file for error reporting
    internal var currentFileName: String = "<input>" {
        didSet {
            SemanticErrorContext.currentFileName = currentFileName
        }
    }
    
    /// Collected vtable generation requests: (concreteType, trait) combinations
    /// that need vtable generation during code generation.
    internal var vtableRequests: Set<VtableRequest> = []

    /// Structured extension method lookup: "typeName.methodName" -> DefId
    /// Populated during instantiation so lookup stays DefId-driven.
    internal var extensionMethodDefIds: [String: DefId] = [:]

    /// Mapping from original function DefId to monomorphized function DefIds.
    /// Multiple concrete implementations can originate from a single semantic
    /// method declaration (e.g. trait methods), so we keep all candidates and
    /// select by function type at rewrite sites.
    internal var remappedFunctionDefIds: [DefId: [(defId: DefId, type: Type)]] = [:]

    /// Receiver-style method dispatch metadata tracked during monomorphization.
    /// Seeded from TypeChecker output and propagated when symbols are copied.
    internal var receiverMethodDispatch: [DefId: ReceiverMethodDispatchInfo] = [:]

    /// Pending instantiation requests (work queue for transitive instantiation)
    internal var pendingRequests: [InstantiationRequest] = []
    
    /// Processed request keys to avoid duplicate processing
    internal var processedRequestKeys: Set<InstantiationKey> = []
    
    // MARK: - Recursion Detection
    
    /// Types currently being instantiated (for recursion detection)
    private var instantiatingTypes: Set<String> = []
    
    /// Functions currently being instantiated (for recursion detection)
    private var instantiatingFunctions: Set<String> = []
    
    /// Current recursion depth for instantiation
    private var currentRecursionDepth: Int = 0
    
    /// Maximum allowed recursion depth to prevent infinite loops
    private let maxRecursionDepth: Int = 100
    
    // MARK: - DefId Support
    
    /// Unified compiler context
    internal let context: CompilerContext
    
    /// Creates a Symbol with a new DefId for monomorphized entities
    /// - Parameters:
    ///   - name: Symbol name
    ///   - type: Symbol type
    ///   - kind: Symbol kind
    ///   - methodKind: Compiler method kind (default: .normal)
    ///   - modulePath: Module path (default: empty for generated symbols)
    ///   - sourceFile: Source file (default: empty)
    ///   - access: Access modifier (default: .protected)
    /// - Returns: A new Symbol with allocated DefId
    internal func makeSymbol(
        name: String,
        type: Type,
        kind: SymbolKind,
        methodKind: CompilerMethodKind = .normal,
        modulePath: [String] = [],
        sourceFile: String = "",
        access: AccessModifier = .protected
    ) -> Symbol {
        let isMutable: Bool
        switch kind {
        case .variable(let varKind):
            isMutable = varKind.isMutable
        case .function, .type, .module:
            isMutable = false
        }
        return context.createSymbol(
            name: name,
            modulePath: modulePath,
            sourceFile: sourceFile,
            type: type,
            kind: kind,
            methodKind: methodKind,
            access: access,
            span: .unknown,
            isMutable: isMutable
        )
    }
    
    /// Creates a Symbol by copying from an existing symbol but with a new DefId
    /// Used when transforming symbols during monomorphization
    internal func copySymbolWithNewDefId(
        _ symbol: Symbol,
        newName: String? = nil,
        newType: Type? = nil,
        newModulePath: [String]? = nil,
        newSourceFile: String? = nil
    ) -> Symbol {
        let name = newName ?? context.getName(symbol.defId) ?? "<unknown>"
        let modulePath = newModulePath ?? context.getModulePath(symbol.defId) ?? []
        let sourceFile = newSourceFile ?? context.getSourceFile(symbol.defId) ?? ""
        let access = context.getAccess(symbol.defId) ?? .protected
        let copied = makeSymbol(
            name: name,
            type: newType ?? symbol.type,
            kind: symbol.kind,
            methodKind: symbol.methodKind,
            modulePath: modulePath,
            sourceFile: sourceFile,
            access: access
        )
        if let dispatchInfo = receiverMethodDispatch[symbol.defId] {
            receiverMethodDispatch[copied.defId] = ReceiverMethodDispatchInfo(
                methodDefId: copied.defId,
                methodName: dispatchInfo.methodName,
                owner: dispatchInfo.owner
            )
        }
        return copied
    }

    /// Copies a Symbol while preserving its DefId (for locals/parameters).
    /// This keeps declaration and use sites aligned when C names include DefId.
    internal func copySymbolPreservingDefId(
        _ symbol: Symbol,
        newType: Type? = nil
    ) -> Symbol {
        return Symbol(
            defId: symbol.defId,
            type: newType ?? symbol.type,
            kind: symbol.kind,
            methodKind: symbol.methodKind
        )
    }

    internal func sanitizeSemanticPathSegment(_ text: String) -> String {
        let sanitized = String(text.map { ch -> Character in
            if ch.isLetter || ch.isNumber || ch == "_" {
                return ch
            }
            return "_"
        })
        return sanitized.isEmpty ? "_" : sanitized
    }

    internal func semanticMethodModulePath(
        ownerType: Type,
        trait: TypedTraitConformance? = nil,
        methodTypeArgs: [Type] = []
    ) -> [String] {
        let owner = sanitizeSemanticPathSegment(ownerType.stableKey)
        let traitSegment: String = {
            guard let trait else { return "inherent" }
            let base = sanitizeSemanticPathSegment(trait.traitName)
            guard !trait.traitTypeArgs.isEmpty else { return "trait_\(base)" }
            let args = trait.traitTypeArgs
                .map { sanitizeSemanticPathSegment($0.stableKey) }
                .joined(separator: "_")
            return "trait_\(base)_\(args)"
        }()

        let methodArgsSegment: String = {
            guard !methodTypeArgs.isEmpty else { return "margs_none" }
            let args = methodTypeArgs
                .map { sanitizeSemanticPathSegment($0.stableKey) }
                .joined(separator: "_")
            return "margs_\(args)"
        }()

        return ["__mono", "method", owner, traitSegment, methodArgsSegment]
    }

    internal func selectExtensionTemplate(
        _ extensions: [GenericExtensionMethodTemplate],
        name: String,
        methodTypeArgCount: Int? = nil,
        extensionTypeArgCount: Int? = nil
    ) -> GenericExtensionMethodTemplate? {
        let candidates = extensions.filter { ext in
            guard ext.method.name == name else {
                return false
            }
            if let methodTypeArgCount, ext.method.typeParameters.count != methodTypeArgCount {
                return false
            }
            if let extensionTypeArgCount, ext.typeParams.count != extensionTypeArgCount {
                return false
            }
            return true
        }

        if let checked = candidates.first(where: { $0.checkedBody != nil }) {
            return checked
        }
        return candidates.first
    }
    
    // MARK: - Initialization
    
    /// Creates a new Monomorphizer with the given TypeChecker output.
    /// - Parameter input: The output from the TypeChecker phase
    public init(input: TypeCheckerOutput) {
        self.input = input
        self.context = input.context
        self.receiverMethodDispatch = input.genericTemplates.receiverMethodDispatch
        // Initialize concrete extension methods from typed given declarations
        // instead of the typechecker registry, to avoid symbol collisions
        // when multiple receiver types share the same method name.
        self.extensionMethods = [:]

        if case .program(let nodes) = input.program {
            for node in nodes {
                guard case .givenDeclaration(let type, let trait, let methods) = node else { continue }

                let receiverType = resolveParameterizedType(type)
                let typeName: String
                switch receiverType {
                case .structure(let defId), .union(let defId):
                    typeName = context.getName(defId) ?? receiverType.description
                case .int, .int8, .int16, .int32, .int64,
                     .uint, .uint8, .uint16, .uint32, .uint64,
                     .float32, .float64,
                     .bool:
                    typeName = receiverType.description
                default:
                    continue
                }

                var methodMap = extensionMethods[typeName] ?? [:]
                for method in methods {
                    let methodName = receiverMethodDispatch[method.identifier.defId]?.methodName
                        ?? (context.getName(method.identifier.defId) ?? "<unknown>")

                    let parameterTypes = method.parameters.map {
                        Parameter(type: $0.type, kind: fromSymbolKindToPassKind($0.kind))
                    }
                    let functionType = Type.function(parameters: parameterTypes, returns: method.returnType)
                    let methodSymbol = copySymbolPreservingDefId(
                        method.identifier,
                        newType: functionType
                    )

                    methodMap[methodName] = ConcreteMethodEntry(symbol: methodSymbol, trait: trait)
                }
                extensionMethods[typeName] = methodMap

                guard trait == nil else { continue }

                let typeKey = type.stableKey
                var names = inherentGivenMethodNamesByTypeKey[typeKey] ?? Set<String>()
                for method in methods {
                    let methodName = receiverMethodDispatch[method.identifier.defId]?.methodName
                        ?? (context.getName(method.identifier.defId) ?? "<unknown>")
                    names.insert(methodName)
                }
                inherentGivenMethodNamesByTypeKey[typeKey] = names
            }
        }
    }

    private enum PendingRequestKindOrder: Int {
        case structType = 0
        case unionType = 1
        case function = 2
        case extensionMethod = 3
        case traitMethod = 4
    }

    private struct PendingRequestSortKey: Comparable {
        let kindOrder: PendingRequestKindOrder
        let templateName: String
        let methodName: String
        let baseTypeKey: String
        let typeArgKeys: [String]
        let methodTypeArgKeys: [String]
        let sourceFileName: String
        let sourceLine: Int

        static func < (lhs: PendingRequestSortKey, rhs: PendingRequestSortKey) -> Bool {
            if lhs.kindOrder.rawValue != rhs.kindOrder.rawValue {
                return lhs.kindOrder.rawValue < rhs.kindOrder.rawValue
            }
            if lhs.templateName != rhs.templateName {
                return lhs.templateName < rhs.templateName
            }
            if lhs.methodName != rhs.methodName {
                return lhs.methodName < rhs.methodName
            }
            if lhs.baseTypeKey != rhs.baseTypeKey {
                return lhs.baseTypeKey < rhs.baseTypeKey
            }
            if lhs.typeArgKeys != rhs.typeArgKeys {
                return lhs.typeArgKeys.lexicographicallyPrecedes(rhs.typeArgKeys)
            }
            if lhs.methodTypeArgKeys != rhs.methodTypeArgKeys {
                return lhs.methodTypeArgKeys.lexicographicallyPrecedes(rhs.methodTypeArgKeys)
            }
            if lhs.sourceFileName != rhs.sourceFileName {
                return lhs.sourceFileName < rhs.sourceFileName
            }
            return lhs.sourceLine < rhs.sourceLine
        }
    }

    private func pendingRequestSortKey(_ request: InstantiationRequest) -> PendingRequestSortKey {
        let key = request.deduplicationKey
        switch key {
        case .structType(let templateName, let args):
            return PendingRequestSortKey(
                kindOrder: .structType,
                templateName: templateName,
                methodName: "",
                baseTypeKey: "",
                typeArgKeys: args.map(\.stableKey),
                methodTypeArgKeys: [],
                sourceFileName: request.sourceFileName,
                sourceLine: request.sourceLine
            )
        case .unionType(let templateName, let args):
            return PendingRequestSortKey(
                kindOrder: .unionType,
                templateName: templateName,
                methodName: "",
                baseTypeKey: "",
                typeArgKeys: args.map(\.stableKey),
                methodTypeArgKeys: [],
                sourceFileName: request.sourceFileName,
                sourceLine: request.sourceLine
            )
        case .function(let templateName, let args):
            return PendingRequestSortKey(
                kindOrder: .function,
                templateName: templateName,
                methodName: "",
                baseTypeKey: "",
                typeArgKeys: args.map(\.stableKey),
                methodTypeArgKeys: [],
                sourceFileName: request.sourceFileName,
                sourceLine: request.sourceLine
            )
        case .extensionMethod(let templateName, let methodName, let typeArgs, let methodTypeArgs):
            return PendingRequestSortKey(
                kindOrder: .extensionMethod,
                templateName: templateName,
                methodName: methodName,
                baseTypeKey: "",
                typeArgKeys: typeArgs.map(\.stableKey),
                methodTypeArgKeys: methodTypeArgs.map(\.stableKey),
                sourceFileName: request.sourceFileName,
                sourceLine: request.sourceLine
            )
        case .traitMethod(let baseType, let methodName, let methodTypeArgs):
            return PendingRequestSortKey(
                kindOrder: .traitMethod,
                templateName: "",
                methodName: methodName,
                baseTypeKey: baseType.stableKey,
                typeArgKeys: [],
                methodTypeArgKeys: methodTypeArgs.map(\.stableKey),
                sourceFileName: request.sourceFileName,
                sourceLine: request.sourceLine
            )
        }
    }

    private func popNextPendingRequest() -> InstantiationRequest? {
        guard !pendingRequests.isEmpty else { return nil }
        var bestIndex = 0
        var bestKey = pendingRequestSortKey(pendingRequests[0])
        for i in 1..<pendingRequests.count {
            let key = pendingRequestSortKey(pendingRequests[i])
            if key < bestKey {
                bestKey = key
                bestIndex = i
            }
        }
        return pendingRequests.remove(at: bestIndex)
    }
    
    // MARK: - Main Entry Point
    
    /// Performs monomorphization on all collected instantiation requests.
    /// - Returns: A MonomorphizedProgram containing only concrete declarations
    /// - Throws: SemanticError if monomorphization fails
    public func monomorphize() throws -> MonomorphizedProgram {
        // Start with the original program's global nodes
        var resultNodes: [TypedGlobalNode] = []

        
        // Extract non-template nodes from the typed program
        // Also pre-populate caches to avoid duplicating work that TypeChecker already did
        if case .program(let nodes) = input.program {
            for node in nodes {
                switch node {
                case .foreignUsing, .foreignType, .foreignStruct, .foreignGlobalVariable, .foreignFunction:
                    resultNodes.append(node)
                case .genericTypeTemplate, .genericFunctionTemplate:
                    // Skip template placeholders - they will be instantiated on demand
                    break
                case .globalStructDeclaration(let identifier, _):
                    // Track already-generated struct layouts
                    let identifierName = context.getName(identifier.defId) ?? "<unknown>"
                    generatedLayouts.insert(identifierName)
                    // Also cache the type if it's a generic instantiation
                          if case .structure(let defId) = identifier.type,
                              context.isGenericInstantiation(defId) == true {
                        instantiatedTypes[identifierName] = identifier.type
                    }
                    resultNodes.append(node)
                case .globalUnionDeclaration(let identifier, _):
                    // Track already-generated union layouts
                    let identifierName = context.getName(identifier.defId) ?? "<unknown>"
                    generatedLayouts.insert(identifierName)
                          if case .union(let defId) = identifier.type,
                              context.isGenericInstantiation(defId) == true {
                        instantiatedTypes[identifierName] = identifier.type
                    }
                    resultNodes.append(node)
                case .globalFunction(let identifier, _, _):
                    // Track already-generated functions
                    let identifierName = context.getName(identifier.defId) ?? "<unknown>"
                    generatedLayouts.insert(identifierName)
                    instantiatedFunctions[identifierName] = (identifierName, identifier.type)
                    resultNodes.append(node)
                case .givenDeclaration(let type, _, let methods):
                    // Track already-generated extension methods
                    let emittedTypeScopeName: String
                    switch type {
                    case .structure(let defId):
                        emittedTypeScopeName = context.getQualifiedName(defId) ?? type.description
                    case .union(let defId):
                        emittedTypeScopeName = context.getQualifiedName(defId) ?? type.description
                    default:
                        emittedTypeScopeName = type.description
                    }
                    
                    for method in methods {
                        let methodName = context.getName(method.identifier.defId) ?? "<unknown>"
                        let specializedMethodSymbolName = "\(emittedTypeScopeName)_\(methodName)"
                        generatedLayouts.insert(specializedMethodSymbolName)
                        instantiatedFunctions[specializedMethodSymbolName] = (
                            specializedMethodSymbolName,
                            method.identifier.type
                        )
                    }
                    resultNodes.append(node)
                default:
                    resultNodes.append(node)
                }
            }
        }

        
        // Initialize pending requests with all collected instantiation requests
        pendingRequests = Array(input.instantiationRequests)
        
        // Process all instantiation requests (including transitive ones)
        while let request = popNextPendingRequest() {
            try processRequest(request)
        }
        
        // Resolve genericStruct/genericUnion types in all result nodes
        var resolvedResultNodes: [TypedGlobalNode] = []
        predeclareGivenMethodRemaps(in: resultNodes)
        for node in resultNodes {
            let resolvedNode = try resolveTypesInGlobalNode(node)
            resolvedResultNodes.append(resolvedNode)
        }
        
        // Process any new instantiation requests that were added during type resolution
        while let request = popNextPendingRequest() {
            try processRequest(request)
        }
        
        // Also resolve types in generated nodes
        var resolvedGeneratedNodes: [TypedGlobalNode] = []
        var processedGeneratedCount = 0
        
        while processedGeneratedCount < generatedNodes.count {
            let pendingGeneratedSlice = Array(generatedNodes[processedGeneratedCount..<generatedNodes.count])
            predeclareGivenMethodRemaps(in: pendingGeneratedSlice)
            for i in processedGeneratedCount..<generatedNodes.count {
                let resolvedNode = try resolveTypesInGlobalNode(generatedNodes[i])
                resolvedGeneratedNodes.append(resolvedNode)
            }
            processedGeneratedCount = generatedNodes.count
            
            while let request = popNextPendingRequest() {
                try processRequest(request)
            }
        }
        
        var allNodes = resolvedGeneratedNodes + resolvedResultNodes

        // Finalize trait placeholder resolution after all instantiations.
        var processedCount = processedRequestKeys.count
        var didProcess = true
        while didProcess {
            while let request = popNextPendingRequest() {
                try processRequest(request)
            }

            var reResolved: [TypedGlobalNode] = []
            // Clear resolution cache so types updated by new instantiations get re-resolved
            resolvedStructUnionDefIds.removeAll()
            for node in allNodes {
                let resolvedNode = try resolveTypesInGlobalNode(node)
                reResolved.append(resolvedNode)
            }
            allNodes = reResolved

            didProcess = processedRequestKeys.count != processedCount
            processedCount = processedRequestKeys.count
        }

        // 构建静态方法查找表
        let staticMethodLookup = buildStaticMethodLookup(from: allNodes)
        
        return MonomorphizedProgram(
            globalNodes: allNodes,
            staticMethodLookup: staticMethodLookup,
            traits: input.genericTemplates.traits,
            vtableRequests: vtableRequests,
            receiverMethodDispatch: receiverMethodDispatch
        )
    }
    
    /// 构建静态方法查找表
    /// - Parameter nodes: 所有全局节点
    /// - Returns: (类型名.方法名) -> DefId 的映射
    private func buildStaticMethodLookup(from nodes: [TypedGlobalNode]) -> [String: DefId] {
        var lookup: [String: DefId] = [:]
        
        // Merge structured extension method lookup (populated during instantiation)
        for (key, defId) in extensionMethodDefIds {
            lookup[key] = defId
        }
        
        for node in nodes {
            switch node {
            case .givenDeclaration(let type, let trait, let methods):
                // 获取类型的简单名称（不含模块路径）
                let typeName: String
                switch type {
                case .structure(let defId):
                    let name = context.getName(defId) ?? type.description
                    typeName = name
                case .union(let defId):
                    let name = context.getName(defId) ?? type.description
                    typeName = name
                default:
                    typeName = type.description
                }
                
                // 注册每个方法
                for method in methods {
                    if let dispatchInfo = receiverMethodDispatch[method.identifier.defId] {
                        let key = "\(typeName).\(dispatchInfo.methodName)"
                        if trait != nil {
                            if lookup[key] == nil {
                                lookup[key] = method.identifier.defId
                            }
                        } else {
                            lookup[key] = method.identifier.defId
                        }
                        continue
                    }
                }
                
            default:
                break
            }
        }
        
        return lookup
    }

    // MARK: - Trait Placeholder Instantiation

    internal func instantiateTraitPlaceholderMethod(baseType: Type, name: String, methodTypeArgs: [Type]) throws {
        let base: Type
        switch baseType {
        case .reference(let inner):
            base = inner
        default:
            base = baseType
        }

        switch base {
        case .genericStruct(let template, let args):
            let resolvedArgs = args.map { resolveParameterizedType($0) }
                if !resolvedArgs.contains(where: { context.containsGenericParameter($0) }),
                    let extensions = input.genericTemplates.extensionMethods[template],
                    let ext = selectExtensionTemplate(
                        extensions,
                        name: name,
                        methodTypeArgCount: methodTypeArgs.count,
                        extensionTypeArgCount: resolvedArgs.count
                    ) {
                let resolvedBase = resolveParameterizedType(.genericStruct(template: template, args: resolvedArgs))
                _ = try instantiateExtensionMethodFromEntry(
                    baseType: resolvedBase,
                    structureName: template,
                    genericArgs: resolvedArgs,
                    methodTypeArgs: methodTypeArgs,
                    methodInfo: ext
                )
            }
        case .genericUnion(let template, let args):
            let resolvedArgs = args.map { resolveParameterizedType($0) }
                if !resolvedArgs.contains(where: { context.containsGenericParameter($0) }),
                    let extensions = input.genericTemplates.extensionMethods[template],
                    let ext = selectExtensionTemplate(
                        extensions,
                        name: name,
                        methodTypeArgCount: methodTypeArgs.count,
                        extensionTypeArgCount: resolvedArgs.count
                    ) {
                let resolvedBase = resolveParameterizedType(.genericUnion(template: template, args: resolvedArgs))
                _ = try instantiateExtensionMethodFromEntry(
                    baseType: resolvedBase,
                    structureName: template,
                    genericArgs: resolvedArgs,
                    methodTypeArgs: methodTypeArgs,
                    methodInfo: ext
                )
            }
        case .structure(let defId), .union(let defId):
            let typeName = context.getName(defId) ?? ""
            let simpleName = typeName.split(separator: ".").last.map(String.init) ?? typeName
            // Use stored templateName if available, otherwise fall back to full name
            let baseName = context.getTemplateName(defId) ?? simpleName
            var extensions = input.genericTemplates.extensionMethods[baseName]
            if extensions == nil {
                if let matchKey = input.genericTemplates.extensionMethods.keys.first(where: { key in
                    simpleName.hasPrefix(key) || simpleName.contains(key)
                }) {
                    extensions = input.genericTemplates.extensionMethods[matchKey]
                }
            }
                if let extensions,
                    let ext = selectExtensionTemplate(
                     extensions,
                     name: name,
                     methodTypeArgCount: methodTypeArgs.count
                    ) {
                                let resolvedTypeArgs = context.getTypeArguments(defId)
                                    ?? layoutToTemplateInfo[typeName]?.args
                if resolvedTypeArgs == nil || resolvedTypeArgs?.count != ext.typeParams.count {
                    throw SemanticError(
                        .generic("Missing type arguments for generic instantiation '\(typeName)' while resolving method '\(name)'."),
                        span: SourceSpan(location: SourceLocation(line: currentLine, column: 1))
                    )
                }
                if let typeArgs = resolvedTypeArgs,
                   typeArgs.count == ext.typeParams.count {
                    _ = try instantiateExtensionMethodFromEntry(
                        baseType: base,
                        structureName: baseName,
                        genericArgs: typeArgs,
                        methodTypeArgs: methodTypeArgs,
                        methodInfo: ext
                    )
                }
            }
        default:
            break
        }
    }

    internal func enqueueTraitPlaceholderRequest(
        baseType: Type,
        methodName: String,
        methodTypeArgs: [Type]
    ) {
        if context.containsGenericParameter(baseType) {
            return
        }
        if methodTypeArgs.contains(where: { context.containsGenericParameter($0) }) {
            return
        }
        pendingRequests.append(InstantiationRequest(
            kind: .traitMethod(
                baseType: baseType,
                methodName: methodName,
                methodTypeArgs: methodTypeArgs
            ),
            sourceLine: currentLine,
            sourceFileName: currentFileName
        ))
    }

    
    // MARK: - Request Processing
    
    /// Processes a single instantiation request.
    private func processRequest(_ request: InstantiationRequest) throws {
        currentLine = request.sourceLine
        currentFileName = request.sourceFileName
        SemanticErrorContext.currentFileName = currentFileName

        guard currentRecursionDepth < maxRecursionDepth else {
            throw SemanticError(
                .generic("Maximum instantiation depth exceeded (possible infinite recursion)"),
                span: SourceSpan(location: SourceLocation(line: currentLine, column: 1))
            )
        }
        
        let key = request.deduplicationKey
        guard !processedRequestKeys.contains(key) else {
            return
        }
        processedRequestKeys.insert(key)
        
        currentRecursionDepth += 1
        defer { currentRecursionDepth -= 1 }
        
        do {
            switch request.kind {
            case .structType(let template, let args):
                _ = try instantiateStruct(template: template, args: args)
            case .unionType(let template, let args):
                _ = try instantiateUnion(template: template, args: args)
            case .function(let template, let args):
                _ = try instantiateFunction(template: template, args: args)
            case .extensionMethod(let templateName, let baseType, let template, let typeArgs, let methodTypeArgs):
                _ = try instantiateExtensionMethod(
                    baseType: baseType,
                    templateName: templateName,
                    template: template,
                    typeArgs: typeArgs,
                    methodTypeArgs: methodTypeArgs
                )
            case .traitMethod(let baseType, let methodName, let methodTypeArgs):
                _ = try instantiateTraitPlaceholderMethod(
                    baseType: baseType,
                    name: methodName,
                    methodTypeArgs: methodTypeArgs
                )
            }
        } catch let e as SemanticError {
            throw e
        }
    }
    
    // MARK: - Helper Methods
    
    internal func getCompilerMethodKind(_ name: String) -> CompilerMethodKind {
        return SemaUtils.getCompilerMethodKind(name)
    }

    /// 获取或分配类型定义的 DefId（用于单态化生成的类型）
    internal func getOrAllocateTypeDefId(
        name: String,
        kind: TypeDefKind,
        modulePath: [String] = [],
        sourceFile: String = "",
        access: AccessModifier = .protected
    ) -> DefId {
        if let existing = context.lookupDefId(modulePath: modulePath, name: name, sourceFile: sourceFile.isEmpty ? nil : sourceFile) {
            return existing
        }
        return context.allocateDefId(
            modulePath: modulePath,
            name: name,
            kind: .type(kind),
            sourceFile: sourceFile,
            access: access,
            span: .unknown
        )
    }
    
    private func resolveTraitName(from node: TypeNode) throws -> String {
        return try SemaUtils.resolveTraitName(from: node)
    }
    
    private func builtinStringType() -> Type {
        let defId = getOrAllocateTypeDefId(name: "String", kind: .structure)
        return .structure(defId: defId)
    }
}
