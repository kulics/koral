// ============================================================================
// Koral Standard Library - List Type
// ============================================================================
// NOTE: This file is merged into core.koral, so primitives, traits, option, and string are already available.
// ============================================================================

// ============================================================================
// List Storage and Type Definition
// ============================================================================

public type [T Any]ListStorage(mut source [T]Pointer, mut len Int, mut cap Int)

given[T Any] [T]ListStorage {
    __drop(self ref) = {
        let mut i = 0
        while i < self.len then {
            self.source.offset(i).deinit()
            i += 1
        }
        dealloc_memory(self.source)
    }
}

public type [T Any]List(mut storage [T]ListStorage ref)

public type [T Any]ListIterator(storage [T]ListStorage ref, mut index Int)

// ============================================================================
// List Methods
// ============================================================================

given[T Any] [T]List {
    public new() Self = {
        let cap = 10
        let source = [T]alloc_memory(cap)
        let storage = ref [T]ListStorage(source, 0, cap)
        [T]List(storage)
    }

    public with_capacity(capacity Int) Self = {
        let cap = if capacity < 1 then 1 else capacity
        let source = [T]alloc_memory(cap)
        let storage = ref [T]ListStorage(source, 0, cap)
        [T]List(storage)
    }

    public count(self) Int = self.storage.len

    private ensure_unique(self ref) Void = {
        if ref_count(self.storage) > 1 then {
            let old = self.storage
            let new_cap = old.cap
            let new_source = [T]alloc_memory(new_cap)
            let mut i = 0
            while i < old.len then {
                let v = old.source.offset(i).peek()
                new_source.offset(i).init(v)
                i += 1
            }
            let new_storage = ref [T]ListStorage(new_source, old.len, new_cap)
            self.storage = new_storage
        }
    }

    private ensure_capacity(self ref, min_capacity Int) Void = {
         if min_capacity > self.storage.cap then {
             let mut new_cap = self.storage.cap * 2
             if new_cap < min_capacity then { new_cap = min_capacity; }
             let new_source = [T]alloc_memory(new_cap)
             let old_len = self.storage.len
             if ref_count(self.storage) == 1 then {
                 let old_source = self.storage.source
                 move_memory(new_source, old_source, old_len)
                 dealloc_memory(old_source)
                 self.storage.source = new_source
                 self.storage.cap = new_cap
             } else {
                 let mut i = 0
                 while i < old_len then {
                    let v = self.storage.source.offset(i).peek()
                    new_source.offset(i).init(v)
                    i += 1
                 }
                 let new_storage = ref [T]ListStorage(new_source, old_len, new_cap)
                 self.storage = new_storage
             }
         } else {
             self.ensure_unique()
         }
    }

    public push_back(self ref, value T) Void = {
        self.ensure_capacity(self.storage.len + 1)
        self.storage.source.offset(self.storage.len).init(value)
        self.storage.len = self.storage.len + 1
    }

    // Using if is pattern matching
    public pop_back(self ref) [T]Option = {
        if self.storage.len == 0 then { return [T]Option.None(); }
        self.ensure_unique()
        self.storage.len = self.storage.len - 1
        let value = self.storage.source.offset(self.storage.len).take()
        [T]Option.Some(value)
    }

    public push_front(self ref, value T) Void = {
        self.ensure_capacity(self.storage.len + 1)
        // Shift all elements to the right
        let mut i = self.storage.len
        while i > 0 then {
            let src = self.storage.source.offset(i - 1)
            let dst = self.storage.source.offset(i)
            dst.init(src.take())
            i = i - 1
        }
        self.storage.source.offset(0).init(value)
        self.storage.len = self.storage.len + 1
    }

    public pop_front(self ref) [T]Option = {
        if self.storage.len == 0 then { return [T]Option.None(); }
        self.ensure_unique()
        let value = self.storage.source.offset(0).take()
        // Shift all elements to the left
        let mut i = 0
        while i < self.storage.len - 1 then {
            let src = self.storage.source.offset(i + 1)
            let dst = self.storage.source.offset(i)
            dst.init(src.take())
            i = i + 1
        }
        self.storage.len = self.storage.len - 1
        [T]Option.Some(value)
    }

    public insert(self ref, index Int, value T) Void = {
        if index < 0 or index > self.storage.len then { panic("List insert index out of bounds"); }
        self.ensure_capacity(self.storage.len + 1)
        // Shift elements to the right
        let mut i = self.storage.len
        while i > index then {
            let src = self.storage.source.offset(i - 1)
            let dst = self.storage.source.offset(i)
            dst.init(src.take())
            i = i - 1
        }
        self.storage.source.offset(index).init(value)
        self.storage.len = self.storage.len + 1
    }

    public remove(self ref, index Int) T = {
        if index < 0 or index >= self.storage.len then { panic("List remove index out of bounds"); }
        self.ensure_unique()
        let value = self.storage.source.offset(index).take()
        // Shift elements to the left
        let mut i = index
        while i < self.storage.len - 1 then {
            let src = self.storage.source.offset(i + 1)
            let dst = self.storage.source.offset(i)
            dst.init(src.take())
            i = i + 1
        }
        self.storage.len = self.storage.len - 1
        value
    }

    public get(self, index Int) [T]Option = {
        if index < 0 or index >= self.storage.len then { return [T]Option.None(); }
        [T]Option.Some(self.storage.source.offset(index).peek())
    }

    public replace(self ref, index Int, value T) [T]Option = {
        if index < 0 or index >= self.storage.len then { return [T]Option.None(); }
        self.ensure_unique()
        let old = self.storage.source.offset(index).replace(value)
        [T]Option.Some(old)
    }

    public front(self) [T]Option = self.get(0)

    public back(self) [T]Option = {
        if self.storage.len == 0 then { return [T]Option.None(); }
        self.get(self.storage.len - 1)
    }

    public is_empty(self) Bool = self.storage.len == 0

    public clear(self ref) Void = {
        self.ensure_unique()
        let mut i = 0
        while i < self.storage.len then {
            self.storage.source.offset(i).deinit()
            i += 1
        }
        self.storage.len = 0
    }

    public iterator(self) [T]ListIterator = [T]ListIterator(self.storage, 0)

    public __at(self, index Int) T = {
        if index < 0 or index >= self.storage.len then { panic("List index out of bounds"); }
        self.storage.source.offset(index).peek()
    }

    public __update_at(self ref, index Int, value T) Void = {
        if index < 0 or index >= self.storage.len then { panic("List index out of bounds"); }
        self.ensure_unique()
        self.storage.source.offset(index).replace(value);
    }
}

given[T Equatable] [T]List {
    public contains(self, value T) Bool = {
        let mut i = 0
        while i < self.storage.len then {
            if self.storage.source.offset(i).peek() == value then {
                return true
            }
            i += 1
        }
        false
    }
}

// ============================================================================
// List Iterator - Using new pattern matching
// ============================================================================

given[T Any] [T]ListIterator {
    public next(self ref) [T]Option = {
        if self.index >= self.storage.len then { return [T]Option.None(); }
        let value = self.storage.source.offset(self.index).peek()
        self.index = self.index + 1
        [T]Option.Some(value)
    }
}

// ============================================================================
// List ToString Implementation
// ============================================================================

given [T ToString] [T]List {
    public to_string(self) String = {
        let mut result = String.empty()
        result.push_string("[")
        let mut i = 0
        while i < self.count() then {
            if i > 0 then { result.push_string(", "); }
            result.push_string(self[i].to_string())
            i += 1
        }
        result.push_string("]")
        result
    }
}
