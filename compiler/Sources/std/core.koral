
public intrinsic type Bool;

public intrinsic type Int;
// type Int8;
// type Int16;
// type Int32;
// type Int64;

// type UInt;
// type UInt8;
// type UInt16;
// type UInt32;
// type UInt64;

// type Float16;
// type Float32;
// type Float64;
public intrinsic type Float;

public intrinsic type String;
public intrinsic type [T Any]Pointer;

// type Byte = UInt8;
// type Rune = UInt32;

// builtin
// trait Any {}

// Most pointer operations are available for Any type [T].
intrinsic given[T Any] [T]Pointer {
    // --- Access & Mutation ---

    // Initializes this pointerâ€™s memory with the given value.
    // This writes to *uninitialized* memory and does NOT drop any existing value.
    // POSTCONDITION: Memory at `self` is initialized.
    init(self, v T) Void;

    // Deinitializes the memory at `self`.
    // This drops the value and returns the memory to an uninitialized state.
    // PRECONDITION: Memory at `self` must be initialized.
    deinit(self) Void;

    // Accesses the value pointed to by `self` without removing or invalidating it.
    // Returns a reference of the value.
    // PRECONDITION: Memory at `self` must be initialized.
    // NOTE: This is the primitive operation used to implement `__at` for higher constructs.
    peek(self) T ref;

    // [Compiler Protocol]
    // Enables `ptr[index]` syntax.
    // Equivalent to `self.offset(index).peek()`.
    // PRECONDITION: Memory at `self + index` must be initialized.
    // __at(self, index Int) T ref;

    // [Compiler Protocol]
    // Enables `ptr[index] = val` mutation syntax.
    // Equivalent to `self.offset(index).peek()`.
    // PRECONDITION: Memory at `self + index` must be initialized.
    // __at_mut(self, index Int) T ref;

    // Retrieves the value from `self`, leaving the memory uninitialized.
    // Ideally used for moving values out of the pointer.
    // PRECONDITION: Memory at `self` must be initialized.
    // POSTCONDITION: Memory at `self` is uninitialized.
    take(self) T;

    // Replaces the value at `self` with `v`, returning the old value.
    // Neither the old value nor the new value is dropped.
    // PRECONDITION: Memory at `self` must be initialized.
    replace(self, v T) T;

    // --- Arithmetic ---

    // Returns a new pointer moved forward by `n` elements from `self`.
    // The offset is in units of T (stride), not bytes.
    offset(self, n Int) [T]Pointer;
};

public intrinsic let [T Any]ref_count(r T ref) Int;

// Allocates uninitialized memory for `capacity` number of elements.
// The caller is responsible for deallocating this memory later.
public intrinsic let [T Any]alloc_memory(capacity Int) [T]Pointer;

// Deallocates the memory pointed to by `ptr`.
// PRECONDITION: The memory must be deinitialized (i.e. uninitialized).
// If the memory contains values that need to be dropped, call `ptr.deinit()` first.
public intrinsic let [T Any]dealloc_memory(ptr [T]Pointer) Void;

// Copies `count` elements from `source` to `dest`.
// The memory regions must NOT overlap.
// PRECONDITION: Memory at `dest` must be uninitialized. `source` must be initialized.
// POSTCONDITION: Memory at `dest` is initialized. `source` remains initialized.
public intrinsic let [T Any]copy_memory(dest [T]Pointer, source [T]Pointer, count Int) Void;

// Moves `count` elements from `source` to `dest`.
// The memory regions may overlap.
// PRECONDITION: Memory at `dest` must be uninitialized. `source` must be initialized.
// POSTCONDITION: Memory at `dest` is initialized. Memory at `source` becomes uninitialized.
public intrinsic let [T Any]move_memory(dest [T]Pointer, source [T]Pointer, count Int) Void;

// Temporary IO
public intrinsic let print_string(message String) Void;
public intrinsic let print_int(value Int) Void;
public intrinsic let print_bool(value Bool) Void;

private type [T Copy]ListStorage(mut source [T]Pointer, mut len Int, mut cap Int);

public type [T Copy]List(private mut storage [T]ListStorage ref);

given[T Copy] [T]List {
    public new() Self = [T]List(ref [T]ListStorage( [T]alloc_memory(10), 0, 10));

    // [Compiler Protocol]
    // Automatically called when the object goes out of scope.
    // User code cannot call this directly.
    __drop(self ref) = {
        if ref_count(self.storage) == 1 then {
            let mut i = 0;
            while i < self.storage.len then {
                self.storage.source.offset(i).deinit();
                i += 1;
            };
            dealloc_memory(self.storage.source);
        } else {}
    }

    public count(self ref) Int = self.storage.len;

    // [Compiler Protocol]
    // Lowering target for `list[index]` in read context.
    // Returns a temporary reference to the element.
    public __at(self ref, index Int) T ref = {
        // Bounds check can be added here
        self.storage.source.offset(index).peek()
    }

    // [Compiler Protocol]
    // Lowering target for `list[index]` in write/mutating context.
    // e.g., `list[0] = val` or `list[0].field = val`.
    // Handles Copy-On-Write logic internally.
    public __at_mut(self ref, index Int) T ref = {
        self.ensure_capacity(self.storage.len);
        self.storage.source.offset(index).peek()
    }
    
    public set(self ref, index Int, value T) Void = {
        self.ensure_capacity(self.storage.len);
        self.storage.source.offset(index).replace(value);
    }

    public push_back(self ref, value T) Void = {
        self.ensure_capacity(self.storage.len + 1);
        self.storage.source.offset(self.storage.len).init(value);
        self.storage.len = self.storage.len + 1;
    }

    public insert(self ref, index Int, value T) Void = {
        self.ensure_capacity(self.storage.len + 1);
        
        if index < self.storage.len then {
            let src = self.storage.source.offset(index);
            let dest = self.storage.source.offset(index + 1);
            let count = self.storage.len - index;
            move_memory(dest, src, count);
            self.storage.source.offset(index).init(value);
        } else {
             self.storage.source.offset(self.storage.len).init(value);
        };
        self.storage.len = self.storage.len + 1;
    }

    public remove(self ref, index Int) Void = {
        self.ensure_capacity(self.storage.len);
        
        // 1. Drop the element at index
        self.storage.source.offset(index).deinit();
        
        // 2. Shift remaining elements down
        if index < self.storage.len - 1 then {
            let src = self.storage.source.offset(index + 1);
            let dest = self.storage.source.offset(index);
            let count = self.storage.len - 1 - index;
            
            // Move [index+1...len-1] to [index...len-2]
            move_memory(dest, src, count);
        } else {};
        
        self.storage.len = self.storage.len - 1;
    }

    // Ensures the list is unique and has enough capacity
    private ensure_capacity(self ref, min_capacity Int) Void = {
        if ref_count(self.storage) > 1 then {
             // Shared case - Clone and Grow if needed
             let mut new_cap = self.storage.cap;
             if min_capacity > new_cap then {
                 new_cap = new_cap * 2;
                 if new_cap < min_capacity then {
                     new_cap = min_capacity;
                 } else {};
             } else {};
             
             let new_source = [T]alloc_memory(new_cap);
             let mut i = 0;
             while i < self.storage.len then {
                new_source.offset(i).init(deref self.storage.source.offset(i).peek());
                i += 1;
             };
             self.storage = ref [T]ListStorage(new_source, self.storage.len, new_cap);
             
        } else {
             // Unique case - Grow if needed
             if min_capacity > self.storage.cap then {
                 let mut new_cap = self.storage.cap * 2;
                 if new_cap < min_capacity then {
                     new_cap = min_capacity;
                 } else {};
                 
                 let new_source = [T]alloc_memory(new_cap);
                 copy_memory(new_source, self.storage.source, self.storage.len);
                 dealloc_memory(self.storage.source);
                 
                 self.storage.source = new_source;
                 self.storage.cap = new_cap;
             } else {};
        }
    }
}
/*
public type [T Copy]ListIterator(source [T]List ref, mut index Int);

given[T Copy] [T]ListIterator {
    public next(self [T]List ref) [T]Option = 
        if self.index < self.source.count() then {
            self.index += 1;
            .Some(self.source[self.index])
        } else {
            .None()
        }
}


public type String(source [Byte]List);

given String {
    public of_utf8_bytes(data [Byte]List) Self = String(data);

    public count(self [T]List ref) Int = self.source.count();

    public iterator(self) StringIterator = StringIterator(self, -1);
}

public type StringIterator(source String, mut index Int);

given StringIterator {
    public next(self Self ref) [Rune]Option = 
        if self.index < self._source.data.size() then {
            self.index += 1;
            .Some((Rune){deref self.source.source.get(self.index)})
        } else {
            .None()
        }
}

public type [T Any]Option {
    Some(value T);
    None();
}

given[T Any] [T]Option {
    public [U Any]map(self, fn [T, U]Func) [U]Option = if self is .Some(v) then .Some(fn(v)) else .None();
}

public trait [T Any]Iterator {
    next(self Self ref) [T]Option;
}

public trait [T Any, I [T]Iterator]IntoIterator {
    iterator(self) I;
}

public let [T Any, I [T]Iterator]lazy(iter I) [T, I]Sequence = Sequence(iter);

public type [T Any, I [T]Iterator]Sequence(iter I);

given[T Any, I [T]Iterator] [T, I]Sequence {
    public [R Any]reduce(self, mut r R, f [R, T, R]Func) R = {
        for v = self then r = f(r, v);
        r
    }
    public filter(self, f [T, Bool]Func) [T, I]FilterSequence = FilterSequence(self, f);
    public [R Any]map(self, f [T, R]Func) [T, R, I]MapSequence = MapSequence(self, f);
}

public type [T Any, I [T]Iterator]FilterSequence(iter I, filter [T, Bool]Func);

given[T Any, I [T]Iterator] [T, I]FilterSequence {
    public next(self Self ref) [T]Option = 
        while self.iter.next() is .Some(v) then {
            if self.filter(v) then return .Some(v);
        } else .None();
}

public type [T Any, R Any, I [T]Iterator]MapSequence(iter I, mapper [T, R]Func);

given[T Any, R Any, I [T]Iterator] [T, R, I]MapSequence  {
    next(self Self ref) [R]Option = 
        if self.iter.next() is .Some(v) then .Some(mapper(v)) else .None();
}

public trait Equatable {
    equals(self Self ref, r Self ref) Bool;
}

public trait Comparable Equatable {
    compare(self Self ref, r Self ref) Int;
}

public let [T Comparable]max(a T, b T) T = if compare(a, b) > 0 then a else b;
public let [T Comparable]min(a T, b T) T = if compare(a, b) < 0 then a else b;
*/