
public intrinsic type Bool;
public intrinsic type Never;

public intrinsic type Int;
public intrinsic type Int8;
public intrinsic type Int16;
public intrinsic type Int32;
public intrinsic type Int64;

public intrinsic type UInt;
public intrinsic type UInt8;
public intrinsic type UInt16;
public intrinsic type UInt32;
public intrinsic type UInt64;

public intrinsic type Float32;
public intrinsic type Float64;

public intrinsic type [T Any]Pointer;

// Memory management primitives
public intrinsic let [T Any]ref_count(r T ref) Int;

// Allocates uninitialized memory for `capacity` number of elements.
// The caller is responsible for deallocating this memory later.
public intrinsic let [T Any]alloc_memory(capacity Int) [T]Pointer;

// Deallocates the memory pointed to by `ptr`.
// PRECONDITION: The memory must be deinitialized (i.e. uninitialized).
// If the memory contains values that need to be dropped, call `ptr.deinit()` first.
public intrinsic let [T Any]dealloc_memory(ptr [T]Pointer) Void;

// Copies `count` elements from `source` to `dest`.
// The memory regions must NOT overlap.
// PRECONDITION: Memory at `dest` must be uninitialized. `source` must be initialized.
// POSTCONDITION: Memory at `dest` is initialized. `source` remains initialized.
public intrinsic let [T Any]copy_memory(dest [T]Pointer, source [T]Pointer, count Int) Void;

// Moves `count` elements from `source` to `dest`.
// The memory regions may overlap.
// PRECONDITION: Memory at `dest` must be uninitialized. `source` must be initialized.
// POSTCONDITION: Memory at `dest` is initialized. Memory at `source` becomes uninitialized.
public intrinsic let [T Any]move_memory(dest [T]Pointer, source [T]Pointer, count Int) Void;

// String storage and COW String
public type StringStorage(mut data [UInt8]Pointer, mut len Int, mut cap Int);

given StringStorage {
    // [Compiler Protocol] drop releases underlying buffer
    __drop(self ref) = {
        dealloc_memory(self.data);
    };
};

public type String(mut storage StringStorage ref) Copy;

// Forward declarations for iterator helpers used in `given String`
public type StringSplitAsciiWhitespace(source String, mut index Int);
public type StringSplit(source String, sep String, mut index Int);
public type StringLines(source String, mut index Int);

// type Byte = UInt8;
// type Rune = UInt32;

// builtin
// trait Any {}

// Most pointer operations are available for Any type [T].
intrinsic given[T Any] [T]Pointer {
    // --- Access & Mutation ---

    // Initializes this pointerâ€™s memory with the given value.
    // This writes to *uninitialized* memory and does NOT drop any existing value.
    // POSTCONDITION: Memory at `self` is initialized.
    init(self, v T) Void;

    // Deinitializes the memory at `self`.
    // This drops the value and returns the memory to an uninitialized state.
    // PRECONDITION: Memory at `self` must be initialized.
    deinit(self) Void;

    // Accesses the value pointed to by `self` without removing or invalidating it.
    // Returns a reference of the value.
    // PRECONDITION: Memory at `self` must be initialized.
    // NOTE: This is the primitive operation used to implement `__at` for higher constructs.
    peek(self) T ref;

    // Retrieves the value from `self`, leaving the memory uninitialized.
    // Ideally used for moving values out of the pointer.
    // PRECONDITION: Memory at `self` must be initialized.
    // POSTCONDITION: Memory at `self` is uninitialized.
    take(self) T;

    // Replaces the value at `self` with `v`, returning the old value.
    // Neither the old value nor the new value is dropped.
    // PRECONDITION: Memory at `self` must be initialized.
    replace(self, v T) T;

    // --- Arithmetic ---

    // Returns a new pointer moved forward by `n` elements from `self`.
    // The offset is in units of T (stride), not bytes.
    offset(self, n Int) [T]Pointer;

    // Compiler protocol: Equatable
    __equals(self ref, other [T]Pointer ref) Bool;

    // Compiler protocol: Comparable
    __compare(self ref, other [T]Pointer ref) Int;
};

// ---------------- Primitive Equatable (intrinsic) ----------------

intrinsic given Bool {
    __equals(self ref, other Bool ref) Bool;
};

intrinsic given Int {
    __equals(self ref, other Int ref) Bool;
};
intrinsic given Int8 {
    __equals(self ref, other Int8 ref) Bool;
};
intrinsic given Int16 {
    __equals(self ref, other Int16 ref) Bool;
};
intrinsic given Int32 {
    __equals(self ref, other Int32 ref) Bool;
};
intrinsic given Int64 {
    __equals(self ref, other Int64 ref) Bool;
};

intrinsic given UInt {
    __equals(self ref, other UInt ref) Bool;
};
intrinsic given UInt8 {
    __equals(self ref, other UInt8 ref) Bool;
};
intrinsic given UInt16 {
    __equals(self ref, other UInt16 ref) Bool;
};
intrinsic given UInt32 {
    __equals(self ref, other UInt32 ref) Bool;
};
intrinsic given UInt64 {
    __equals(self ref, other UInt64 ref) Bool;
};

intrinsic given Float32 {
    __equals(self ref, other Float32 ref) Bool;
};
intrinsic given Float64 {
    __equals(self ref, other Float64 ref) Bool;
};

// ---------------- Primitive Comparable (intrinsic) ----------------

intrinsic given Bool {
    __compare(self ref, other Bool ref) Int;
};

intrinsic given Int {
    __compare(self ref, other Int ref) Int;
};
intrinsic given Int8 {
    __compare(self ref, other Int8 ref) Int;
};
intrinsic given Int16 {
    __compare(self ref, other Int16 ref) Int;
};
intrinsic given Int32 {
    __compare(self ref, other Int32 ref) Int;
};
intrinsic given Int64 {
    __compare(self ref, other Int64 ref) Int;
};

intrinsic given UInt {
    __compare(self ref, other UInt ref) Int;
};
intrinsic given UInt8 {
    __compare(self ref, other UInt8 ref) Int;
};
intrinsic given UInt16 {
    __compare(self ref, other UInt16 ref) Int;
};
intrinsic given UInt32 {
    __compare(self ref, other UInt32 ref) Int;
};
intrinsic given UInt64 {
    __compare(self ref, other UInt64 ref) Int;
};

intrinsic given Float32 {
    __compare(self ref, other Float32 ref) Int;
};
intrinsic given Float64 {
    __compare(self ref, other Float64 ref) Int;
};

// Temporary IO
public intrinsic let print_string(message String) Void;
public intrinsic let print_int(value Int) Void;
public intrinsic let print_bool(value Bool) Void;
public intrinsic let panic(message String) Never;
public intrinsic let exit(code Int) Never;
public intrinsic let abort() Never;

// Bit-level utilities (intrinsic)
// Used for stable hashing of floating point values.
public intrinsic let float32_bits(value Float32) UInt32;
public intrinsic let float64_bits(value Float64) UInt64;

// ---------------- Option ----------------
public type [T Any] Option {
    None();
    Some(value T);
};

given [T Any] [T]Option {
    public is_some(self ref) Bool = {
        deref self match {
            .Some(_) -> true;
            .None -> false;
        }
    }

    public is_none(self ref) Bool = {
        not self.is_some()
    }

    public unwrap(self) T = {
        self match {
            .Some(v) -> v;
            .None -> panic("Option.unwrap failed: value is None");
        }
    }

    public unwrap_or(self, default T) T = {
        self match {
            .Some(v) -> v;
            .None -> default;
        }
    }
};

// ---------------- Result ----------------
public type [T Any, E Any] Result {
    Ok(value T);
    Err(error E);
};

given [T Any, E Any] [T, E]Result {
    public is_ok(self ref) Bool = {
        deref self match {
            .Ok(_) -> true;
            .Err(_) -> false;
        }
    }

    public is_err(self ref) Bool = {
        not self.is_ok()
    }

    public unwrap(self) T = {
        self match {
            .Ok(v) -> v;
            .Err(_) -> panic("Result.unwrap failed: value is Err");
        }
    }

    public unwrap_err(self) E = {
        self match {
            .Ok(_) -> panic("Result.unwrap_err failed: value is Ok");
            .Err(e) -> e;
        }
    }
};

// ---------------- String ----------------

given String {
    // Unsafe constructor: does not validate UTF-8
    public from_utf8_bytes_unchecked(bytes [UInt8]Pointer, len Int) String = {
        let cap = len + 1; // keep room for trailing 0
        let data = [UInt8]alloc_memory(cap);
        copy_memory(data, bytes, len);
        data.offset(len).init(0);
        let storage = ref StringStorage(data, len, cap);
        String(storage)
    };

    public empty() String = {
        let data = [UInt8]alloc_memory(1);
        data.init(0);
        let storage = ref StringStorage(data, 0, 1);
        String(storage)
    };

    private is_ascii_space(b UInt8) Bool =
        b == " " or b == "\t" or b == "\n" or b == "\v" or b == "\f" or b == "\r";

    private bounds_check_read(self, index Int) Void = {
        if index < 0 or index > self.storage.len then { panic("String index out of bounds"); };
    };

    private bounds_check_write(self, index Int) Void = {
        if index < 0 or index >= self.storage.len then { panic("String index out of bounds"); };
    };

    private ensure_unique(self ref) Void = {
        if ref_count(self.storage) > 1 then {
            let old = self.storage;
            let new_data = [UInt8]alloc_memory(old.cap);
            copy_memory(new_data, old.data, old.len + 1); // copy including trailing 0
            let new_storage = ref StringStorage(new_data, old.len, old.cap);
            self.storage = new_storage;
        }
    };

    private ensure_capacity(self ref, min_cap Int) Void = {
        if self.storage.cap >= min_cap then { return; };
        let mut new_cap = self.storage.cap * 2;
        if new_cap < min_cap then { new_cap = min_cap; };

        let new_data = [UInt8]alloc_memory(new_cap);
        copy_memory(new_data, self.storage.data, self.storage.len + 1);
        let new_storage = ref StringStorage(new_data, self.storage.len, new_cap);
        self.storage = new_storage;
    };

    public count_byte(self) Int = self.storage.len;

    public is_empty(self) Bool = self.storage.len == 0;

    public get_byte(self, index Int) UInt8 = {
        self.bounds_check_read(index);
        deref self.storage.data.offset(index).peek()
    };

    public set_byte(self ref, index Int, value UInt8) Void = {
        self.bounds_check_write(index);
        self.ensure_unique();
        self.storage.data.offset(index).replace(value);
    };

    public push_byte(self ref, value UInt8) Void = {
        self.ensure_unique();
        let needed = self.storage.len + 2; // new byte + trailing 0
        self.ensure_capacity(needed);
        self.storage.data.offset(self.storage.len).init(value);
        self.storage.len = self.storage.len + 1;
        self.storage.data.offset(self.storage.len).replace(0);
    };

    public push(self ref, other String) Void = {
        let other_len = other.storage.len;
        self.ensure_unique();
        let needed = self.storage.len + other_len + 1;
        self.ensure_capacity(needed);
        let dest = self.storage.data.offset(self.storage.len);
        copy_memory(dest, other.storage.data, other_len);
        self.storage.len = self.storage.len + other_len;
        self.storage.data.offset(self.storage.len).replace(0);
    };

    public reserve_byte(self ref, capacity Int) Void = {
        self.ensure_unique();
        let need = capacity + 1;
        self.ensure_capacity(need);
    };

    public capacity_byte(self) Int = self.storage.cap - 1;

    public starts_with(self, prefix String) Bool = {
        if prefix.storage.len > self.storage.len then { return false; };
        let mut i = 0;
        while i < prefix.storage.len then {
            if self.get_byte(i) <> prefix.get_byte(i) then { return false; };
            i += 1;
        };
        true
    };

    public ends_with(self, suffix String) Bool = {
        let slen = suffix.storage.len;
        if slen > self.storage.len then { return false; };
        let offset = self.storage.len - slen;
        let mut i = 0;
        while i < slen then {
            if self.get_byte(offset + i) <> suffix.get_byte(i) then { return false; };
            i += 1;
        };
        true
    };

    public contains_byte(self, b UInt8) Bool = {
        self.first_index_of_byte(b) match {
            .Some(_) -> true;
            .None -> false
        }
    };

    public first_index_of_byte(self, b UInt8) [Int]Option = {
        let mut i = 0;
        while i < self.storage.len then {
            if self.get_byte(i) == b then { return [Int]Option.Some(i); };
            i += 1;
        };
        [Int]Option.None()
    };

    public last_index_of_byte(self, b UInt8) [Int]Option = {
        let mut i = self.storage.len;
        while i > 0 then {
            i -= 1;
            if self.get_byte(i) == b then { return [Int]Option.Some(i); };
        };
        [Int]Option.None()
    };

    private make_substring(self, start Int, len Int) String = {
        if start < 0 or len < 0 or start + len > self.storage.len then {
            panic("substring out of bounds");
        };
        let cap = len + 1;
        let data = [UInt8]alloc_memory(cap);
        copy_memory(data, self.storage.data.offset(start), len);
        data.offset(len).init(0);
        let storage = ref StringStorage(data, len, cap);
        String(storage)
    };

    public substring(self, start Int, len Int) String = self.make_substring(start, len);

    public trim_ascii_start(self) String = {
        let mut i = 0;
        while i < self.storage.len and String.is_ascii_space(self.get_byte(i)) then { i += 1; };
        self.make_substring(i, self.storage.len - i)
    };

    public trim_ascii_end(self) String = {
        let mut end = self.storage.len;
        while end > 0 and String.is_ascii_space(self.get_byte(end - 1)) then { end -= 1; };
        self.make_substring(0, end)
    };

    public trim_ascii_whitespace(self) String = {
        let head = self.trim_ascii_start();
        head.trim_ascii_end()
    };

    private to_lower_byte(b UInt8) UInt8 =
        if b >= 65 and b <= 90 then b + 32 else b;

    private to_upper_byte(b UInt8) UInt8 =
        if b >= 97 and b <= 122 then b - 32 else b;

    public to_ascii_lowercase(self) String = {
        let cap = self.storage.len + 1;
        let data = [UInt8]alloc_memory(cap);
        let mut i = 0;
        while i < self.storage.len then {
            data.offset(i).init(String.to_lower_byte(self.get_byte(i)));
            i += 1;
        };
        data.offset(self.storage.len).init(0);
        let storage = ref StringStorage(data, self.storage.len, cap);
        String(storage)
    };

    public to_ascii_uppercase(self) String = {
        let cap = self.storage.len + 1;
        let data = [UInt8]alloc_memory(cap);
        let mut i = 0;
        while i < self.storage.len then {
            data.offset(i).init(String.to_upper_byte(self.get_byte(i)));
            i += 1;
        };
        data.offset(self.storage.len).init(0);
        let storage = ref StringStorage(data, self.storage.len, cap);
        String(storage)
    };

    public to_ascii_title(self) String = {
        let cap = self.storage.len + 1;
        let data = [UInt8]alloc_memory(cap);
        let mut in_word = false;
        let mut i = 0;
        while i < self.storage.len then {
            let b = self.get_byte(i);
            if String.is_ascii_space(b) then {
                in_word = false;
                data.offset(i).init(b);
            } else {
                if not in_word then {
                    in_word = true;
                    data.offset(i).init(String.to_upper_byte(b));
                } else {
                    data.offset(i).init(String.to_lower_byte(b));
                }
            };
            i += 1;
        };
        data.offset(self.storage.len).init(0);
        let storage = ref StringStorage(data, self.storage.len, cap);
        String(storage)
    };

    public insert_byte(self ref, index Int, value UInt8) Void = {
        if index < 0 or index > self.storage.len then { panic("insert out of bounds"); };
        self.ensure_unique();
        let needed = self.storage.len + 2;
        self.ensure_capacity(needed);
        let src = self.storage.data.offset(index);
        let dest = self.storage.data.offset(index + 1);
        let count = self.storage.len - index + 1; // include trailing 0
        move_memory(dest, src, count);
        self.storage.data.offset(index).replace(value);
        self.storage.len = self.storage.len + 1;
    };

    public insert(self ref, index Int, value String) Void = {
        if index < 0 or index > self.storage.len then { panic("insert out of bounds"); };
        let vlen = value.storage.len;
        if vlen == 0 then { return; };
        self.ensure_unique();
        let needed = self.storage.len + vlen + 1;
        self.ensure_capacity(needed);
        let src = self.storage.data.offset(index);
        let dest = self.storage.data.offset(index + vlen);
        let count = self.storage.len - index + 1; // include trailing 0
        move_memory(dest, src, count);
        copy_memory(self.storage.data.offset(index), value.storage.data, vlen);
        self.storage.len = self.storage.len + vlen;
    };

    public remove_byte(self ref, index Int) UInt8 = {
        if index < 0 or index >= self.storage.len then { panic("remove out of bounds"); };
        self.ensure_unique();
        let old = deref self.storage.data.offset(index).peek();
        let dest = self.storage.data.offset(index);
        let src = self.storage.data.offset(index + 1);
        let count = self.storage.len - index; // include trailing 0
        move_memory(dest, src, count);
        self.storage.len = self.storage.len - 1;
        old
    };

    public pop_byte(self ref) [UInt8]Option =
        if self.storage.len == 0 then { [UInt8]Option.None() }
        else { [UInt8]Option.Some(self.remove_byte(self.storage.len - 1)) };

    public is_ascii(self) Bool = {
        let mut i = 0;
        while i < self.storage.len then {
            if self.get_byte(i) >= 128 then { return false; };
            i += 1;
        };
        true
    };

    public is_ascii_blank(self) Bool = {
        let mut i = 0;
        while i < self.storage.len then {
            let b = self.get_byte(i);
            if not String.is_ascii_space(b) then { return false; };
            i += 1;
        };
        true
    };

    public __equals(self ref, other String ref) Bool = {
        if self.storage.len <> other.storage.len then { return false; };
        let mut i = 0;
        while i < self.storage.len then {
            if self.get_byte(i) <> other.get_byte(i) then { return false; };
            i += 1;
        };
        true
    };

    public __compare(self ref, other String ref) Int = {
        let min = if self.storage.len < other.storage.len then self.storage.len else other.storage.len;
        let mut i = 0;
        while i < min then {
            let a = self.get_byte(i);
            let b = other.get_byte(i);
            if a < b then { return 0 - 1; };
            if a > b then { return 1; };
            i += 1;
        };
        if self.storage.len < other.storage.len then 0 - 1
        else if self.storage.len > other.storage.len then 1
        else 0
    };

    public find_from(self, pat String, start Int) [Int]Option = {
        if pat.storage.len == 0 then { panic("find empty pattern"); };
        if start < 0 or start > self.storage.len then { panic("find start out of bounds"); };
        let mut i = start;
        let max = self.storage.len - pat.storage.len;
        while i <= max then {
            let mut j = 0;
            let mut ok = true;
            while j < pat.storage.len then {
                if self.get_byte(i + j) <> pat.get_byte(j) then { ok = false; break; };
                j += 1;
            };
            if ok then { return [Int]Option.Some(i); };
            i += 1;
        };
        [Int]Option.None()
    };

    public find(self, pat String) [Int]Option = self.find_from(pat, 0);

    public contains(self, pat String) Bool = {
        self.find_from(pat, 0) match {
            .Some(_) -> true;
            .None -> false
        }
    };

    public count_string(self, pat String) Int = {
        let mut count = 0;
        let mut idxOpt = self.find_from(pat, 0);
        while true then {
            idxOpt match {
                .Some(i) -> {
                    count += 1;
                    idxOpt = self.find_from(pat, i + pat.storage.len);
                };
                .None -> { break; }
            };
        };
        count
    };

    public repeat(self, times Int) String = {
        if times < 0 then { panic("repeat negative"); };
        if times == 0 then { return String.empty(); };
        let total = self.storage.len * times;
        let cap = total + 1;
        let data = [UInt8]alloc_memory(cap);
        let mut offset = 0;
        let mut t = 0;
        while t < times then {
            copy_memory(data.offset(offset), self.storage.data, self.storage.len);
            offset += self.storage.len;
            t += 1;
        };
        data.offset(total).init(0);
        let storage = ref StringStorage(data, total, cap);
        String(storage)
    };

    public replace(self, pat String, with String) String = {
        if pat.storage.len == 0 then { panic("replace empty pattern"); };
        let mut result = String.empty();
        let mut start = 0;
        let mut idxOpt = self.find_from(pat, start);
        while true then {
            idxOpt match {
                .Some(idx) -> {
                    let prefix_len = idx - start;
                    if prefix_len > 0 then {
                        let slice = self.make_substring(start, prefix_len);
                        result.push(slice);
                    };
                    result.push(with);
                    start = idx + pat.storage.len;
                    idxOpt = self.find_from(pat, start);
                };
                .None -> { break; }
            };
        };
        if start < self.storage.len then {
            let tail = self.make_substring(start, self.storage.len - start);
            result.push(tail);
        };
        result
    };

    public split_ascii_whitespace(self) StringSplitAsciiWhitespace =
        StringSplitAsciiWhitespace(self, 0);

    public split(self, sep String) StringSplit = {
        if sep.storage.len == 0 then { panic("split empty separator"); };
        StringSplit(self, sep, 0)
    };

    public lines(self) StringLines = StringLines(self, 0);

    public remove_prefix(self, prefix String) String =
        if self.starts_with(prefix) then { self.make_substring(prefix.storage.len, self.storage.len - prefix.storage.len) } else { self }
    ;

    public remove_suffix(self, suffix String) String = {
        if self.ends_with(suffix) then {
            let remain = self.storage.len - suffix.storage.len;
            self.make_substring(0, remain)
        } else { self }
    };
};

given StringSplitAsciiWhitespace {
    public next(self ref) [String]Option = {
        let len = self.source.count_byte();
        let mut i = self.index;
        while i < len and String.is_ascii_space(self.source.get_byte(i)) then { i += 1; };
        if i >= len then { return [String]Option.None(); };
        let start = i;
        while i < len and not String.is_ascii_space(self.source.get_byte(i)) then { i += 1; };
        let part = self.source.substring(start, i - start);
        self.index = i;
        [String]Option.Some(part)
    };
};

given StringSplit {
    public next(self ref) [String]Option = {
        let len = self.source.count_byte();
        if self.index > len then { return [String]Option.None(); };
        let mut idxOpt = self.source.find_from(self.sep, self.index);
        idxOpt match {
            .Some(i) -> {
                let part = self.source.substring(self.index, i - self.index);
                self.index = i + self.sep.count_byte();
                [String]Option.Some(part)
            };
            .None -> {
                let part = self.source.substring(self.index, len - self.index);
                self.index = len + 1;
                [String]Option.Some(part)
            }
        }
    };
};

given StringLines {
    public next(self ref) [String]Option = {
        let len = self.source.count_byte();
        if self.index > len then { return [String]Option.None(); };
        // Do not yield a trailing empty line when the string ends with '\n'.
        if self.index == len then {
            self.index = len + 1;
            return [String]Option.None();
        };
        let mut iOpt = self.source.find_from("\n", self.index);
        iOpt match {
            .Some(i) -> {
                let part = self.source.substring(self.index, i - self.index);
                self.index = i + 1;
                [String]Option.Some(part)
            };
            .None -> {
                let part = self.source.substring(self.index, len - self.index);
                self.index = len + 1;
                [String]Option.Some(part)
            }
        }
    };
};

public type [T Copy]List(private mut source [T]Pointer, private mut len Int, private mut cap Int);

given[T Copy] [T]List {
    public new() Self = [T]List([T]alloc_memory(10), 0, 10);

    // [Compiler Protocol]
    // Automatically called when the object goes out of scope.
    // User code cannot call this directly.
    __drop(self ref) = {
        let mut i = 0;
        while i < self.len then {
            self.source.offset(i).deinit();
            i += 1;
        };
        dealloc_memory(self.source);
    }

    public copy(self ref) Self = {
        let new_ptr = [T]alloc_memory(self.cap);
        copy_memory(new_ptr, self.source, self.len);
        [T]List(new_ptr, self.len, self.cap)
    }

    public count(self ref) Int = self.len;

    // [Compiler Protocol]
    // Lowering target for `list[index]` in read context.
    // Returns a temporary reference to the element.
    public __at(self ref, index Int) T ref = {
        // Bounds check can be added here
        self.source.offset(index).peek()
    }

    // [Compiler Protocol]
    // Lowering target for `list[index] = value`.
    public __update_at(self ref, index Int, value T) Void = {
        // Replace element (handles ref-counted Copy types via init/deinit)
        self.source.offset(index).deinit();
        self.source.offset(index).init(value);
    }

    public push_back(self ref, value T) Void = {
         self.ensure_capacity(self.len + 1);
        self.source.offset(self.len).init(value);
        self.len = self.len + 1;
    }

    public insert(self ref, index Int, value T) Void = {
        self.ensure_capacity(self.len + 1);
        
        if index < self.len then {
            let src = self.source.offset(index);
            let dest = self.source.offset(index + 1);
            let count = self.len - index;
            move_memory(dest, src, count);
            self.source.offset(index).init(value);
        } else {
             self.source.offset(self.len).init(value);
        };
        self.len = self.len + 1;
    }

    public remove(self ref, index Int) Void = {
        // 1. Drop the element at index
        self.source.offset(index).deinit();
        
        // 2. Shift remaining elements down
        if index < self.len - 1 then {
            let src = self.source.offset(index + 1);
            let dest = self.source.offset(index);
            let count = self.len - 1 - index;
            
            // Move [index+1...len-1] to [index...len-2]
            move_memory(dest, src, count);
        };
        
        self.len = self.len - 1;
    }

    // Ensures the list is unique and has enough capacity
    private ensure_capacity(self ref, min_capacity Int) Void = {
         // Unique case - Grow if needed
         if min_capacity > self.cap then {
             let mut new_cap = self.cap * 2;
             if new_cap < min_capacity then {
                 new_cap = min_capacity;
             };
             
             let new_source = [T]alloc_memory(new_cap);
             move_memory(new_source, self.source, self.len);
             dealloc_memory(self.source);
             
             self.source = new_source;
             self.cap = new_cap;
         };
    }

    public iterator(self ref) [T]ListIterator = {
        // Capture a ref to the list instead of exposing raw Pointer
        [T]ListIterator(self, 0)
    };
};

// Iterator now holds a ref to the list to avoid exposing raw pointers
public type [T Copy]ListIterator(source [T]List ref, mut index Int);

given[T Copy] [T]ListIterator {
    public next(self ref) [T]Option = 
        if self.index < self.source.count() then {
            let val = self.source[self.index];
            self.index += 1;
            [T]Option.Some(val)
        } else {
            [T]Option.None()
        };
};

/*
NOTE: The iterator/sequence trait sketches below require *generic traits* and/or
trait method generics, which are not supported in trait v1 yet. Keep as design
notes until that feature lands.

public trait [T Any]Iterator {
    next(self Self ref) [T]Option;
}

public trait [T Any, I [T]Iterator]IntoIterator {
    iterator(self) I;
}

public let [T Any, I [T]Iterator]lazy(iter I) [T, I]Sequence = Sequence(iter);

public type [T Any, I [T]Iterator]Sequence(iter I);

given[T Any, I [T]Iterator] [T, I]Sequence {
    public [R Any]reduce(self, mut r R, f [R, T, R]Func) R = {
        for v = self then r = f(r, v);
        r
    }
    public filter(self, f [T, Bool]Func) [T, I]FilterSequence = FilterSequence(self, f);
    public [R Any]map(self, f [T, R]Func) [T, R, I]MapSequence = MapSequence(self, f);
}

public type [T Any, I [T]Iterator]FilterSequence(iter I, filter [T, Bool]Func);

given[T Any, I [T]Iterator] [T, I]FilterSequence {
    public next(self Self ref) [T]Option = 
        while self.iter.next() is .Some(v) then {
            if self.filter(v) then return .Some(v);
        } else .None();
}

public type [T Any, R Any, I [T]Iterator]MapSequence(iter I, mapper [T, R]Func);

given[T Any, R Any, I [T]Iterator] [T, R, I]MapSequence  {
    next(self Self ref) [R]Option = 
        if self.iter.next() is .Some(v) then .Some(mapper(v)) else .None();
}
*/

// ---------------- Traits (v1) ----------------

public trait Equatable {
    __equals(self ref, other Self ref) Bool;
};

// Hash utilities (UInt-only, no bitwise required)
public let hash_combine(seed UInt, value UInt) UInt = seed * 16777619 + value;

public trait Hashable Equatable {
    hash(self ref) UInt;
};

public trait Comparable Equatable {
    __compare(self ref, other Self ref) Int;
};

// ---------------- Hashable (std implementations) ----------------

given Bool {
    public hash(self ref) UInt = {
        let mut h UInt = 0;
        if deref self then { h = 1; };
        h
    };
};

// Identity hash for UInt.
given UInt {
    public hash(self ref) UInt = deref self;
};

// Hashes for smaller unsigned ints.
given UInt8 { public hash(self ref) UInt = (UInt)deref self; };
given UInt16 { public hash(self ref) UInt = (UInt)deref self; };
given UInt32 { public hash(self ref) UInt = (UInt)deref self; };

// Hash UInt64 by mixing low/high parts (portable even if UInt is 32-bit).
given UInt64 {
    public hash(self ref) UInt = {
        let v UInt64 = deref self;
        let lo UInt = (UInt)v;
        let hi UInt = (UInt){ v / (UInt64)4294967296 };
        hash_combine(hash_combine(0, lo), hi)
    };
};

// Minimal, deterministic String hash (currently length-based).
// This satisfies the Hashable contract (equal => same hash) and is a placeholder
// until numeric casts/bitwise ops across integer widths are available.
given String {
    // Deterministic byte-based hash.
    // Uses `hash_combine` so it doesn't require bitwise ops.
    public hash(self ref) UInt = {
        let s = deref self;
        let mut h UInt = 2166136261;
        let mut i Int = 0;
        while i < s.count_byte() then {
            let b UInt8 = s.get_byte(i);
            h = hash_combine(h, (UInt)b);
            i += 1;
        };
        h
    };
};

// Hashes for signed ints (cast to UInt keeps equality=>same-hash for the same type).
given Int { public hash(self ref) UInt = (UInt)deref self; };
given Int8 { public hash(self ref) UInt = (UInt)deref self; };
given Int16 { public hash(self ref) UInt = (UInt)deref self; };
given Int32 { public hash(self ref) UInt = (UInt)deref self; };

// Hash Int64 by mixing low/high parts.
given Int64 {
    public hash(self ref) UInt = {
        let v UInt64 = (UInt64)deref self;
        let lo UInt = (UInt)v;
        let hi UInt = (UInt){ v / (UInt64)4294967296 };
        hash_combine(hash_combine(0, lo), hi)
    };
};

// Hash floats via bit-pattern.
given Float32 {
    public hash(self ref) UInt = {
        let bits UInt32 = float32_bits(deref self);
        hash_combine(0, (UInt)bits)
    };
};

given Float64 {
    public hash(self ref) UInt = {
        let bits UInt64 = float64_bits(deref self);
        let lo UInt = (UInt)bits;
        let hi UInt = (UInt){ bits / (UInt64)4294967296 };
        hash_combine(hash_combine(0, lo), hi)
    };
};

given[T Any] [T]Pointer {
    public hash(self ref) UInt = (UInt)deref self;
};

public let [T Comparable]max(a T, b T) T = if a > b then a else b;
public let [T Comparable]min(a T, b T) T = if a < b then a else b;