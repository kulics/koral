// ============================================================================
// Koral Standard Library - Core Module
// ============================================================================

// ============================================================================
// SECTION 1: Primitive Types
// ============================================================================

public intrinsic type Bool
public intrinsic type Never

public intrinsic type Int
public intrinsic type Int8
public intrinsic type Int16
public intrinsic type Int32
public intrinsic type Int64

public intrinsic type UInt
public intrinsic type UInt8
public intrinsic type UInt16
public intrinsic type UInt32
public intrinsic type UInt64

public intrinsic type Float32
public intrinsic type Float64

public intrinsic type [T Any]Pointer

// ============================================================================
// SECTION 2: Memory Management Primitives
// ============================================================================

public intrinsic let [T Any]ref_count(r T ref) Int

// Allocates uninitialized memory for `capacity` number of elements.
public intrinsic let [T Any]alloc_memory(capacity Int) [T]Pointer

// Deallocates the memory pointed to by `ptr`.
// PRECONDITION: The memory must be deinitialized.
public intrinsic let [T Any]dealloc_memory(ptr [T]Pointer) Void

// Copies `count` elements from `source` to `dest`. Regions must NOT overlap.
public intrinsic let [T Any]copy_memory(dest [T]Pointer, source [T]Pointer, count Int) Void

// Moves `count` elements from `source` to `dest`. Regions may overlap.
public intrinsic let [T Any]move_memory(dest [T]Pointer, source [T]Pointer, count Int) Void

// ============================================================================
// SECTION 3: Pointer Operations
// ============================================================================

intrinsic given[T Any] [T]Pointer {
    // Initializes this pointer's memory with the given value.
    init(self, v T) Void

    // Deinitializes the memory at `self`.
    deinit(self) Void

    // Accesses the value pointed to by `self` without removing it.
    peek(self) T

    // Retrieves the value from `self`, leaving the memory uninitialized.
    take(self) T

    // Replaces the value at `self` with `v`, returning the old value.
    replace(self, v T) T

    // Returns a new pointer moved forward by `n` elements.
    offset(self, n Int) [T]Pointer

    // Compiler protocol: Equatable
    __equals(self, other [T]Pointer) Bool

    // Compiler protocol: Comparable
    __compare(self, other [T]Pointer) Int
    
    // Returns the bit width of pointers on the current platform (32 or 64)
    bits() Int
}

// ============================================================================
// SECTION 4: Primitive Equatable (intrinsic)
// ============================================================================

intrinsic given Bool { __equals(self, other Bool) Bool }

intrinsic given Int { __equals(self, other Int) Bool }
intrinsic given Int8 { __equals(self, other Int8) Bool }
intrinsic given Int16 { __equals(self, other Int16) Bool }
intrinsic given Int32 { __equals(self, other Int32) Bool }
intrinsic given Int64 { __equals(self, other Int64) Bool }

intrinsic given UInt { __equals(self, other UInt) Bool }
intrinsic given UInt8 { __equals(self, other UInt8) Bool }
intrinsic given UInt16 { __equals(self, other UInt16) Bool }
intrinsic given UInt32 { __equals(self, other UInt32) Bool }
intrinsic given UInt64 { __equals(self, other UInt64) Bool }

intrinsic given Float32 { __equals(self, other Float32) Bool }
intrinsic given Float64 { __equals(self, other Float64) Bool }

// ============================================================================
// SECTION 5: Primitive Comparable (intrinsic)
// ============================================================================

intrinsic given Bool { __compare(self, other Bool) Int }

intrinsic given Int { __compare(self, other Int) Int }
intrinsic given Int8 { __compare(self, other Int8) Int }
intrinsic given Int16 { __compare(self, other Int16) Int }
intrinsic given Int32 { __compare(self, other Int32) Int }
intrinsic given Int64 { __compare(self, other Int64) Int }

intrinsic given UInt { __compare(self, other UInt) Int }
intrinsic given UInt8 { __compare(self, other UInt8) Int }
intrinsic given UInt16 { __compare(self, other UInt16) Int }
intrinsic given UInt32 { __compare(self, other UInt32) Int }
intrinsic given UInt64 { __compare(self, other UInt64) Int }

intrinsic given Float32 { __compare(self, other Float32) Int }
intrinsic given Float64 { __compare(self, other Float64) Int }

// ============================================================================
// SECTION 6: IO and Utility Intrinsics
// ============================================================================

public intrinsic let exit(code Int) Never
public intrinsic let abort() Never

// Low-level IO intrinsics (minimal set using file descriptors)
// File descriptor constants: std_in = 0, std_out = 1, std_err = 2
intrinsic let fwrite(ptr [UInt8]Pointer, len Int, fd Int) Int  // returns bytes written
intrinsic let fgetc(fd Int) Int  // returns char (0-255) or -1 for EOF
intrinsic let fflush(fd Int) Void

// File descriptor constants (internal use only)
let std_in Int = 0
let std_out Int = 1
let std_err Int = 2

// ============================================================================
// SECTION 7: Float Bit Manipulation Intrinsics
// ============================================================================

intrinsic given Float32 {
    public to_bits(self) UInt32
    public from_bits(bits UInt32) Float32
}

intrinsic given Float64 {
    public to_bits(self) UInt64
    public from_bits(bits UInt64) Float64
}

// ============================================================================
// SECTION 8: Traits
// ============================================================================

public trait Equatable {
    __equals(self, other Self) Bool
}

public trait Comparable Equatable {
    __compare(self, other Self) Int
}

// Hash utilities
public let hash_combine(seed UInt, value UInt) UInt = {
    let magic UInt = 2654435769  // 0x9e3779b9
    seed bitxor {value + magic + {seed bitshl 6} + {seed bitshr 2}}
}

public trait Hashable Equatable {
    hash(self) UInt
}

public trait ToString {
    to_string(self) String
}

// ============================================================================
// SECTION 9: Primitive Hashable Implementations (hash only)
// ============================================================================
// NOTE: to_string implementations are in SECTION 12B after String is defined

given Bool {
    public hash(self) UInt = {
        let mut h UInt = 0
        if self then { h = 1; }
        h
    }
}

given UInt {
    public hash(self) UInt = self
}

given UInt8 {
    public hash(self) UInt = (UInt)self
}

given UInt16 {
    public hash(self) UInt = (UInt)self
}

given UInt32 {
    public hash(self) UInt = (UInt)self
}

given UInt64 {
    public hash(self) UInt = {
        let v UInt64 = self
        let lo UInt = (UInt)v
        let hi UInt = (UInt){ v / (UInt64)4294967296 }
        hash_combine(hash_combine(0, lo), hi)
    }
}

given Int {
    public hash(self) UInt = (UInt)self
}

given Int8 {
    public hash(self) UInt = (UInt)self
}

given Int16 {
    public hash(self) UInt = (UInt)self
}

given Int32 {
    public hash(self) UInt = (UInt)self
}

given Int64 {
    public hash(self) UInt = {
        let v UInt64 = (UInt64)self
        let lo UInt = (UInt)v
        let hi UInt = (UInt){ v / (UInt64)4294967296 }
        hash_combine(hash_combine(0, lo), hi)
    }
}

given Float32 {
    public hash(self) UInt = {
        let bits UInt32 = self.to_bits()
        hash_combine(0, (UInt)bits)
    }
}

given Float64 {
    public hash(self) UInt = {
        let bits UInt64 = self.to_bits()
        let lo UInt = (UInt)bits
        let hi UInt = (UInt){ bits / 4294967296u64 }
        hash_combine(hash_combine(0, lo), hi)
    }
}

given[T Any] [T]Pointer {
    public hash(self) UInt = (UInt)self
}

// ============================================================================
// SECTION 10: Option Type
// ============================================================================

public type [T Any] Option {
    None(),
    Some(value T),
}

given [T Any] [T]Option {
    public is_some(self) Bool = {
        when self is {
            .Some(_) then true,
            .None then false,
        }
    }

    public is_none(self) Bool = not self.is_some()

    public unwrap(self) T = {
        when self is {
            .Some(v) then v,
            .None then panic("Option.unwrap failed: value is None"),
        }
    }

    public unwrap_or(self, default T) T = {
        when self is {
            .Some(v) then v,
            .None then default,
        }
    }
}

// ============================================================================
// SECTION 11: Result Type
// ============================================================================

public type [T Any, E Any] Result {
    Ok(value T),
    Err(error E),
}

given [T Any, E Any] [T, E]Result {
    public is_ok(self) Bool = {
        when self is {
            .Ok(_) then true,
            .Err(_) then false,
        }
    }

    public is_err(self) Bool = not self.is_ok()

    public unwrap(self) T = {
        when self is {
            .Ok(v) then v,
            .Err(_) then panic("Result.unwrap failed: value is Err"),
        }
    }

    public unwrap_err(self) E = {
        when self is {
            .Ok(_) then panic("Result.unwrap_err failed: value is Ok"),
            .Err(e) then e,
        }
    }
}

// ============================================================================
// SECTION 12: String Type
// ============================================================================

// Internal storage for String (COW semantics)
public type StringStorage(mut data [UInt8]Pointer, mut len Int, mut cap Int)

given StringStorage {
    __drop(self ref) = { dealloc_memory(self.data) }
}

// String type with COW semantics
public type String(mut storage StringStorage ref)

// Forward declarations for String iterators
public type StringSplitAsciiWhitespace(source String, mut index Int)
public type StringSplit(source String, sep String, mut index Int)
public type StringLines(source String, mut index Int)

given String {
    // Unsafe constructor: does not validate UTF-8
    public from_utf8_bytes_unchecked(bytes [UInt8]Pointer, len Int) String = {
        let cap = len + 1
        let data = [UInt8]alloc_memory(cap)
        copy_memory(data, bytes, len)
        data.offset(len).init(0)
        let storage = ref StringStorage(data, len, cap)
        String(storage)
    }

    public empty() String = {
        let data = [UInt8]alloc_memory(1)
        data.init(0)
        let storage = ref StringStorage(data, 0, 1)
        String(storage)
    }

    public with_capacity(capacity Int) String = {
        let cap = if capacity < 1 then 1 else capacity + 1
        let data = [UInt8]alloc_memory(cap)
        data.init(0)
        let storage = ref StringStorage(data, 0, cap)
        String(storage)
    }

    private is_ascii_space(b UInt8) Bool =
        b == " " or b == "\t" or b == "\n" or b == "\v" or b == "\f" or b == "\r"

    private bounds_check_read(self, index Int) Void = {
        if index < 0 or index > self.storage.len then {
            panic("String index out of bounds")
        }
    }

    private bounds_check_write(self, index Int) Void = {
        if index < 0 or index >= self.storage.len then {
            panic("String index out of bounds")
        }
    }

    private ensure_unique(self ref) Void = {
        if ref_count(self.storage) > 1 then {
            let old = self.storage
            let new_data = [UInt8]alloc_memory(old.cap)
            copy_memory(new_data, old.data, old.len + 1)
            let new_storage = ref StringStorage(new_data, old.len, old.cap)
            self.storage = new_storage
        }
    }

    private ensure_capacity(self ref, min_cap Int) Void = {
        if self.storage.cap >= min_cap then { return; }
        let mut new_cap = self.storage.cap * 2
        if new_cap < min_cap then { new_cap = min_cap; }
        let new_data = [UInt8]alloc_memory(new_cap)
        copy_memory(new_data, self.storage.data, self.storage.len + 1)
        let new_storage = ref StringStorage(new_data, self.storage.len, new_cap)
        self.storage = new_storage
    }

    public count_byte(self) Int = self.storage.len
    public is_empty(self) Bool = self.storage.len == 0
    public capacity_byte(self) Int = self.storage.cap - 1

    public get_byte(self, index Int) UInt8 = {
        self.bounds_check_read(index)
        self.storage.data.offset(index).peek()
    }

    public set_byte(self ref, index Int, value UInt8) Void = {
        self.bounds_check_write(index)
        self.ensure_unique()
        self.storage.data.offset(index).replace(value);
    }

    public push_byte(self ref, value UInt8) Void = {
        self.ensure_unique()
        let needed = self.storage.len + 2
        self.ensure_capacity(needed)
        self.storage.data.offset(self.storage.len).init(value)
        self.storage.len = self.storage.len + 1
        self.storage.data.offset(self.storage.len).replace(0);
    }

    public push(self ref, other String) Void = {
        let other_len = other.storage.len
        self.ensure_unique()
        let needed = self.storage.len + other_len + 1
        self.ensure_capacity(needed)
        let dest = self.storage.data.offset(self.storage.len)
        copy_memory(dest, other.storage.data, other_len)
        self.storage.len = self.storage.len + other_len
        self.storage.data.offset(self.storage.len).replace(0);
    }

    public reserve_byte(self ref, capacity Int) Void = {
        self.ensure_unique()
        self.ensure_capacity(capacity + 1)
    }

    public starts_with(self, prefix String) Bool = {
        if prefix.storage.len > self.storage.len then { return false; }
        let mut i = 0
        while i < prefix.storage.len then {
            if self.get_byte(i) <> prefix.get_byte(i) then { return false; }
            i += 1
        }
        true
    }

    public ends_with(self, suffix String) Bool = {
        let slen = suffix.storage.len
        if slen > self.storage.len then { return false; }
        let offset = self.storage.len - slen
        let mut i = 0
        while i < slen then {
            if self.get_byte(offset + i) <> suffix.get_byte(i) then { return false; }
            i += 1
        }
        true
    }

    public contains_byte(self, b UInt8) Bool = {
        when self.first_index_of_byte(b) is {
            .Some(_) then true,
            .None then false,
        }
    }

    public first_index_of_byte(self, b UInt8) [Int]Option = {
        let mut i = 0
        while i < self.storage.len then {
            if self.get_byte(i) == b then { return [Int]Option.Some(i); }
            i += 1
        }
        [Int]Option.None()
    }

    public last_index_of_byte(self, b UInt8) [Int]Option = {
        let mut i = self.storage.len
        while i > 0 then {
            i -= 1
            if self.get_byte(i) == b then { return [Int]Option.Some(i); }
        }
        [Int]Option.None()
    }

    private make_substring(self, start Int, len Int) String = {
        if start < 0 or len < 0 or start + len > self.storage.len then {
            panic("substring out of bounds")
        }
        let cap = len + 1
        let data = [UInt8]alloc_memory(cap)
        copy_memory(data, self.storage.data.offset(start), len)
        data.offset(len).init(0)
        let storage = ref StringStorage(data, len, cap)
        String(storage)
    }

    public substring(self, start Int, len Int) String = self.make_substring(start, len)

    public trim_ascii_start(self) String = {
        let mut i = 0
        while i < self.storage.len and String.is_ascii_space(self.get_byte(i)) then { i += 1; }
        self.make_substring(i, self.storage.len - i)
    }

    public trim_ascii_end(self) String = {
        let mut end = self.storage.len
        while end > 0 and String.is_ascii_space(self.get_byte(end - 1)) then { end -= 1; }
        self.make_substring(0, end)
    }

    public trim_ascii_whitespace(self) String = {
        let head = self.trim_ascii_start()
        head.trim_ascii_end()
    }

    private to_lower_byte(b UInt8) UInt8 =
        if b >= 65 and b <= 90 then b + 32 else b

    private to_upper_byte(b UInt8) UInt8 =
        if b >= 97 and b <= 122 then b - 32 else b

    public to_ascii_lowercase(self) String = {
        let cap = self.storage.len + 1
        let data = [UInt8]alloc_memory(cap)
        let mut i = 0
        while i < self.storage.len then {
            data.offset(i).init(String.to_lower_byte(self.get_byte(i)))
            i += 1
        }
        data.offset(self.storage.len).init(0)
        let storage = ref StringStorage(data, self.storage.len, cap)
        String(storage)
    }

    public to_ascii_uppercase(self) String = {
        let cap = self.storage.len + 1
        let data = [UInt8]alloc_memory(cap)
        let mut i = 0
        while i < self.storage.len then {
            data.offset(i).init(String.to_upper_byte(self.get_byte(i)))
            i += 1
        }
        data.offset(self.storage.len).init(0)
        let storage = ref StringStorage(data, self.storage.len, cap)
        String(storage)
    }

    public to_ascii_title(self) String = {
        let cap = self.storage.len + 1
        let data = [UInt8]alloc_memory(cap)
        let mut in_word = false
        let mut i = 0
        while i < self.storage.len then {
            let b = self.get_byte(i)
            if String.is_ascii_space(b) then {
                in_word = false
                data.offset(i).init(b)
            } else {
                if not in_word then {
                    in_word = true
                    data.offset(i).init(String.to_upper_byte(b))
                } else {
                    data.offset(i).init(String.to_lower_byte(b))
                }
            }
            i += 1
        }
        data.offset(self.storage.len).init(0)
        let storage = ref StringStorage(data, self.storage.len, cap)
        String(storage)
    }

    public insert_byte(self ref, index Int, value UInt8) Void = {
        if index < 0 or index > self.storage.len then {
            panic("insert out of bounds")
        }
        self.ensure_unique()
        let needed = self.storage.len + 2
        self.ensure_capacity(needed)
        let src = self.storage.data.offset(index)
        let dest = self.storage.data.offset(index + 1)
        let count = self.storage.len - index + 1
        move_memory(dest, src, count)
        self.storage.data.offset(index).replace(value)
        self.storage.len = self.storage.len + 1
    }

    public insert(self ref, index Int, value String) Void = {
        if index < 0 or index > self.storage.len then {
            panic("insert out of bounds")
        }
        let vlen = value.storage.len
        if vlen == 0 then { return; }
        self.ensure_unique()
        let needed = self.storage.len + vlen + 1
        self.ensure_capacity(needed)
        let src = self.storage.data.offset(index)
        let dest = self.storage.data.offset(index + vlen)
        let count = self.storage.len - index + 1
        move_memory(dest, src, count)
        copy_memory(self.storage.data.offset(index), value.storage.data, vlen)
        self.storage.len = self.storage.len + vlen
    }

    public remove_byte(self ref, index Int) UInt8 = {
        if index < 0 or index >= self.storage.len then {
            panic("remove out of bounds")
        }
        self.ensure_unique()
        let old = self.storage.data.offset(index).peek()
        let dest = self.storage.data.offset(index)
        let src = self.storage.data.offset(index + 1)
        let count = self.storage.len - index
        move_memory(dest, src, count)
        self.storage.len = self.storage.len - 1
        old
    }

    public pop_byte(self ref) [UInt8]Option =
        if self.storage.len == 0 then { [UInt8]Option.None() }
        else { [UInt8]Option.Some(self.remove_byte(self.storage.len - 1)) }

    public is_ascii(self) Bool = {
        let mut i = 0
        while i < self.storage.len then {
            if self.get_byte(i) >= 128 then { return false; }
            i += 1
        }
        true
    }

    public is_ascii_blank(self) Bool = {
        let mut i = 0
        while i < self.storage.len then {
            if not String.is_ascii_space(self.get_byte(i)) then { return false; }
            i += 1
        }
        true
    }

    public __equals(self, other String) Bool = {
        if self.storage.len <> other.storage.len then { return false; }
        let mut i = 0
        while i < self.storage.len then {
            if self.get_byte(i) <> other.get_byte(i) then { return false; }
            i += 1
        }
        true
    }

    public __compare(self, other String) Int = {
        let min = if self.storage.len < other.storage.len then self.storage.len else other.storage.len
        let mut i = 0
        while i < min then {
            let a = self.get_byte(i)
            let b = other.get_byte(i)
            if a < b then { return 0 - 1; }
            if a > b then { return 1; }
            i += 1
        }
        if self.storage.len < other.storage.len then 0 - 1
        else if self.storage.len > other.storage.len then 1
        else 0
    }

    public hash(self) UInt = {
        let mut h UInt = 2166136261
        let mut i Int = 0
        while i < self.count_byte() then {
            let b UInt8 = self.get_byte(i)
            h = hash_combine(h, (UInt)b)
            i += 1
        }
        h
    }

    public to_string(self) String = self

    public find_from(self, pat String, start Int) [Int]Option = {
        if pat.storage.len == 0 then {
            panic("find empty pattern")
        }
        if start < 0 or start > self.storage.len then {
            panic("find start out of bounds")
        }
        let mut i = start
        let max = self.storage.len - pat.storage.len
        while i <= max then {
            let mut j = 0
            let mut ok = true
            while j < pat.storage.len then {
                if self.get_byte(i + j) <> pat.get_byte(j) then { ok = false; break; }
                j += 1
            }
            if ok then { return [Int]Option.Some(i); }
            i += 1
        }
        [Int]Option.None()
    }

    public find(self, pat String) [Int]Option = self.find_from(pat, 0)

    public contains(self, pat String) Bool = {
        when self.find_from(pat, 0) is {
            .Some(_) then true,
            .None then false,
        }
    }

    public count_string(self, pat String) Int = {
        let mut count = 0
        let mut idxOpt = self.find_from(pat, 0)
        while true then {
            when idxOpt is {
                .Some(i) then {
                    count += 1
                    idxOpt = self.find_from(pat, i + pat.storage.len)
                },
                .None then { break },
            }
        }
        count
    }

    public repeat(self, times Int) String = {
        if times < 0 then {
            panic("repeat negative")
        }
        if times == 0 then { return String.empty(); }
        let total = self.storage.len * times
        let cap = total + 1
        let data = [UInt8]alloc_memory(cap)
        let mut offset = 0
        let mut t = 0
        while t < times then {
            copy_memory(data.offset(offset), self.storage.data, self.storage.len)
            offset += self.storage.len
            t += 1
        }
        data.offset(total).init(0)
        let storage = ref StringStorage(data, total, cap)
        String(storage)
    }

    public replace(self, pat String, with String) String = {
        if pat.storage.len == 0 then {
            panic("replace empty pattern")
        }
        let mut result = String.empty()
        let mut start = 0
        let mut idxOpt = self.find_from(pat, start)
        while true then {
            when idxOpt is {
                .Some(idx) then {
                    let prefix_len = idx - start
                    if prefix_len > 0 then {
                        let slice = self.make_substring(start, prefix_len)
                        result.push(slice)
                    }
                    result.push(with)
                    start = idx + pat.storage.len
                    idxOpt = self.find_from(pat, start)
                },
                .None then { break },
            }
        }
        if start < self.storage.len then {
            let tail = self.make_substring(start, self.storage.len - start)
            result.push(tail)
        }
        result
    }

    public split_ascii_whitespace(self) StringSplitAsciiWhitespace =
        StringSplitAsciiWhitespace(self, 0)

    public split(self, sep String) StringSplit = {
        if sep.storage.len == 0 then {
            panic("split empty separator")
        }
        StringSplit(self, sep, 0)
    }

    public lines(self) StringLines = StringLines(self, 0)

    public remove_prefix(self, prefix String) String =
        if self.starts_with(prefix) then { self.make_substring(prefix.storage.len, self.storage.len - prefix.storage.len) } else { self }

    public remove_suffix(self, suffix String) String = {
        if self.ends_with(suffix) then {
            let remain = self.storage.len - suffix.storage.len
            self.make_substring(0, remain)
        } else { self }
    }
}

// String iterator implementations
given StringSplitAsciiWhitespace {
    public next(self ref) [String]Option = {
        let len = self.source.count_byte()
        let mut i = self.index
        while i < len and String.is_ascii_space(self.source.get_byte(i)) then { i += 1; }
        if i >= len then { return [String]Option.None(); }
        let start = i
        while i < len and not String.is_ascii_space(self.source.get_byte(i)) then { i += 1; }
        let part = self.source.substring(start, i - start)
        self.index = i
        [String]Option.Some(part)
    }
}

given StringSplit {
    public next(self ref) [String]Option = {
        let len = self.source.count_byte()
        if self.index > len then { return [String]Option.None() }
        let mut idxOpt = self.source.find_from(self.sep, self.index)
        when idxOpt is {
            .Some(i) then {
                let part = self.source.substring(self.index, i - self.index)
                self.index = i + self.sep.count_byte()
                [String]Option.Some(part)
            },
            .None then {
                let part = self.source.substring(self.index, len - self.index)
                self.index = len + 1
                [String]Option.Some(part)
            },
        }
    }
}

given StringLines {
    public next(self ref) [String]Option = {
        let len = self.source.count_byte()
        if self.index > len then { return [String]Option.None() }
        if self.index == len then {
            self.index = len + 1
            return [String]Option.None()
        }
        let mut iOpt = self.source.find_from("\n", self.index)
        when iOpt is {
            .Some(i) then {
                let part = self.source.substring(self.index, i - self.index)
                self.index = i + 1
                [String]Option.Some(part)
            },
            .None then {
                let part = self.source.substring(self.index, len - self.index)
                self.index = len + 1
                [String]Option.Some(part)
            },
        }
    }
}

// ============================================================================
// SECTION 12A: Panic and Assertion (requires String)
// ============================================================================

// High-level panic function (uses String)
public let panic(message String) Never = {
    // Write "Panic: " prefix
    let prefix = "Panic: "
    fwrite(prefix.storage.data, prefix.storage.len, std_err);
    // Write message
    fwrite(message.storage.data, message.storage.len, std_err);
    // Write newline
    let newline = "\n"
    fwrite(newline.storage.data, newline.storage.len, std_err);
    // Flush stderr
    fflush(std_err);
    // Exit with error code
    exit(1)
}

public let assert(condition Bool, message String) Void = {
    if not condition then { panic(message) }
}

// ============================================================================
// SECTION 12B: Primitive ToString Implementations (requires String)
// ============================================================================

given Bool {
    public to_string(self) String = if self then "true" else "false"
}

given Int {
    public to_string(self) String = {
        if self == 0 then { return "0"; }
    
        let mut n = self
        let is_negative = n < 0
        if is_negative then { n = 0 - n; }
    
        // Extract digits in reverse order into buffer (21 bytes: max 19 digits + sign + null)
        let buf = [UInt8]alloc_memory(21)
        let mut pos = 20
        buf.offset(pos).init(0)  // null terminator
        while n > 0 then {
            pos -= 1
            buf.offset(pos).init((UInt8){ n % 10 } + '0')
            n = n / 10
        }
    
        // Add sign if negative
        if is_negative then {
            pos -= 1
            buf.offset(pos).init('-')
        }
        
        // Use buf directly, shifting content to start
        let len = 20 - pos
        if pos > 0 then {
            move_memory(buf, buf.offset(pos), len + 1)
        }
        let storage = ref StringStorage(buf, len, 21)
        String(storage)
    }
    
    // Int max: unsigned max >> 1 (clear sign bit)
    // Int min: ~max (two's complement)
    public max() Int = (Int){ (bitnot 0u) bitshr 1 }
    public min() Int = bitnot Int.max()
}

given Int8 {
    public to_string(self) String = {
        let n = (Int)self
        n.to_string()
    }
    // Int8 max: unsigned max >> 1
    // Int8 min: ~max
    public max() Int8 = (Int8){ (bitnot 0u8) bitshr 1 }
    public min() Int8 = bitnot Int8.max()
}

given Int16 {
    public to_string(self) String = {
        let n = (Int)self
        n.to_string()
    }
    // Int16 max: unsigned max >> 1
    // Int16 min: ~max
    public max() Int16 = (Int16){ (bitnot 0u16) bitshr 1 }
    public min() Int16 = bitnot Int16.max()
}

given Int32 {
    public to_string(self) String = {
        let n = (Int)self
        n.to_string()
    }
    // Int32 max: unsigned max >> 1
    // Int32 min: ~max
    public max() Int32 = (Int32){ (bitnot 0u32) bitshr 1 }
    public min() Int32 = bitnot Int32.max()
}

given Int64 {
    public to_string(self) String = {
        let n = (Int)self
        n.to_string()
    }
    // Int64 max: unsigned max >> 1
    // Int64 min: ~max
    public max() Int64 = (Int64){ (bitnot 0u64) bitshr 1 }
    public min() Int64 = bitnot Int64.max()
}

given UInt {
    public to_string(self) String = {
        if self == (UInt)0 then { return "0"; }
        
        let mut n = self
    
        // Extract digits in reverse order into buffer (21 bytes: max 20 digits + null)
        let buf = [UInt8]alloc_memory(21)
        let mut pos = 20
        buf.offset(pos).init(0)  // null terminator
        while n > (UInt)0 then {
            pos -= 1
            buf.offset(pos).init((UInt8){ n % (UInt)10 } + '0')
            n = n / (UInt)10
        }
    
        // Use buf directly, shifting content to start
        let len = 20 - pos
        if pos > 0 then {
            move_memory(buf, buf.offset(pos), len + 1)
        }
        let storage = ref StringStorage(buf, len, 21)
        String(storage)
    }
    
    // UInt max: all bits set (UInt is 64-bit on this platform)
    public max() UInt = bitnot 0u
    public min() UInt = 0u
}

given UInt8 {
    public to_string(self) String = {
        let n = (UInt)self
        n.to_string()
    }
    // UInt8 max: all bits set = 255
    public max() UInt8 = bitnot 0u8
    public min() UInt8 = 0u8
}

given UInt16 {
    public to_string(self) String = {
        let n = (UInt)self
        n.to_string()
    }
    // UInt16 max: all bits set = 65535
    public max() UInt16 = bitnot 0u16
    public min() UInt16 = 0u16
}

given UInt32 {
    public to_string(self) String = {
        let n = (UInt)self
        n.to_string()
    }
    // UInt32 max: all bits set = 4294967295
    public max() UInt32 = bitnot 0u32
    public min() UInt32 = 0u32
}

given UInt64 {
    public to_string(self) String = {
        let n = (UInt)self
        n.to_string()
    }
    // UInt64 max: all bits set
    public max() UInt64 = bitnot 0u64
    public min() UInt64 = 0u64
}

given Float32 {
    public to_string(self) String = {
        // Handle special cases
        let bits = self.to_bits()
        let exp = { bits bitshr 23 } bitand 255u32
        let mantissa = bits bitand 8388607u32  // 0x7FFFFF
        if exp == 255u32 then {
            if mantissa <> 0u32 then { return "NaN"; }
            if { bits bitshr 31 } == 1u32 then { return "-Inf"; }
            return "Inf"
        }
        
        let is_negative = { bits bitshr 31 } == 1u32
        let mut f = if is_negative then 0.0 - (Float64)self else (Float64)self
        
        let int_part = (Int)f
        let frac_part = f - (Float64)int_part
        
        let mut result = String.empty()
        if is_negative then { result.push_byte('-'); }
        
        result.push(int_part.to_string())
        result.push_byte('.')
        
        let mut frac = frac_part
        let mut digits = 0
        while digits < 6 then {
            frac = frac * 10.0
            let d = (Int)frac
            result.push_byte((UInt8)d + '0')
            frac = frac - (Float64)d
            digits += 1
        }
        
        result
    }
    
    // Static constants via bit manipulation using intrinsic
    // Inf: exp=255, mantissa=0, sign=0 -> 0x7F800000
    public inf() Float32 = Float32.from_bits(2139095040u32)
    
    // NaN: exp=255, mantissa!=0 -> 0x7FC00000 (quiet NaN)
    public nan() Float32 = Float32.from_bits(2143289344u32)
    
    // Min normal: exp=1, mantissa=0 -> 0x00800000 = 1.17549435e-38
    public min_normal() Float32 = Float32.from_bits(8388608u32)
    
    // Min denormal: exp=0, mantissa=1 -> 0x00000001 = 1.4013e-45
    public min_denormal() Float32 = Float32.from_bits(1u32)
    
    // Max finite: exp=254, mantissa=all 1s -> 0x7F7FFFFF = 3.4028235e+38
    public max() Float32 = Float32.from_bits(2139095039u32)
    
    // Min finite (most negative): -max -> 0xFF7FFFFF
    public min() Float32 = Float32.from_bits(4286578687u32)
    
    // Instance methods
    public is_nan(self) Bool = {
        let bits = self.to_bits()
        let exp = { bits bitshr 23 } bitand 255u32
        let mantissa = bits bitand 8388607u32
        exp == 255u32 and mantissa <> 0u32
    }
    
    public is_inf(self) Bool = {
        let bits = self.to_bits()
        let exp = { bits bitshr 23 } bitand 255u32
        let mantissa = bits bitand 8388607u32
        exp == 255u32 and mantissa == 0u32
    }
    
    public is_normal(self) Bool = {
        let bits = self.to_bits()
        let exp = { bits bitshr 23 } bitand 255u32
        exp > 0u32 and exp < 255u32
    }
}

given Float64 {
    public to_string(self) String = {
        // Handle special cases
        let bits = self.to_bits()
        let exp = { bits bitshr 52 } bitand 2047u64
        let mantissa = bits bitand 4503599627370495u64  // 0xFFFFFFFFFFFFF
        if exp == 2047u64 then {
            if mantissa <> 0u64 then { return "NaN"; }
            if { bits bitshr 63 } == 1u64 then { return "-Inf"; }
            return "Inf"
        }
        
        let is_negative = { bits bitshr 63 } == 1u64
        let mut f = if is_negative then 0.0 - self else self
        
        let int_part = (Int)f
        let frac_part = f - (Float64)int_part
        
        let mut result = String.empty()
        if is_negative then { result.push_byte('-'); }

        result.push(int_part.to_string())
        result.push_byte('.')
        
        let mut frac = frac_part
        let mut digits = 0
        while digits < 6 then {
            frac = frac * 10.0
            let d = (Int)frac
            result.push_byte((UInt8)d + '0')
            frac = frac - (Float64)d
            digits += 1
        }
        
        result
    }
    
    // Static constants via bit manipulation using intrinsic
    // Inf: exp=2047, mantissa=0, sign=0 -> 0x7FF0000000000000 = 0x7FF << 52
    public inf() Float64 = Float64.from_bits(2047u64 bitshl 52)
    
    // NaN: exp=2047, mantissa!=0 -> 0x7FF8000000000000 = (0x7FF << 52) | (1 << 51)
    public nan() Float64 = Float64.from_bits({ 2047u64 bitshl 52 } bitor { 1u64 bitshl 51 })
    
    // Min normal: exp=1, mantissa=0 -> 0x0010000000000000 = 1 << 52
    public min_normal() Float64 = Float64.from_bits(1u64 bitshl 52)
    
    // Min denormal: exp=0, mantissa=1 -> 0x0000000000000001
    public min_denormal() Float64 = Float64.from_bits(1u64)
    
    // Max finite: exp=2046, mantissa=all 1s -> 0x7FEFFFFFFFFFFFFF
    public max() Float64 = {
        let exp_bits UInt64 = 2046u64 bitshl 52
        let mantissa_bits UInt64 = { 1u64 bitshl 52 } - 1u64
        Float64.from_bits(exp_bits bitor mantissa_bits)
    }
    
    // Min finite (most negative): -max -> 0xFFEFFFFFFFFFFFFF
    public min() Float64 = {
        let sign_bit UInt64 = 1u64 bitshl 63
        let exp_bits UInt64 = 2046u64 bitshl 52
        let mantissa_bits UInt64 = { 1u64 bitshl 52 } - 1u64
        Float64.from_bits(sign_bit bitor exp_bits bitor mantissa_bits)
    }
    
    // Instance methods
    public is_nan(self) Bool = {
        let bits = self.to_bits()
        let exp = { bits bitshr 52 } bitand 2047u64
        let mantissa = bits bitand 4503599627370495u64
        exp == 2047u64 and mantissa <> 0u64
    }
    
    public is_inf(self) Bool = {
        let bits = self.to_bits()
        let exp = { bits bitshr 52 } bitand 2047u64
        let mantissa = bits bitand 4503599627370495u64
        exp == 2047u64 and mantissa == 0u64
    }
    
    public is_normal(self) Bool = {
        let bits = self.to_bits()
        let exp = { bits bitshr 52 } bitand 2047u64
        exp > 0u64 and exp < 2047u64
    }
}

// ============================================================================
// SECTION 13: List Type
// ============================================================================

public type [T Any]ListStorage(mut source [T]Pointer, mut len Int, mut cap Int)

given[T Any] [T]ListStorage {
    __drop(self ref) = {
        let mut i = 0
        while i < self.len then {
            self.source.offset(i).deinit()
            i += 1
        }
        dealloc_memory(self.source)
    }
}

public type [T Any]List(mut storage [T]ListStorage ref)

public type [T Any]ListIterator(storage [T]ListStorage ref, mut index Int)

given[T Any] [T]List {
    public new() Self = {
        let cap = 10
        let source = [T]alloc_memory(cap)
        let storage = ref [T]ListStorage(source, 0, cap)
        [T]List(storage)
    }

    public with_capacity(capacity Int) Self = {
        let cap = if capacity < 1 then 1 else capacity
        let source = [T]alloc_memory(cap)
        let storage = ref [T]ListStorage(source, 0, cap)
        [T]List(storage)
    }

    public count(self) Int = self.storage.len

    private ensure_unique(self ref) Void = {
        if ref_count(self.storage) > 1 then {
            let old = self.storage
            let new_cap = old.cap
            let new_source = [T]alloc_memory(new_cap)
            let mut i = 0
            while i < old.len then {
                let v = old.source.offset(i).peek()
                new_source.offset(i).init(v)
                i += 1
            }
            let new_storage = ref [T]ListStorage(new_source, old.len, new_cap)
            self.storage = new_storage
        }
    }

    private ensure_capacity(self ref, min_capacity Int) Void = {
         if min_capacity > self.storage.cap then {
             let mut new_cap = self.storage.cap * 2
             if new_cap < min_capacity then { new_cap = min_capacity; }
             let new_source = [T]alloc_memory(new_cap)
             let old_len = self.storage.len
             if ref_count(self.storage) == 1 then {
                 let old_source = self.storage.source
                 move_memory(new_source, old_source, old_len)
                 dealloc_memory(old_source)
                 self.storage.source = new_source
                 self.storage.cap = new_cap
             } else {
                 let mut i = 0
                 while i < old_len then {
                    let v = self.storage.source.offset(i).peek()
                    new_source.offset(i).init(v)
                    i += 1
                 }
                 let new_storage = ref [T]ListStorage(new_source, old_len, new_cap)
                 self.storage = new_storage
             }
         } else {
             self.ensure_unique()
         }
    }

    public push_back(self ref, value T) Void = {
        self.ensure_capacity(self.storage.len + 1)
        self.storage.source.offset(self.storage.len).init(value)
        self.storage.len = self.storage.len + 1
    }

    public pop_back(self ref) [T]Option = {
        if self.storage.len == 0 then { return [T]Option.None(); }
        self.ensure_unique()
        self.storage.len = self.storage.len - 1
        let value = self.storage.source.offset(self.storage.len).take()
        [T]Option.Some(value)
    }

    public push_front(self ref, value T) Void = {
        self.ensure_capacity(self.storage.len + 1)
        // Shift all elements to the right
        let mut i = self.storage.len
        while i > 0 then {
            let src = self.storage.source.offset(i - 1)
            let dst = self.storage.source.offset(i)
            dst.init(src.take())
            i = i - 1
        }
        self.storage.source.offset(0).init(value)
        self.storage.len = self.storage.len + 1
    }

    public pop_front(self ref) [T]Option = {
        if self.storage.len == 0 then { return [T]Option.None(); }
        self.ensure_unique()
        let value = self.storage.source.offset(0).take()
        // Shift all elements to the left
        let mut i = 0
        while i < self.storage.len - 1 then {
            let src = self.storage.source.offset(i + 1)
            let dst = self.storage.source.offset(i)
            dst.init(src.take())
            i = i + 1
        }
        self.storage.len = self.storage.len - 1
        [T]Option.Some(value)
    }

    public insert(self ref, index Int, value T) Void = {
        if index < 0 or index > self.storage.len then { panic("List insert index out of bounds"); }
        self.ensure_capacity(self.storage.len + 1)
        // Shift elements to the right
        let mut i = self.storage.len
        while i > index then {
            let src = self.storage.source.offset(i - 1)
            let dst = self.storage.source.offset(i)
            dst.init(src.take())
            i = i - 1
        }
        self.storage.source.offset(index).init(value)
        self.storage.len = self.storage.len + 1
    }

    public remove(self ref, index Int) T = {
        if index < 0 or index >= self.storage.len then { panic("List remove index out of bounds"); }
        self.ensure_unique()
        let value = self.storage.source.offset(index).take()
        // Shift elements to the left
        let mut i = index
        while i < self.storage.len - 1 then {
            let src = self.storage.source.offset(i + 1)
            let dst = self.storage.source.offset(i)
            dst.init(src.take())
            i = i + 1
        }
        self.storage.len = self.storage.len - 1
        value
    }

    public at(self, index Int) [T]Option = {
        if index < 0 or index >= self.storage.len then { return [T]Option.None(); }
        [T]Option.Some(self.storage.source.offset(index).peek())
    }

    public replace(self ref, index Int, value T) [T]Option = {
        if index < 0 or index >= self.storage.len then { return [T]Option.None(); }
        self.ensure_unique()
        let old = self.storage.source.offset(index).replace(value)
        [T]Option.Some(old)
    }

    public front(self) [T]Option = self.at(0)

    public back(self) [T]Option = {
        if self.storage.len == 0 then { return [T]Option.None(); }
        self.at(self.storage.len - 1)
    }

    public is_empty(self) Bool = self.storage.len == 0

    public clear(self ref) Void = {
        self.ensure_unique()
        let mut i = 0
        while i < self.storage.len then {
            self.storage.source.offset(i).deinit()
            i += 1
        }
        self.storage.len = 0
    }

    public iterator(self) [T]ListIterator = [T]ListIterator(self.storage, 0)

    public __at(self, index Int) T = {
        if index < 0 or index >= self.storage.len then { panic("List index out of bounds"); }
        self.storage.source.offset(index).peek()
    }

    public __update_at(self ref, index Int, value T) Void = {
        if index < 0 or index >= self.storage.len then { panic("List index out of bounds"); }
        self.ensure_unique()
        self.storage.source.offset(index).replace(value);
    }
}

given[T Any] [T]ListIterator {
    public next(self ref) [T]Option = {
        if self.index >= self.storage.len then { return [T]Option.None(); }
        let value = self.storage.source.offset(self.index).peek()
        self.index = self.index + 1
        [T]Option.Some(value)
    }
}

// ============================================================================
// SECTION 14: Map Type
// ============================================================================

public type [K Hashable, V Any]MapEntry(key K, value V)

public type [K Hashable, V Any]MapBucket {
    Empty(),
    Occupied(entry [K, V]MapEntry),
    Deleted(),
}

public type [K Hashable, V Any]MapStorage(
    mut buckets [[K, V]MapBucket]Pointer,
    mut count Int,
    mut capacity Int
)

given[K Hashable, V Any] [K, V]MapStorage {
    __drop(self ref) = {
        let mut i = 0
        while i < self.capacity then {
            self.buckets.offset(i).deinit()
            i += 1
        }
        dealloc_memory(self.buckets)
    }
}

public type [K Hashable, V Any]Map(mut storage [K, V]MapStorage ref)

public type [K Hashable, V Any]MapIterator(storage [K, V]MapStorage ref, mut index Int)

given[K Hashable, V Any] [K, V]Map {
    public new() Self = {
        let capacity = 16
        let buckets = [[K, V]MapBucket]alloc_memory(capacity)
        let mut i = 0
        while i < capacity then {
            buckets.offset(i).init([K, V]MapBucket.Empty())
            i += 1
        }
        let storage = ref [K, V]MapStorage(buckets, 0, capacity)
        [K, V]Map(storage)
    }

    public with_capacity(capacity Int) Self = {
        // Hash tables need extra space for efficiency (load factor ~0.5)
        let cap = if capacity < 4 then 4 else capacity * 2
        let buckets = [[K, V]MapBucket]alloc_memory(cap)
        let mut i = 0
        while i < cap then {
            buckets.offset(i).init([K, V]MapBucket.Empty())
            i += 1
        }
        let storage = ref [K, V]MapStorage(buckets, 0, cap)
        [K, V]Map(storage)
    }

    public count(self) Int = self.storage.count

    private ensure_unique(self ref) Void = {
        if ref_count(self.storage) > 1 then {
            let old = self.storage
            let new_buckets = [[K, V]MapBucket]alloc_memory(old.capacity)
            let mut i = 0
            while i < old.capacity then {
                let bucket = old.buckets.offset(i).peek()
                new_buckets.offset(i).init(bucket)
                i += 1
            }
            let new_storage = ref [K, V]MapStorage(new_buckets, old.count, old.capacity)
            self.storage = new_storage
        }
    }

    private find_slot(self ref, key K ref) Int = {
        let h = key.hash()
        let mut idx = (Int){ h % (UInt)self.storage.capacity }
        let mut first_deleted = 0 - 1
        let mut probes = 0
        while probes < self.storage.capacity then {
            let bucket = self.storage.buckets.offset(idx).peek()
            when bucket is {
                .Empty then {
                    if first_deleted >= 0 then { return first_deleted; }
                    return idx
                },
                .Deleted then {
                    if first_deleted < 0 then { first_deleted = idx; }
                },
                .Occupied(e) then {
                    if e.key == deref key then { return idx; }
                },
            }
            idx = { idx + 1 } % self.storage.capacity
            probes += 1
        }
        if first_deleted >= 0 then first_deleted else 0 - 1
    }

    private rehash(self ref) Void = {
        let old_cap = self.storage.capacity
        let old_buckets = self.storage.buckets
        let new_cap = old_cap * 2
        let new_buckets = [[K, V]MapBucket]alloc_memory(new_cap)
        let mut i = 0
        while i < new_cap then {
            new_buckets.offset(i).init([K, V]MapBucket.Empty())
            i += 1
        }
        self.storage.buckets = new_buckets
        self.storage.capacity = new_cap
        self.storage.count = 0
        i = 0
        while i < old_cap then {
            let bucket = old_buckets.offset(i).take()
            when bucket is {
                .Occupied(e) then { self.insert_internal(e.key, e.value); },
                .Empty then {},
                .Deleted then {},
            }
            i += 1
        }
        dealloc_memory(old_buckets)
    }

    // Internal insert used by rehash - doesn't return old value
    private insert_internal(self ref, key K, value V) Void = {
        let idx = self.find_slot(ref key)
        if idx < 0 then { panic("Map insert failed"); }
        let bucket = self.storage.buckets.offset(idx).peek()
        when bucket is {
            .Occupied(_) then {
                self.storage.buckets.offset(idx).replace([K, V]MapBucket.Occupied([K, V]MapEntry(key, value)));
            },
            .Empty then {
                self.storage.buckets.offset(idx).replace([K, V]MapBucket.Occupied([K, V]MapEntry(key, value)));
                self.storage.count = self.storage.count + 1
            },
            .Deleted then {
                self.storage.buckets.offset(idx).replace([K, V]MapBucket.Occupied([K, V]MapEntry(key, value)));
                self.storage.count = self.storage.count + 1
            },
        }
    }

    // Returns None if key was new, Some(old_value) if overwritten
    public insert(self ref, key K, value V) [V]Option = {
        self.ensure_unique()
        if self.storage.count * 2 >= self.storage.capacity then { self.rehash(); }
        let idx = self.find_slot(ref key)
        if idx < 0 then { panic("Map insert failed"); }
        let bucket = self.storage.buckets.offset(idx).peek()
        when bucket is {
            .Occupied(e) then {
                self.storage.buckets.offset(idx).replace([K, V]MapBucket.Occupied([K, V]MapEntry(key, value)));
                [V]Option.Some(e.value)
            },
            .Empty then {
                self.storage.buckets.offset(idx).replace([K, V]MapBucket.Occupied([K, V]MapEntry(key, value)));
                self.storage.count = self.storage.count + 1
                [V]Option.None()
            },
            .Deleted then {
                self.storage.buckets.offset(idx).replace([K, V]MapBucket.Occupied([K, V]MapEntry(key, value)));
                self.storage.count = self.storage.count + 1
                [V]Option.None()
            },
        }
    }

    public at(self, key K) [V]Option = {
        let idx = self.find_slot(ref key)
        if idx < 0 then { return [V]Option.None(); }
        let bucket = self.storage.buckets.offset(idx).peek()
        when bucket is {
            .Occupied(e) then [V]Option.Some(e.value),
            .Empty then [V]Option.None(),
            .Deleted then [V]Option.None(),
        }
    }

    public __at(self, key K) V = {
        let idx = self.find_slot(ref key)
        if idx < 0 then { panic("Map key not found"); }
        let bucket = self.storage.buckets.offset(idx).peek()
        when bucket is {
            .Occupied(e) then e.value,
            .Empty then panic("Map key not found"),
            .Deleted then panic("Map key not found"),
        }
    }

    public __update_at(self ref, key K, value V) Void = {
        self.ensure_unique()
        let idx = self.find_slot(ref key)
        if idx < 0 then { panic("Map key not found"); }
        let bucket = self.storage.buckets.offset(idx).peek()
        when bucket is {
            .Occupied(e) then {
                let old = self.storage.buckets.offset(idx).replace([K, V]MapBucket.Occupied([K, V]MapEntry(e.key, value)))
                // old is dropped here
            },
            .Empty then panic("Map key not found"),
            .Deleted then panic("Map key not found"),
        }
    }

    public contains(self, key K) Bool = {
        when self.at(key) is {
            .Some(_) then true,
            .None then false,
        }
    }

    public remove(self ref, key K) [V]Option = {
        self.ensure_unique()
        let idx = self.find_slot(ref key)
        if idx < 0 then { return [V]Option.None(); }
        let bucket = self.storage.buckets.offset(idx).peek()
        when bucket is {
            .Occupied(e) then {
                self.storage.buckets.offset(idx).replace([K, V]MapBucket.Deleted());
                self.storage.count = self.storage.count - 1
                [V]Option.Some(e.value)
            },
            .Empty then [V]Option.None(),
            .Deleted then [V]Option.None(),
        }
    }

    public is_empty(self) Bool = self.storage.count == 0

    public clear(self ref) Void = {
        self.ensure_unique()
        let mut i = 0
        while i < self.storage.capacity then {
            self.storage.buckets.offset(i).replace([K, V]MapBucket.Empty());
            i += 1
        }
        self.storage.count = 0
    }

    public iterator(self) [K, V]MapIterator = [K, V]MapIterator(self.storage, 0)
}

given[K Hashable, V Any] [K, V]MapIterator {
    public next(self ref) [[K, V]MapEntry]Option = {
        while self.index < self.storage.capacity then {
            let bucket = self.storage.buckets.offset(self.index).peek()
            self.index = self.index + 1
            when bucket is {
                .Occupied(e) then { return [[K, V]MapEntry]Option.Some(e); },
                .Empty then {},
                .Deleted then {},
            }
        }
        [[K, V]MapEntry]Option.None()
    }
}

// ============================================================================
// SECTION 15: Set Type
// ============================================================================

public type [T Hashable]SetBucket {
    Empty(),
    Occupied(value T),
    Deleted(),
}

public type [T Hashable]SetStorage(
    mut buckets [[T]SetBucket]Pointer,
    mut count Int,
    mut capacity Int
)

given[T Hashable] [T]SetStorage {
    __drop(self ref) = {
        let mut i = 0
        while i < self.capacity then {
            self.buckets.offset(i).deinit()
            i += 1
        }
        dealloc_memory(self.buckets)
    }
}

public type [T Hashable]Set(mut storage [T]SetStorage ref)

public type [T Hashable]SetIterator(storage [T]SetStorage ref, mut index Int)

given[T Hashable] [T]Set {
    public new() Self = {
        let capacity = 16
        let buckets = [[T]SetBucket]alloc_memory(capacity)
        let mut i = 0
        while i < capacity then {
            buckets.offset(i).init([T]SetBucket.Empty())
            i += 1
        }
        let storage = ref [T]SetStorage(buckets, 0, capacity)
        [T]Set(storage)
    }

    public with_capacity(capacity Int) Self = {
        // Hash tables need extra space for efficiency (load factor ~0.5)
        let cap = if capacity < 4 then 4 else capacity * 2
        let buckets = [[T]SetBucket]alloc_memory(cap)
        let mut i = 0
        while i < cap then {
            buckets.offset(i).init([T]SetBucket.Empty())
            i += 1
        }
        let storage = ref [T]SetStorage(buckets, 0, cap)
        [T]Set(storage)
    }

    public count(self) Int = self.storage.count

    private ensure_unique(self ref) Void = {
        if ref_count(self.storage) > 1 then {
            let old = self.storage
            let new_buckets = [[T]SetBucket]alloc_memory(old.capacity)
            let mut i = 0
            while i < old.capacity then {
                let bucket = old.buckets.offset(i).peek()
                new_buckets.offset(i).init(bucket)
                i += 1
            }
            let new_storage = ref [T]SetStorage(new_buckets, old.count, old.capacity)
            self.storage = new_storage
        }
    }

    private find_slot(self ref, value T ref) Int = {
        let h = value.hash()
        let mut idx = (Int){ h % (UInt)self.storage.capacity }
        let mut first_deleted = 0 - 1
        let mut probes = 0
        while probes < self.storage.capacity then {
            let bucket = self.storage.buckets.offset(idx).peek()
            when bucket is {
                .Empty then {
                    if first_deleted >= 0 then { return first_deleted; }
                    return idx
                },
                .Deleted then {
                    if first_deleted < 0 then { first_deleted = idx; }
                },
                .Occupied(v) then {
                    if v == deref value then { return idx; }
                },
            }
            idx = { idx + 1 } % self.storage.capacity
            probes += 1
        }
        if first_deleted >= 0 then first_deleted else 0 - 1
    }

    private rehash(self ref) Void = {
        let old_cap = self.storage.capacity
        let old_buckets = self.storage.buckets
        let new_cap = old_cap * 2
        let new_buckets = [[T]SetBucket]alloc_memory(new_cap)
        let mut i = 0
        while i < new_cap then {
            new_buckets.offset(i).init([T]SetBucket.Empty())
            i += 1
        }
        self.storage.buckets = new_buckets
        self.storage.capacity = new_cap
        self.storage.count = 0
        i = 0
        while i < old_cap then {
            let bucket = old_buckets.offset(i).take()
            when bucket is {
                .Occupied(v) then { self.insert(v); },
                .Empty then {},
                .Deleted then {},
            }
            i += 1
        }
        dealloc_memory(old_buckets)
    }

    // Returns true if value was new, false if already present
    public insert(self ref, value T) Bool = {
        self.ensure_unique()
        if self.storage.count * 2 >= self.storage.capacity then { self.rehash(); }
        let idx = self.find_slot(ref value)
        if idx < 0 then { panic("Set insert failed"); }
        let bucket = self.storage.buckets.offset(idx).peek()
        when bucket is {
            .Occupied(_) then false,
            .Empty then {
                self.storage.buckets.offset(idx).replace([T]SetBucket.Occupied(value));
                self.storage.count = self.storage.count + 1
                true
            },
            .Deleted then {
                self.storage.buckets.offset(idx).replace([T]SetBucket.Occupied(value));
                self.storage.count = self.storage.count + 1
                true
            },
        }
    }

    public contains(self, value T) Bool = {
        let idx = self.find_slot(ref value)
        if idx < 0 then { return false; }
        let bucket = self.storage.buckets.offset(idx).peek()
        when bucket is {
            .Occupied(_) then true,
            .Empty then false,
            .Deleted then false,
        }
    }

    public remove(self ref, value T) Bool = {
        self.ensure_unique()
        let idx = self.find_slot(ref value)
        if idx < 0 then { return false; }
        let bucket = self.storage.buckets.offset(idx).peek()
        when bucket is {
            .Occupied(_) then {
                self.storage.buckets.offset(idx).replace([T]SetBucket.Deleted());
                self.storage.count = self.storage.count - 1
                true
            },
            .Empty then false,
            .Deleted then false,
        }
    }

    public is_empty(self) Bool = self.storage.count == 0

    public clear(self ref) Void = {
        self.ensure_unique()
        let mut i = 0
        while i < self.storage.capacity then {
            self.storage.buckets.offset(i).replace([T]SetBucket.Empty());
            i += 1
        }
        self.storage.count = 0
    }

    public union(self, other [T]Set) [T]Set = {
        let mut result = [T]Set.new()
        let mut it = self.iterator()
        while true then {
            when it.next() is {
                .Some(v) then { result.insert(v); },
                .None then { break; },
            }
        }
        let mut it2 = other.iterator()
        while true then {
            when it2.next() is {
                .Some(v) then { result.insert(v); },
                .None then { break; },
            }
        }
        result
    }

    public intersection(self, other [T]Set) [T]Set = {
        let mut result = [T]Set.new()
        let mut it = self.iterator()
        while true then {
            when it.next() is {
                .Some(v) then {
                    if other.contains(v) then { result.insert(v); }
                },
                .None then { break; },
            }
        }
        result
    }

    public difference(self, other [T]Set) [T]Set = {
        let mut result = [T]Set.new()
        let mut it = self.iterator()
        while true then {
            when it.next() is {
                .Some(v) then {
                    if not other.contains(v) then { result.insert(v); }
                },
                .None then { break; },
            }
        }
        result
    }

    public iterator(self) [T]SetIterator = [T]SetIterator(self.storage, 0)
}

given[T Hashable] [T]SetIterator {
    public next(self ref) [T]Option = {
        while self.index < self.storage.capacity then {
            let bucket = self.storage.buckets.offset(self.index).peek()
            self.index = self.index + 1
            when bucket is {
                .Occupied(v) then { return [T]Option.Some(v); },
                .Empty then {},
                .Deleted then {},
            }
        }
        [T]Option.None()
    }
}

// ============================================================================
// SECTION 16: Utility Functions
// ============================================================================

public let [T Comparable]max(a T, b T) T = if a > b then a else b
public let [T Comparable]min(a T, b T) T = if a < b then a else b


// ============================================================================
// SECTION 17: Standard IO Functions
// ============================================================================

//  flush
public let [T ToString]print(value T) Void = {
    let s = value.to_string()
    fwrite(s.storage.data, s.storage.len, std_out);
    fflush(std_out)
}

//  flush
public let [T ToString]print_line(value T) Void = {
    let s = value.to_string()
    fwrite(s.storage.data, s.storage.len, std_out);
    let newline = "\n"
    fwrite(newline.storage.data, newline.storage.len, std_out);
    fflush(std_out)
}

//  flush
public let [T ToString]error_print(value T) Void = {
    let s = value.to_string()
    fwrite(s.storage.data, s.storage.len, std_err);
    fflush(std_err)
}

//  flush
public let [T ToString]error_print_line(value T) Void = {
    let s = value.to_string()
    fwrite(s.storage.data, s.storage.len, std_err);
    let newline = "\n"
    fwrite(newline.storage.data, newline.storage.len, std_err);
    fflush(std_err)
}

// 
public let read_line() [String]Option = {
    let mut result = String.empty()
    
    while true then {
        let ch = fgetc(std_in)
        
        // EOF
        if ch < 0 then {
            if result.is_empty() then {
                return [String]Option.None()
            }
            break
        }
        
        // Newline - end of line
        if ch == 10 then {  // '\n' = 10
            break
        }
        
        // Skip carriage return (for Windows line endings)
        if ch == 13 then {  // '\r' = 13
            continue
        }
        
        // Add character to result
        result.push_byte((UInt8)ch)
    }
    
    [String]Option.Some(result)
}
