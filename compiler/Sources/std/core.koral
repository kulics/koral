// builtin
// type Bool;

// builtin
// type Int;
// type Int8;
// type Int16;
// type Int32;
// type Int64;

// builtin
// type UInt;
// type UInt8;
// type UInt16;
// type UInt32;
// type UInt64;

// builtin
// type Float16;
// type Float32;
// type Float64;

// builtin
// 映射为 C 的 T*
// type [T Any]Pointer;

type Byte = UInt8;
type Rune = UInt32;

// builtin
// trait Any {}

/* builtin
// Most pointer operations are available for Any type [T].
given[T Any] [T]Pointer {
    // --- Lifecycle ---

    // Allocates uninitialized memory for `capacity` number of elements.
    // The caller is responsible for deallocating this memory later.
    allocate(capacity Int) Self;

    // Deallocates the memory pointed to by `self`.
    // PRECONDITION: The memory must be deinitialized (i.e. uninitialized).
    // If the memory contains values that need to be dropped, call `deinitialize()` first.
    deallocate(self) Void;

    // --- Access & Mutation ---

    // Initializes this pointer’s memory with the given value.
    // This writes to *uninitialized* memory and does NOT drop any existing value.
    // POSTCONDITION: Memory at `self` is initialized.
    initialize(self, v T) Void;

    // Deinitializes the memory at `self`.
    // This drops the value and returns the memory to an uninitialized state.
    // PRECONDITION: Memory at `self` must be initialized.
    deinitialize(self) Void;

    // Puts a new value `v` into *initialized* memory.
    // This drops the existing value at `self` and replaces it with `v`.
    // PRECONDITION: Memory at `self` must be initialized.
    put(self, v T) Void;

    // Retrieves the value from `self`, leaving the memory uninitialized.
    // Ideally used for moving values out of the pointer.
    // PRECONDITION: Memory at `self` must be initialized.
    // POSTCONDITION: Memory at `self` is uninitialized.
    take(self) T;

    // Replaces the value at `self` with `v`, returning the old value.
    // Neither the old value nor the new value is dropped.
    // PRECONDITION: Memory at `self` must be initialized.
    replace(self, v T) T;

    // --- Arithmetic ---

    // Returns a new pointer moved forward by `n` elements from `self`.
    // The offset is in units of T (stride), not bytes.
    advance(self, n Int) Self;
}

// Peek is restricted to Copy types because it duplicates the value from the container.
given[T Copy] [T]Pointer {
    // Peeks the value from `self` without removing or invalidating it.
    // Returns a copy of the value.
    // PRECONDITION: Memory at `self` must be initialized.
    peek(self) T;
}
*/
// builtin
// let [T Any]ref_count(r T ref) Int;

type [T Copy]ListStorage(mut source [T]Pointer, mut len Int, mut cap Int);

public type [T Copy]List(storage [T]ListStorage ref);

given[T Copy] [T]List {
    public new() Self = List(ref ListStorage([T]Pointer.allocate(10), 0, 10));

    drop(self ref) = {
        if ref_count(self.storage) == 1 then {
            for i = 0..<self.storage.len then {
                self.storage.source.advance(i).deinitialize();
            }
            self.storage.source.deallocate();
        }
    }

    public count(self ref) Int = self.storage.len;

    public get(self ref, index Int) T = self.storage.source.advance(index).peek();
    
    public set(self ref, index Int, value T) Void = {
        make_sure_unique(self);
        self.storage.source.advance(index).put(value);
    }

    public push(self ref, value T) Void = {
        make_sure_unique(self);
        // todo, make sure the cap is enough
        self.storage.source.advance(self.storage.len).initialize(value);
        self.storage.len += 1;
    }

    public insert(self ref, index Int, value T) Void = {
        make_sure_unique(self);
        // todo, make sure the cap is enough
        if index < self.storage.len then {
            // Move elements to create space from back to front
            // Handle the last element first: move it to uninitialized memory
            let last = self.storage.source.advance(self.storage.len - 1).take();
            self.storage.source.advance(self.storage.len).initialize(last);
            
            // Shift the rest
            for i = self.storage.len - 1 ..< index step -1 then {
                 // Move [i-1] to [i]
                 let prev = self.storage.source.advance(i - 1).take();
                 // Slot [i] is now logically uninitialized (because we moved out of it in previous step? NO)
                 // Wait, loop logic:
                 // Iteration 1 (i = len-1): We want to move [len-2] to [len-1].
                 // [len-1] was moved out in "Handle the last element first". So it IS uninitialized.
                 // So we use initialize.
                 self.storage.source.advance(i).initialize(prev);
            }
            // After loop, slot [index] is uninitialized.
            self.storage.source.advance(index).initialize(value);
        } else {
             self.storage.source.advance(self.storage.len).initialize(value);
        }
        self.storage.len += 1;
    }

    public remove(self ref, index Int) Void = {
        make_sure_unique(self);
        
        // 1. Drop the element at index
        self.storage.source.advance(index).deinitialize();
        
        // 2. Shift remaining elements down
        for i = index ..< self.storage.len - 1 then {
            // We want to move [i+1] to [i]
            // Slot [i] is uninitialized (either dropped above, or moved out in previous iter)
            let next_val = self.storage.source.advance(i + 1).take();
            self.storage.source.advance(i).initialize(next_val);
        }
        
        // 3. The last element slot is now uninitialized because we moved from it in the last iteration.
        // So we don't need to deinitialize it! It's already empty.
        
        self.storage.len -= 1;
    }

    public iterator(self) [T]ListIterator = [T]ListIterator(self, 0);

    make_sure_unique(self ref) = { 
        // todo
    }
}

public type [T Copy]ListIterator(source [T]List ref, mut index Int);

given[T Copy] [T]ListIterator {
    public next(self ref) [T]Option = 
        if self.index < self.source.count() then {
            self.index += 1;
            .Some(self.source[self.index])
        } else {
            .None()
        }
}

/*
public type String(source [Byte]List);

given String {
    public of_utf8_bytes(data [Byte]List) Self = String(data);

    public count(self ref) Int = self.source.count();

    public iterator(self) StringIterator = StringIterator(self, -1);
}

public type StringIterator(source String, mut index Int);

given StringIterator {
    public next(self ref) [Rune]Option = 
        if self.index < self._source.data.size() then {
            self.index += 1;
            .Some((Rune){deref self.source.source.get(self.index)})
        } else {
            .None()
        }
}

public type [T Any]Option {
    Some(value T);
    None();
}

given[T Any] [T]Option {
    public [U Any]map(self, fn [T, U]Func) [U]Option = if self is .Some(v) then .Some(fn(v)) else .None();
}

public trait [T Any]Iterator {
    next(self ref) [T]Option;
}

public trait [T Any, I [T]Iterator]IntoIterator {
    iterator(self) I;
}

public let [T Any, I [T]Iterator]lazy(iter I) [T, I]Sequence = Sequence(iter);

public type [T Any, I [T]Iterator]Sequence(iter I);

given[T Any, I [T]Iterator] [T, I]Sequence {
    public [R Any]reduce(self, mut r R, f [R, T, R]Func) R = {
        for v = self then r = f(r, v);
        r
    }
    public filter(self, f [T, Bool]Func) [T, I]FilterSequence = FilterSequence(self, f);
    public [R Any]map(self, f [T, R]Func) [T, R, I]MapSequence = MapSequence(self, f);
}

public type [T Any, I [T]Iterator]FilterSequence(iter I, filter [T, Bool]Func);

given[T Any, I [T]Iterator] [T, I]FilterSequence {
    public next(self ref) [T]Option = 
        while self.iter.next() is .Some(v) then {
            if self.filter(v) then return .Some(v);
        } else .None();
}

public type [T Any, R Any, I [T]Iterator]MapSequence(iter I, mapper [T, R]Func);

given[T Any, R Any, I [T]Iterator] [T, R, I]MapSequence  {
    next(self ref) [R]Option = 
        if self.iter.next() is .Some(v) then .Some(mapper(v)) else .None();
}

public trait Equatable {
    equals(self ref, r Self ref) Bool;
}

public trait Comparable Equatable {
    compare(self ref, r Self ref) Int;
}

public let [T Comparable]max(a T, b T) T = if compare(a, b) > 0 then a else b;
public let [T Comparable]min(a T, b T) T = if compare(a, b) < 0 then a else b;
*/