// ============================================================================
// Koral Standard Library - String Type
// ============================================================================
// NOTE: This file is merged into core.koral, so primitives, traits, and option are already available.
// ============================================================================

// ============================================================================
// String Storage and Type Definition
// ============================================================================

// Internal storage for String (COW semantics)
public type StringStorage(mut data [UInt8]Pointer, mut len Int, mut cap Int)

given StringStorage {
    __drop(self ref) = { dealloc_memory(self.data) }
}

// String type with COW semantics
public type String(mut storage StringStorage ref)

// Forward declarations for String iterators
// Wrapper types (provide iterator() method)
public type StringSplitAsciiWhitespace(source String)
public type StringSplit(source String, sep String)
public type StringLines(source String)

// Iterator types (provide next() method)
public type StringSplitAsciiWhitespaceIterator(source String, mut index Int)
public type StringSplitIterator(source String, sep String, mut index Int)
public type StringLinesIterator(source String, mut index Int)

// ============================================================================
// String Methods
// ============================================================================

given String {
    // Unsafe constructor: does not validate UTF-8
    public from_bytes_unchecked(bytes [UInt8]Pointer, len Int) String = {
        let cap = len + 1
        let data = [UInt8]alloc_memory(cap)
        copy_memory(data, bytes, len)
        data.offset(len).init(0)
        let storage = ref StringStorage(data, len, cap)
        String(storage)
    }

    public empty() String = {
        let data = [UInt8]alloc_memory(1)
        data.init(0)
        let storage = ref StringStorage(data, 0, 1)
        String(storage)
    }

    public with_capacity(capacity Int) String = {
        let cap = if capacity < 1 then 1 else capacity + 1
        let data = [UInt8]alloc_memory(cap)
        data.init(0)
        let storage = ref StringStorage(data, 0, cap)
        String(storage)
    }

    public new() String = {
        let cap = 16  // 默认容量
        let data = [UInt8]alloc_memory(cap)
        data.init(0)
        let storage = ref StringStorage(data, 0, cap)
        String(storage)
    }

    // Using comparison patterns for ASCII space check
    private is_ascii_space(b UInt8) Bool =
        b == " " or b == "\t" or b == "\n" or b == "\v" or b == "\f" or b == "\r"

    private bounds_check_read(self, index Int) Void = {
        if index < 0 or index > self.storage.len then {
            panic("String index out of bounds")
        }
    }

    private bounds_check_write(self, index Int) Void = {
        if index < 0 or index >= self.storage.len then {
            panic("String index out of bounds")
        }
    }

    private ensure_unique(self ref) Void = {
        if ref_count(self.storage) > 1 then {
            let old = self.storage
            let new_data = [UInt8]alloc_memory(old.cap)
            copy_memory(new_data, old.data, old.len + 1)
            let new_storage = ref StringStorage(new_data, old.len, old.cap)
            self.storage = new_storage
        }
    }

    private ensure_capacity(self ref, min_cap Int) Void = {
        if self.storage.cap >= min_cap then { return; }
        let mut new_cap = self.storage.cap * 2
        if new_cap < min_cap then { new_cap = min_cap; }
        let new_data = [UInt8]alloc_memory(new_cap)
        copy_memory(new_data, self.storage.data, self.storage.len + 1)
        let new_storage = ref StringStorage(new_data, self.storage.len, new_cap)
        self.storage = new_storage
    }

    public count(self) Int = self.storage.len
    public is_empty(self) Bool = self.storage.len == 0
    public capacity(self) Int = self.storage.cap - 1

    public get(self, index Int) [UInt8]Option = {
        if index < 0 or index >= self.storage.len then {
            return [UInt8]Option.None()
        }
        [UInt8]Option.Some(self.storage.data.offset(index).peek())
    }

    public __at(self, index Int) UInt8 = {
        if index < 0 or index >= self.storage.len then {
            panic("String index out of bounds")
        }
        self.storage.data.offset(index).peek()
    }

    public push(self ref, value UInt8) Void = {
        self.ensure_unique()
        let needed = self.storage.len + 2
        self.ensure_capacity(needed)
        self.storage.data.offset(self.storage.len).init(value)
        self.storage.len = self.storage.len + 1
        self.storage.data.offset(self.storage.len).replace(0);
    }

    public push_string(self ref, other String) Void = {
        let other_len = other.storage.len
        self.ensure_unique()
        let needed = self.storage.len + other_len + 1
        self.ensure_capacity(needed)
        let dest = self.storage.data.offset(self.storage.len)
        copy_memory(dest, other.storage.data, other_len)
        self.storage.len = self.storage.len + other_len
        self.storage.data.offset(self.storage.len).replace(0);
    }

    // Push an Int value directly to the string
    public push_int(self ref, value Int) Void = {
        if value == 0 then {
            self.push('0')
            return
        }
        
        let mut n = value
        let is_negative = n < 0
        if is_negative then { n = 0 - n; }
        
        let buf = [UInt8]alloc_memory(21)
        let mut pos = 20
        while n > 0 then {
            pos -= 1
            buf.offset(pos).init((UInt8){ n % 10 } + '0')
            n = n / 10
        }
        
        if is_negative then {
            pos -= 1
            buf.offset(pos).init('-')
        }
        
        let mut i = pos
        while i < 20 then {
            self.push(buf.offset(i).peek())
            i += 1
        }
        
        let mut j = pos
        while j < 20 then {
            buf.offset(j).deinit()
            j += 1
        }
        dealloc_memory(buf)
    }

    // Push a UInt value directly to the string
    public push_uint(self ref, value UInt) Void = {
        if value == 0u then {
            self.push('0')
            return
        }
        
        let mut n = value
        let buf = [UInt8]alloc_memory(21)
        let mut pos = 20
        while n > 0u then {
            pos -= 1
            buf.offset(pos).init((UInt8){ n % 10u } + '0')
            n = n / 10u
        }
        
        let mut i = pos
        while i < 20 then {
            self.push(buf.offset(i).peek())
            i += 1
        }
        
        let mut j = pos
        while j < 20 then {
            buf.offset(j).deinit()
            j += 1
        }
        dealloc_memory(buf)
    }

    public reserve(self ref, capacity Int) Void = {
        self.ensure_unique()
        self.ensure_capacity(capacity + 1)
    }

    public starts_with(self, prefix String) Bool = {
        if prefix.storage.len > self.storage.len then { return false; }
        let mut i = 0
        while i < prefix.storage.len then {
            if self.storage.data.offset(i).peek() <> prefix.storage.data.offset(i).peek() then { return false; }
            i += 1
        }
        true
    }

    public ends_with(self, suffix String) Bool = {
        let slen = suffix.storage.len
        if slen > self.storage.len then { return false; }
        let offset = self.storage.len - slen
        let mut i = 0
        while i < slen then {
            if self.storage.data.offset(offset + i).peek() <> suffix.storage.data.offset(i).peek() then { return false; }
            i += 1
        }
        true
    }

    public index_of(self, pat String) [Int]Option = self.index_of_after(pat, 0)

    public last_index_of(self, pat String) [Int]Option = {
        if pat.storage.len == 0 then {
            panic("last_index_of empty pattern")
        }
        let mut result = [Int]Option.None()
        let mut start = 0
        // Using while is pattern matching for iterator-like loop
        while self.index_of_after(pat, start) is .Some(idx) then {
            result = [Int]Option.Some(idx)
            start = idx + 1
        }
        result
    }

    private make_substring(self, start Int, len Int) String = {
        if start < 0 or len < 0 or start + len > self.storage.len then {
            panic("substring out of bounds")
        }
        let cap = len + 1
        let data = [UInt8]alloc_memory(cap)
        copy_memory(data, self.storage.data.offset(start), len)
        data.offset(len).init(0)
        let storage = ref StringStorage(data, len, cap)
        String(storage)
    }

    public slice(self, range [Int]Range) String = when range is {
        .ClosedRange(start, end) then self.make_substring(start, end - start + 1),
        .ClosedOpenRange(start, end) then self.make_substring(start, end - start),
        .OpenClosedRange(start, end) then self.make_substring(start + 1, end - start),
        .OpenRange(start, end) then self.make_substring(start + 1, end - start - 1),
        .FromRange(start) then self.make_substring(start, self.storage.len - start),
        .FromOpenRange(start) then self.make_substring(start + 1, self.storage.len - start - 1),
        .ToRange(end) then self.make_substring(0, end + 1),
        .ToOpenRange(end) then self.make_substring(0, end),
        .FullRange then self.make_substring(0, self.storage.len),
    }

    public trim_ascii_start(self) String = {
        let mut i = 0
        while i < self.storage.len and String.is_ascii_space(self.storage.data.offset(i).peek()) then { i += 1; }
        self.make_substring(i, self.storage.len - i)
    }

    public trim_ascii_end(self) String = {
        let mut end = self.storage.len
        while end > 0 and String.is_ascii_space(self.storage.data.offset(end - 1).peek()) then { end -= 1; }
        self.make_substring(0, end)
    }

    public trim_ascii(self) String = {
        let head = self.trim_ascii_start()
        head.trim_ascii_end()
    }

    // Using comparison patterns for case conversion
    private to_lower_byte(b UInt8) UInt8 =
        if b is >= 65 and <= 90 then b + 32 else b

    private to_upper_byte(b UInt8) UInt8 =
        if b is >= 97 and <= 122 then b - 32 else b

    public to_ascii_lowercase(self) String = {
        let cap = self.storage.len + 1
        let data = [UInt8]alloc_memory(cap)
        let mut i = 0
        while i < self.storage.len then {
            data.offset(i).init(String.to_lower_byte(self.storage.data.offset(i).peek()))
            i += 1
        }
        data.offset(self.storage.len).init(0)
        let storage = ref StringStorage(data, self.storage.len, cap)
        String(storage)
    }

    public to_ascii_uppercase(self) String = {
        let cap = self.storage.len + 1
        let data = [UInt8]alloc_memory(cap)
        let mut i = 0
        while i < self.storage.len then {
            data.offset(i).init(String.to_upper_byte(self.storage.data.offset(i).peek()))
            i += 1
        }
        data.offset(self.storage.len).init(0)
        let storage = ref StringStorage(data, self.storage.len, cap)
        String(storage)
    }

    public is_ascii(self) Bool = {
        let mut i = 0
        while i < self.storage.len then {
            if self.storage.data.offset(i).peek() >= 128 then { return false; }
            i += 1
        }
        true
    }

    public is_ascii_whitespace(self) Bool = {
        let mut i = 0
        while i < self.storage.len then {
            if not String.is_ascii_space(self.storage.data.offset(i).peek()) then { return false; }
            i += 1
        }
        true
    }

    public __equals(self, other String) Bool = {
        if self.storage.len <> other.storage.len then { return false; }
        let mut i = 0
        while i < self.storage.len then {
            if self.storage.data.offset(i).peek() <> other.storage.data.offset(i).peek() then { return false; }
            i += 1
        }
        true
    }

    public __compare(self, other String) Int = {
        let min = if self.storage.len < other.storage.len then self.storage.len else other.storage.len
        let mut i = 0
        while i < min then {
            let a = self.storage.data.offset(i).peek()
            let b = other.storage.data.offset(i).peek()
            if a < b then { return 0 - 1; }
            if a > b then { return 1; }
            i += 1
        }
        if self.storage.len < other.storage.len then 0 - 1
        else if self.storage.len > other.storage.len then 1
        else 0
    }

    public hash(self) UInt = {
        let mut h UInt = 2166136261u
        let mut i Int = 0
        while i < self.storage.len then {
            let b UInt8 = self.storage.data.offset(i).peek()
            h = combine_hash(h, (UInt)b)
            i += 1
        }
        h
    }

    public to_string(self) String = self

    public index_of_after(self, pat String, start Int) [Int]Option = {
        if pat.storage.len == 0 then {
            panic("find empty pattern")
        }
        if start < 0 or start > self.storage.len then {
            panic("find start out of bounds")
        }
        let mut i = start
        let max = self.storage.len - pat.storage.len
        while i <= max then {
            let mut j = 0
            let mut ok = true
            while j < pat.storage.len then {
                if self.storage.data.offset(i + j).peek() <> pat.storage.data.offset(j).peek() then { ok = false; break; }
                j += 1
            }
            if ok then { return [Int]Option.Some(i); }
            i += 1
        }
        [Int]Option.None()
    }

    public contains(self, pat String) Bool = when self.index_of_after(pat, 0) is {
        .Some(_) then true,
        .None then false,
    }

    public repeat(self, times Int) String = {
        if times < 0 then {
            panic("repeat negative")
        }
        if times == 0 then { return String.empty(); }
        let total = self.storage.len * times
        let cap = total + 1
        let data = [UInt8]alloc_memory(cap)
        let mut offset = 0
        let mut t = 0
        while t < times then {
            copy_memory(data.offset(offset), self.storage.data, self.storage.len)
            offset += self.storage.len
            t += 1
        }
        data.offset(total).init(0)
        let storage = ref StringStorage(data, total, cap)
        String(storage)
    }

    public replace_all(self, pat String, with String) String = {
        if pat.storage.len == 0 then {
            panic("replace empty pattern")
        }
        let mut result = String.empty()
        let mut start = 0
        // Using while is pattern matching
        while self.index_of_after(pat, start) is .Some(idx) then {
            let prefix_len = idx - start
            if prefix_len > 0 then {
                let slice = self.make_substring(start, prefix_len)
                result.push_string(slice)
            }
            result.push_string(with)
            start = idx + pat.storage.len
        }
        if start < self.storage.len then {
            let tail = self.make_substring(start, self.storage.len - start)
            result.push_string(tail)
        }
        result
    }

    public split_ascii_whitespace(self) StringSplitAsciiWhitespace =
        StringSplitAsciiWhitespace(self)

    public split(self, sep String) StringSplit = {
        if sep.storage.len == 0 then {
            panic("split empty separator")
        }
        StringSplit(self, sep)
    }

    public lines(self) StringLines = StringLines(self)

    public remove_prefix(self, prefix String) String =
        if self.starts_with(prefix) then { self.make_substring(prefix.storage.len, self.storage.len - prefix.storage.len) } else { self }

    public remove_suffix(self, suffix String) String = {
        if self.ends_with(suffix) then {
            let remain = self.storage.len - suffix.storage.len
            self.make_substring(0, remain)
        } else { self }
    }
}

// ============================================================================
// String Iterator Implementations - Using new pattern matching
// ============================================================================

// Wrapper types provide iterator() method
given StringSplitAsciiWhitespace {
    public iterator(self) StringSplitAsciiWhitespaceIterator =
        StringSplitAsciiWhitespaceIterator(self.source, 0)
}

given StringSplit {
    public iterator(self) StringSplitIterator =
        StringSplitIterator(self.source, self.sep, 0)
}

given StringLines {
    public iterator(self) StringLinesIterator =
        StringLinesIterator(self.source, 0)
}

// Iterator types provide next() method
given StringSplitAsciiWhitespaceIterator {
    public next(self ref) [String]Option = {
        let len = self.source.count()
        let mut i = self.index
        while i < len and String.is_ascii_space(self.source[i]) then { i += 1; }
        if i >= len then { return [String]Option.None(); }
        let start = i
        while i < len and not String.is_ascii_space(self.source[i]) then { i += 1; }
        let part = self.source.slice(start..<i)
        self.index = i
        [String]Option.Some(part)
    }
}

given StringSplitIterator {
    public next(self ref) [String]Option = {
        let len = self.source.count()
        if self.index > len then { return [String]Option.None() }
        when self.source.index_of_after(self.sep, self.index) is {
            .Some(i) then {
                let part = self.source.slice(self.index..<i)
                self.index = i + self.sep.count()
                [String]Option.Some(part)
            },
            .None then {
                let part = self.source.slice(self.index...)
                self.index = len + 1
                [String]Option.Some(part)
            },
        }
    }
}

given StringLinesIterator {
    public next(self ref) [String]Option = {
        let len = self.source.count()
        if self.index > len then { return [String]Option.None() }
        if self.index == len then {
            self.index = len + 1
            return [String]Option.None()
        }
        when self.source.index_of_after("\n", self.index) is {
            .Some(i) then {
                let part = self.source.slice(self.index..<i)
                self.index = i + 1
                [String]Option.Some(part)
            },
            .None then {
                let part = self.source.slice(self.index...)
                self.index = len + 1
                [String]Option.Some(part)
            },
        }
    }
}

// ============================================================================
// Additional String Methods
// ============================================================================

given String {
    // Push a Float64 value directly to the string
    public push_float64(self ref, value Float64) Void = {
        // Handle special cases
        let bits = value.to_bits()
        let exp = { bits >> 52 } & 2047u64
        let mantissa = bits & 4503599627370495u64
        if exp == 2047u64 then {
            if mantissa <> 0u64 then {
                self.push_string("NaN")
                return
            }
            if { bits >> 63 } == 1u64 then {
                self.push_string("-Inf")
                return
            }
            self.push_string("Inf")
            return
        }
        
        let is_negative = { bits >> 63 } == 1u64
        let mut f = if is_negative then 0.0 - value else value
        
        let int_part = (Int)f
        let frac_part = f - (Float64)int_part
        
        if is_negative then { self.push('-'); }
        self.push_int(int_part)
        self.push('.')
        
        let mut frac = frac_part
        let mut digits = 0
        while digits < 6 then {
            frac = frac * 10.0
            let d = (Int)frac
            self.push((UInt8)d + '0')
            frac = frac - (Float64)d
            digits += 1
        }
    }

    // Push a Bool value directly to the string
    public push_bool(self ref, value Bool) Void = {
        if value then {
            self.push_string("true")
        } else {
            self.push_string("false")
        }
    }

    public to_ascii_titlecase(self) String = {
        let cap = self.storage.len + 1
        let data = [UInt8]alloc_memory(cap)
        let mut in_word = false
        let mut i = 0
        while i < self.storage.len then {
            let b = self.storage.data.offset(i).peek()
            if String.is_ascii_space(b) then {
                in_word = false
                data.offset(i).init(b)
            } else {
                if not in_word then {
                    in_word = true
                    data.offset(i).init(String.to_upper_byte(b))
                } else {
                    data.offset(i).init(String.to_lower_byte(b))
                }
            }
            i += 1
        }
        data.offset(self.storage.len).init(0)
        let storage = ref StringStorage(data, self.storage.len, cap)
        String(storage)
    }
}


// ============================================================================
// Primitive ToString Implementations
// ============================================================================

given Bool {
    public to_string(self) String = if self then "true" else "false"
}

given Int {
    public to_string(self) String = {
        if self == 0 then { return "0"; }
    
        let mut n = self
        let is_negative = n < 0
        if is_negative then { n = 0 - n; }
    
        // Extract digits in reverse order into buffer
        let buf = [UInt8]alloc_memory(21)
        let mut pos = 20
        buf.offset(pos).init(0)
        while n > 0 then {
            pos -= 1
            buf.offset(pos).init((UInt8){ n % 10 } + '0')
            n = n / 10
        }
    
        if is_negative then {
            pos -= 1
            buf.offset(pos).init('-')
        }
        
        let len = 20 - pos
        if pos > 0 then {
            move_memory(buf, buf.offset(pos), len + 1)
        }
        let storage = ref StringStorage(buf, len, 21)
        String(storage)
    }
    
    public max() Int = (Int){ (~0u) >> 1 }
    public min() Int = ~Int.max()
}

given Int8 {
    public to_string(self) String = ((Int)self).to_string()
    public max() Int8 = (Int8){ (~0u8) >> 1 }
    public min() Int8 = ~Int8.max()
}

given Int16 {
    public to_string(self) String = ((Int)self).to_string()
    public max() Int16 = (Int16){ (~0u16) >> 1 }
    public min() Int16 = ~Int16.max()
}

given Int32 {
    public to_string(self) String = ((Int)self).to_string()
    public max() Int32 = (Int32){ (~0u32) >> 1 }
    public min() Int32 = ~Int32.max()
}

given Int64 {
    public to_string(self) String = ((Int)self).to_string()
    public max() Int64 = (Int64){ (~0u64) >> 1 }
    public min() Int64 = ~Int64.max()
}


given UInt {
    public to_string(self) String = {
        if self == 0u then { return "0"; }
        
        let mut n = self
        let buf = [UInt8]alloc_memory(21)
        let mut pos = 20
        buf.offset(pos).init(0)
        while n > 0u then {
            pos -= 1
            buf.offset(pos).init((UInt8){ n % 10u } + '0')
            n = n / 10u
        }
    
        let len = 20 - pos
        if pos > 0 then {
            move_memory(buf, buf.offset(pos), len + 1)
        }
        let storage = ref StringStorage(buf, len, 21)
        String(storage)
    }
    
    public max() UInt = ~0u
    public min() UInt = 0u
}

given UInt8 {
    public to_string(self) String = ((UInt)self).to_string()
    public max() UInt8 = ~0u8
    public min() UInt8 = 0u8
}

given UInt16 {
    public to_string(self) String = ((UInt)self).to_string()
    public max() UInt16 = ~0u16
    public min() UInt16 = 0u16
}

given UInt32 {
    public to_string(self) String = ((UInt)self).to_string()
    public max() UInt32 = ~0u32
    public min() UInt32 = 0u32
}

given UInt64 {
    public to_string(self) String = ((UInt)self).to_string()
    public max() UInt64 = ~0u64
    public min() UInt64 = 0u64
}


given Float32 {
    public to_string(self) String = {
        let bits = self.to_bits()
        let exp = { bits >> 23 } & 255u32
        let mantissa = bits & 8388607u32
        if exp == 255u32 then {
            if mantissa <> 0u32 then { return "NaN"; }
            if { bits >> 31 } == 1u32 then { return "-Inf"; }
            return "Inf"
        }
        
        let is_negative = { bits >> 31 } == 1u32
        let mut f = if is_negative then 0.0 - (Float64)self else (Float64)self
        
        let int_part = (Int)f
        let frac_part = f - (Float64)int_part
        
        let mut result = String.empty()
        if is_negative then { result.push('-'); }
        
        result.push_string(int_part.to_string())
        result.push('.')
        
        let mut frac = frac_part
        let mut digits = 0
        while digits < 6 then {
            frac = frac * 10.0
            let d = (Int)frac
            result.push((UInt8)d + '0')
            frac = frac - (Float64)d
            digits += 1
        }
        
        result
    }
    
    public inf() Float32 = Float32.from_bits(2139095040u32)
    public nan() Float32 = Float32.from_bits(2143289344u32)
    public min_normal() Float32 = Float32.from_bits(8388608u32)
    public min_denormal() Float32 = Float32.from_bits(1u32)
    public max() Float32 = Float32.from_bits(2139095039u32)
    public min() Float32 = Float32.from_bits(4286578687u32)
    
    public is_nan(self) Bool = {
        let bits = self.to_bits()
        let exp = { bits >> 23 } & 255u32
        let mantissa = bits & 8388607u32
        exp == 255u32 and mantissa <> 0u32
    }
    
    public is_inf(self) Bool = {
        let bits = self.to_bits()
        let exp = { bits >> 23 } & 255u32
        let mantissa = bits & 8388607u32
        exp == 255u32 and mantissa == 0u32
    }
    
    public is_normal(self) Bool = {
        let bits = self.to_bits()
        let exp = { bits >> 23 } & 255u32
        exp > 0u32 and exp < 255u32
    }
}


given Float64 {
    public to_string(self) String = {
        let bits = self.to_bits()
        let exp = { bits >> 52 } & 2047u64
        let mantissa = bits & 4503599627370495u64
        if exp == 2047u64 then {
            if mantissa <> 0u64 then { return "NaN"; }
            if { bits >> 63 } == 1u64 then { return "-Inf"; }
            return "Inf"
        }
        
        let is_negative = { bits >> 63 } == 1u64
        let mut f = if is_negative then 0.0 - self else self
        
        let int_part = (Int)f
        let frac_part = f - (Float64)int_part
        
        let mut result = String.empty()
        if is_negative then { result.push('-'); }

        result.push_string(int_part.to_string())
        result.push('.')
        
        let mut frac = frac_part
        let mut digits = 0
        while digits < 6 then {
            frac = frac * 10.0
            let d = (Int)frac
            result.push((UInt8)d + '0')
            frac = frac - (Float64)d
            digits += 1
        }
        
        result
    }
    
    public inf() Float64 = Float64.from_bits(2047u64 << 52)
    public nan() Float64 = Float64.from_bits({ 2047u64 << 52 } | { 1u64 << 51 })
    public min_normal() Float64 = Float64.from_bits(1u64 << 52)
    public min_denormal() Float64 = Float64.from_bits(1u64)
    public max() Float64 = {
        let exp_bits UInt64 = 2046u64 << 52
        let mantissa_bits UInt64 = { 1u64 << 52 } - 1u64
        Float64.from_bits(exp_bits | mantissa_bits)
    }
    public min() Float64 = {
        let sign_bit UInt64 = 1u64 << 63
        let exp_bits UInt64 = 2046u64 << 52
        let mantissa_bits UInt64 = { 1u64 << 52 } - 1u64
        Float64.from_bits(sign_bit | exp_bits | mantissa_bits)
    }
    
    public is_nan(self) Bool = {
        let bits = self.to_bits()
        let exp = { bits >> 52 } & 2047u64
        let mantissa = bits & 4503599627370495u64
        exp == 2047u64 and mantissa <> 0u64
    }
    
    public is_inf(self) Bool = {
        let bits = self.to_bits()
        let exp = { bits >> 52 } & 2047u64
        let mantissa = bits & 4503599627370495u64
        exp == 2047u64 and mantissa == 0u64
    }
    
    public is_normal(self) Bool = {
        let bits = self.to_bits()
        let exp = { bits >> 52 } & 2047u64
        exp > 0u64 and exp < 2047u64
    }
}


// ============================================================================
// Option ToString Implementation
// ============================================================================

given [T ToString] [T]Option {
    public to_string(self) String = when self is {
        .Some(v) then {
            let mut result = String.empty()
            result.push_string("Some(")
            result.push_string(v.to_string())
            result.push_string(")")
            result
        },
        .None then "None",
    }
}

// ============================================================================
// Rune Type - Unicode Code Point
// ============================================================================

// Unicode code point wrapper type (0x0000 to 0x10FFFF)
public type Rune(value UInt32)

given Rune {
    // Unicode replacement character U+FFFD
    public replacement_char() Rune = Rune(65533u32)
    
    // Constructor from UInt32
    public from_uint32(value UInt32) Rune = Rune(value)
    
    // Get internal UInt32 value
    public to_uint32(self) UInt32 = self.value
    
    // Equality comparison
    public __equals(self, other Rune) Bool = self.value == other.value
    
    // Ordering comparison
    public __compare(self, other Rune) Int = {
        if self.value < other.value then 0 - 1
        else if self.value > other.value then 1
        else 0
    }
}


// ============================================================================
// Rune UTF-8 Encoding Methods
// ============================================================================

given Rune {
    // Check if rune is valid Unicode code point
    public is_valid(self) Bool = {
        let cp = self.value
        // Valid range: 0x0000-0x10FFFF, excluding surrogates 0xD800-0xDFFF
        cp <= 1114111u32 and (cp < 55296u32 or cp > 57343u32)
    }
    
    // Return number of bytes needed to encode this rune in UTF-8
    public byte_count(self) Int = {
        let cp = self.value
        if not self.is_valid() then { return 3; }  // Replacement char length
        if cp < 128u32 then 1
        else if cp < 2048u32 then 2
        else if cp < 65536u32 then 3
        else 4
    }
    
    // Convert rune to UTF-8 encoded string
    public to_string(self) String = {
        let cp = self.value
        
        // Handle invalid code points - return replacement character
        if not self.is_valid() then {
            let data = [UInt8]alloc_memory(4)
            data.offset(0).init(239u8)   // 0xEF
            data.offset(1).init(191u8)   // 0xBF
            data.offset(2).init(189u8)   // 0xBD
            data.offset(3).init(0u8)
            let storage = ref StringStorage(data, 3, 4)
            return String(storage)
        }
        
        // 1-byte sequence (ASCII)
        if cp < 128u32 then {
            let data = [UInt8]alloc_memory(2)
            data.offset(0).init((UInt8)cp)
            data.offset(1).init(0u8)
            let storage = ref StringStorage(data, 1, 2)
            return String(storage)
        }
        
        // 2-byte sequence
        if cp < 2048u32 then {
            let data = [UInt8]alloc_memory(3)
            data.offset(0).init((UInt8){ cp >> 6 } | 192u8)
            data.offset(1).init((UInt8){ cp & 63u32 } | 128u8)
            data.offset(2).init(0u8)
            let storage = ref StringStorage(data, 2, 3)
            return String(storage)
        }
        
        // 3-byte sequence
        if cp < 65536u32 then {
            let data = [UInt8]alloc_memory(4)
            data.offset(0).init((UInt8){ cp >> 12 } | 224u8)
            data.offset(1).init((UInt8){ { cp >> 6 } & 63u32 } | 128u8)
            data.offset(2).init((UInt8){ cp & 63u32 } | 128u8)
            data.offset(3).init(0u8)
            let storage = ref StringStorage(data, 3, 4)
            return String(storage)
        }
        
        // 4-byte sequence
        let data = [UInt8]alloc_memory(5)
        data.offset(0).init((UInt8){ cp >> 18 } | 240u8)
        data.offset(1).init((UInt8){ { cp >> 12 } & 63u32 } | 128u8)
        data.offset(2).init((UInt8){ { cp >> 6 } & 63u32 } | 128u8)
        data.offset(3).init((UInt8){ cp & 63u32 } | 128u8)
        data.offset(4).init(0u8)
        let storage = ref StringStorage(data, 4, 5)
        String(storage)
    }
}


// ============================================================================
// Rune Character Classification Methods
// ============================================================================

given Rune {
    // Check if rune is in ASCII range (0x00-0x7F)
    public is_ascii(self) Bool = self.value < 128u32
    
    // Check if rune is ASCII digit (0-9)
    public is_ascii_digit(self) Bool = {
        let cp = self.value
        cp >= 48u32 and cp <= 57u32  // '0' to '9'
    }
    
    // Check if rune is ASCII whitespace
    public is_ascii_whitespace(self) Bool = {
        let cp = self.value
        cp == 32u32 or   // Space
        cp == 9u32 or    // Tab
        cp == 10u32 or   // LF
        cp == 13u32 or   // CR
        cp == 12u32 or   // Form feed
        cp == 11u32      // Vertical tab
    }
    
    // Check if rune is ASCII letter (A-Z, a-z)
    public is_ascii_letter(self) Bool = {
        let cp = self.value
        (cp >= 65u32 and cp <= 90u32) or   // A-Z
        (cp >= 97u32 and cp <= 122u32)     // a-z
    }
    
    // Check if rune is ASCII alphanumeric
    public is_ascii_alphanumeric(self) Bool = 
        self.is_ascii_letter() or self.is_ascii_digit()
}


given Rune {
    // Check if rune is Unicode letter (simplified: ASCII + Latin Extended + CJK)
    public is_letter(self) Bool = {
        let cp = self.value
        // ASCII letters
        if (cp >= 65u32 and cp <= 90u32) or (cp >= 97u32 and cp <= 122u32) then {
            return true
        }
        // Latin Extended-A, Extended-B, and more (0x00C0-0x024F)
        if cp >= 192u32 and cp <= 591u32 then { return true; }
        // CJK Unified Ideographs (0x4E00-0x9FFF)
        if cp >= 19968u32 and cp <= 40959u32 then { return true; }
        // CJK Extension A (0x3400-0x4DBF)
        if cp >= 13312u32 and cp <= 19903u32 then { return true; }
        // Hiragana (0x3040-0x309F)
        if cp >= 12352u32 and cp <= 12447u32 then { return true; }
        // Katakana (0x30A0-0x30FF)
        if cp >= 12448u32 and cp <= 12543u32 then { return true; }
        // Hangul Syllables (0xAC00-0xD7AF)
        if cp >= 44032u32 and cp <= 55215u32 then { return true; }
        // Greek (0x0370-0x03FF)
        if cp >= 880u32 and cp <= 1023u32 then { return true; }
        // Cyrillic (0x0400-0x04FF)
        if cp >= 1024u32 and cp <= 1279u32 then { return true; }
        false
    }
    
    // Check if rune is Unicode digit (simplified: ASCII digits only for now)
    public is_digit(self) Bool = self.is_ascii_digit()
    
    // Check if rune is Unicode whitespace
    public is_whitespace(self) Bool = {
        let cp = self.value
        // ASCII whitespace
        if self.is_ascii_whitespace() then { return true; }
        // NEL (Next Line)
        if cp == 133u32 then { return true; }
        // NBSP (No-Break Space)
        if cp == 160u32 then { return true; }
        // Various Unicode spaces (0x2000-0x200A)
        if cp >= 8192u32 and cp <= 8202u32 then { return true; }
        // Line Separator
        if cp == 8232u32 then { return true; }
        // Paragraph Separator
        if cp == 8233u32 then { return true; }
        // Narrow No-Break Space
        if cp == 8239u32 then { return true; }
        // Medium Mathematical Space
        if cp == 8287u32 then { return true; }
        // Ideographic Space
        if cp == 12288u32 then { return true; }
        false
    }
    
    // Check if rune is newline character
    public is_newline(self) Bool = {
        let cp = self.value
        cp == 10u32 or   // LF
        cp == 13u32 or   // CR
        cp == 133u32 or  // NEL (Next Line)
        cp == 8232u32 or // Line Separator
        cp == 8233u32    // Paragraph Separator
    }
}


given Rune {
    // Check if rune can start an identifier (letter or underscore)
    public is_identifier_start(self) Bool = {
        let cp = self.value
        // Underscore
        if cp == 95u32 then { return true; }
        // Letter
        self.is_letter()
    }
    
    // Check if rune can continue an identifier (letter, digit, or underscore)
    public is_identifier_continue(self) Bool = {
        let cp = self.value
        // Underscore
        if cp == 95u32 then { return true; }
        // Letter or digit
        self.is_letter() or self.is_digit()
    }
}


// ============================================================================
// Rune Iterator Types
// ============================================================================

// Wrapper type for rune iteration (provides iterator() method)
public type Runes(source String)

// Iterator type for rune iteration (provides next() method)
public type RunesIterator(source String, mut byte_index Int)

given Runes {
    public iterator(self) RunesIterator = RunesIterator(self.source, 0)
}


given RunesIterator {
    // Decode next UTF-8 sequence and return Rune
    public next(self ref) [Rune]Option = {
        let len = self.source.count()
        if self.byte_index >= len then {
            return [Rune]Option.None()
        }
        
        let b0 = self.source[self.byte_index]
        
        // 1-byte sequence (ASCII): 0xxxxxxx
        if b0 < 128u8 then {
            self.byte_index = self.byte_index + 1
            return [Rune]Option.Some(Rune((UInt32)b0))
        }
        
        // Invalid: continuation byte as first byte
        if b0 < 192u8 then {
            self.byte_index = self.byte_index + 1
            return [Rune]Option.Some(Rune.replacement_char())
        }
        
        // 2-byte sequence: 110xxxxx 10xxxxxx
        if b0 < 224u8 then {
            if self.byte_index + 1 >= len then {
                self.byte_index = self.byte_index + 1
                return [Rune]Option.Some(Rune.replacement_char())
            }
            let b1 = self.source[self.byte_index + 1]
            if { b1 & 192u8 } <> 128u8 then {
                self.byte_index = self.byte_index + 1
                return [Rune]Option.Some(Rune.replacement_char())
            }
            let cp = { { (UInt32)b0 & 31u32 } << 6 } | { (UInt32)b1 & 63u32 }
            // Check for overlong encoding
            if cp < 128u32 then {
                self.byte_index = self.byte_index + 2
                return [Rune]Option.Some(Rune.replacement_char())
            }
            self.byte_index = self.byte_index + 2
            return [Rune]Option.Some(Rune(cp))
        }
        
        // 3-byte sequence: 1110xxxx 10xxxxxx 10xxxxxx
        if b0 < 240u8 then {
            if self.byte_index + 2 >= len then {
                self.byte_index = self.byte_index + 1
                return [Rune]Option.Some(Rune.replacement_char())
            }
            let b1 = self.source[self.byte_index + 1]
            let b2 = self.source[self.byte_index + 2]
            if { b1 & 192u8 } <> 128u8 or { b2 & 192u8 } <> 128u8 then {
                self.byte_index = self.byte_index + 1
                return [Rune]Option.Some(Rune.replacement_char())
            }
            let cp = { { (UInt32)b0 & 15u32 } << 12 } | { { (UInt32)b1 & 63u32 } << 6 } | { (UInt32)b2 & 63u32 }
            // Check for overlong encoding or surrogate
            if cp < 2048u32 or (cp >= 55296u32 and cp <= 57343u32) then {
                self.byte_index = self.byte_index + 3
                return [Rune]Option.Some(Rune.replacement_char())
            }
            self.byte_index = self.byte_index + 3
            return [Rune]Option.Some(Rune(cp))
        }
        
        // 4-byte sequence: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        if b0 < 248u8 then {
            if self.byte_index + 3 >= len then {
                self.byte_index = self.byte_index + 1
                return [Rune]Option.Some(Rune.replacement_char())
            }
            let b1 = self.source[self.byte_index + 1]
            let b2 = self.source[self.byte_index + 2]
            let b3 = self.source[self.byte_index + 3]
            if { b1 & 192u8 } <> 128u8 or { b2 & 192u8 } <> 128u8 or { b3 & 192u8 } <> 128u8 then {
                self.byte_index = self.byte_index + 1
                return [Rune]Option.Some(Rune.replacement_char())
            }
            let cp = { { (UInt32)b0 & 7u32 } << 18 } | { { (UInt32)b1 & 63u32 } << 12 } | { { (UInt32)b2 & 63u32 } << 6 } | { (UInt32)b3 & 63u32 }
            // Check for overlong encoding or out of range
            if cp < 65536u32 or cp > 1114111u32 then {
                self.byte_index = self.byte_index + 4
                return [Rune]Option.Some(Rune.replacement_char())
            }
            self.byte_index = self.byte_index + 4
            return [Rune]Option.Some(Rune(cp))
        }
        
        // Invalid first byte
        self.byte_index = self.byte_index + 1
        [Rune]Option.Some(Rune.replacement_char())
    }
}


// ============================================================================
// String Rune Methods
// ============================================================================

given String {
    // Return Runes wrapper for iterating over Unicode code points
    public runes(self) Runes = Runes(self)
}


given String {
    // Count number of Unicode code points (runes) in the string
    public rune_count(self) Int = {
        let mut count = 0
        let mut iter = self.runes().iterator()
        while iter.next() is .Some(_) then {
            count = count + 1
        }
        count
    }
}


given String {
    // Get rune at specified index (0-based rune position, not byte position)
    public get_rune(self, index Int) [Rune]Option = {
        if index < 0 then {
            return [Rune]Option.None()
        }
        let mut iter = self.runes().iterator()
        let mut i = 0
        while iter.next() is .Some(r) then {
            if i == index then {
                return [Rune]Option.Some(r)
            }
            i = i + 1
        }
        [Rune]Option.None()
    }
}


given String {
    // Append a rune to the string (encodes as UTF-8)
    public push_rune(self ref, rune Rune) Void = {
        let cp = rune.value
        
        // Handle invalid code points - append replacement character
        if not rune.is_valid() then {
            self.push(239u8)   // 0xEF
            self.push(191u8)   // 0xBF
            self.push(189u8)   // 0xBD
            return
        }
        
        // 1-byte sequence (ASCII)
        if cp < 128u32 then {
            self.push((UInt8)cp)
            return
        }
        
        // 2-byte sequence
        if cp < 2048u32 then {
            self.push((UInt8){ cp >> 6 } | 192u8)
            self.push((UInt8){ cp & 63u32 } | 128u8)
            return
        }
        
        // 3-byte sequence
        if cp < 65536u32 then {
            self.push((UInt8){ cp >> 12 } | 224u8)
            self.push((UInt8){ { cp >> 6 } & 63u32 } | 128u8)
            self.push((UInt8){ cp & 63u32 } | 128u8)
            return
        }
        
        // 4-byte sequence
        self.push((UInt8){ cp >> 18 } | 240u8)
        self.push((UInt8){ { cp >> 12 } & 63u32 } | 128u8)
        self.push((UInt8){ { cp >> 6 } & 63u32 } | 128u8)
        self.push((UInt8){ cp & 63u32 } | 128u8)
    }
}
