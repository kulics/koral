// ============================================================================
// Koral Standard Library - Set Type
// ============================================================================
// NOTE: This file is merged into core.koral, so all previous types are already available.
// ============================================================================

// ============================================================================
// Set Storage and Type Definition
// ============================================================================

public type [T Hashable]SetBucket {
    Empty(),
    Occupied(value T),
    Deleted(),
}

public type [T Hashable]SetStorage(
    mut buckets [[T]SetBucket]Pointer,
    mut count Int,
    mut capacity Int
)

given[T Hashable] [T]SetStorage {
    __drop(self ref) = {
        let mut i = 0
        while i < self.capacity then {
            self.buckets.offset(i).deinit()
            i += 1
        }
        dealloc_memory(self.buckets)
    }
}

public type [T Hashable]Set(mut storage [T]SetStorage ref)

public type [T Hashable]SetIterator(storage [T]SetStorage ref, mut index Int)


// ============================================================================
// Set Methods
// ============================================================================

given[T Hashable] [T]Set {
    public new() Self = {
        let capacity = 16
        let buckets = [[T]SetBucket]alloc_memory(capacity)
        let mut i = 0
        while i < capacity then {
            buckets.offset(i).init([T]SetBucket.Empty())
            i += 1
        }
        let storage = ref [T]SetStorage(buckets, 0, capacity)
        [T]Set(storage)
    }

    public with_capacity(capacity Int) Self = {
        // Hash tables need extra space for efficiency (load factor ~0.5)
        let cap = if capacity < 4 then 4 else capacity * 2
        let buckets = [[T]SetBucket]alloc_memory(cap)
        let mut i = 0
        while i < cap then {
            buckets.offset(i).init([T]SetBucket.Empty())
            i += 1
        }
        let storage = ref [T]SetStorage(buckets, 0, cap)
        [T]Set(storage)
    }

    public count(self) Int = self.storage.count

    private ensure_unique(self ref) Void = {
        if ref_count(self.storage) > 1 then {
            let old = self.storage
            let new_buckets = [[T]SetBucket]alloc_memory(old.capacity)
            let mut i = 0
            while i < old.capacity then {
                let bucket = old.buckets.offset(i).peek()
                new_buckets.offset(i).init(bucket)
                i += 1
            }
            let new_storage = ref [T]SetStorage(new_buckets, old.count, old.capacity)
            self.storage = new_storage
        }
    }

    // Using when for bucket handling
    private find_slot(self ref, value T ref) Int = {
        let h = value.hash()
        let mut idx = (Int){ h % (UInt)self.storage.capacity }
        let mut first_deleted = 0 - 1
        let mut probes = 0
        while probes < self.storage.capacity then {
            let bucket = self.storage.buckets.offset(idx).peek()
            when bucket is {
                .Empty then {
                    if first_deleted >= 0 then { return first_deleted; }
                    return idx
                },
                .Deleted then {
                    if first_deleted < 0 then { first_deleted = idx; }
                },
                .Occupied(v) then {
                    if v == deref value then { return idx; }
                },
            }
            idx = { idx + 1 } % self.storage.capacity
            probes += 1
        }
        if first_deleted >= 0 then first_deleted else 0 - 1
    }

    private rehash(self ref) Void = {
        let old_cap = self.storage.capacity
        let old_buckets = self.storage.buckets
        let new_cap = old_cap * 2
        let new_buckets = [[T]SetBucket]alloc_memory(new_cap)
        let mut i = 0
        while i < new_cap then {
            new_buckets.offset(i).init([T]SetBucket.Empty())
            i += 1
        }
        self.storage.buckets = new_buckets
        self.storage.capacity = new_cap
        self.storage.count = 0
        i = 0
        while i < old_cap then {
            let bucket = old_buckets.offset(i).take()
            when bucket is {
                .Occupied(v) then { self.insert(v); },
                _ then {},
            }
            i += 1
        }
        dealloc_memory(old_buckets)
    }


    // Returns true if value was new, false if already present
    public insert(self ref, value T) Bool = {
        self.ensure_unique()
        if self.storage.count * 2 >= self.storage.capacity then { self.rehash(); }
        let idx = self.find_slot(ref value)
        if idx < 0 then { panic("Set insert failed"); }
        let bucket = self.storage.buckets.offset(idx).peek()
        when bucket is {
            .Occupied(_) then false,
            .Empty or .Deleted then {
                self.storage.buckets.offset(idx).replace([T]SetBucket.Occupied(value));
                self.storage.count = self.storage.count + 1
                true
            },
        }
    }

    public contains(self, value T) Bool = {
        let idx = self.find_slot(ref value)
        if idx < 0 then { return false; }
        let bucket = self.storage.buckets.offset(idx).peek()
        when bucket is {
            .Occupied(_) then true,
            _ then false,
        }
    }

    public remove(self ref, value T) Bool = {
        self.ensure_unique()
        let idx = self.find_slot(ref value)
        if idx < 0 then { return false; }
        let bucket = self.storage.buckets.offset(idx).peek()
        when bucket is {
            .Occupied(_) then {
                self.storage.buckets.offset(idx).replace([T]SetBucket.Deleted());
                self.storage.count = self.storage.count - 1
                true
            },
            _ then false,
        }
    }

    public is_empty(self) Bool = self.storage.count == 0

    public clear(self ref) Void = {
        self.ensure_unique()
        let mut i = 0
        while i < self.storage.capacity then {
            self.storage.buckets.offset(i).replace([T]SetBucket.Empty());
            i += 1
        }
        self.storage.count = 0
    }

    // Using while is pattern matching for iterator loops
    public union(self, other [T]Set) [T]Set = {
        let mut result = [T]Set.new()
        let mut it = self.iterator()
        while it.next() is .Some(v) then { result.insert(v); }
        let mut it2 = other.iterator()
        while it2.next() is .Some(v) then { result.insert(v); }
        result
    }

    public intersection(self, other [T]Set) [T]Set = {
        let mut result = [T]Set.new()
        let mut it = self.iterator()
        while it.next() is .Some(v) then {
            if other.contains(v) then { result.insert(v); }
        }
        result
    }

    public difference(self, other [T]Set) [T]Set = {
        let mut result = [T]Set.new()
        let mut it = self.iterator()
        while it.next() is .Some(v) then {
            if not other.contains(v) then { result.insert(v); }
        }
        result
    }

    public iterator(self) [T]SetIterator = [T]SetIterator(self.storage, 0)
}


// ============================================================================
// Set Iterator
// ============================================================================

given[T Hashable] [T]SetIterator {
    public next(self ref) [T]Option = {
        while self.index < self.storage.capacity then {
            let bucket = self.storage.buckets.offset(self.index).peek()
            self.index = self.index + 1
            when bucket is {
                .Occupied(v) then { return [T]Option.Some(v); },
                _ then {},
            }
        }
        [T]Option.None()
    }
}

// ============================================================================
// Set ToString Implementation
// ============================================================================

given [T ToString and Hashable] [T]Set {
    public to_string(self) String = {
        let mut result = String.empty()
        result.push_string("[")
        let mut first = true
        let mut i = 0
        while i < self.storage.capacity then {
            let bucket = self.storage.buckets.offset(i).peek()
            when bucket is {
                .Occupied(v) then {
                    if not first then { result.push_string(", "); }
                    first = false
                    result.push_string(v.to_string())
                },
                _ then {},
            }
            i += 1
        }
        result.push_string("]")
        result
    }
}
