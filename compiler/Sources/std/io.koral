// ============================================================================
// Koral Standard Library - IO Functions
// ============================================================================
// NOTE: This file is merged into core.koral, so all previous types are already available.
// ============================================================================

// ============================================================================
// Panic and Assertion
// ============================================================================

// High-level panic function (uses String)
public let panic(message String) Never = {
    // Write "Panic: " prefix
    let prefix = "Panic: "
    fwrite(prefix.storage.data, prefix.storage.len, std_err);
    // Write message
    fwrite(message.storage.data, message.storage.len, std_err);
    // Write newline
    let newline = "\n"
    fwrite(newline.storage.data, newline.storage.len, std_err);
    // Flush stderr
    fflush(std_err);
    // Exit with error code
    exit(1)
}

public let assert(condition Bool, message String) Void = {
    if not condition then { panic(message) }
}

// ============================================================================
// Standard IO Functions
// ============================================================================

// Print value to stdout (no newline, auto flush)
public let [T ToString]print(value T) Void = {
    let s = value.to_string()
    fwrite(s.storage.data, s.storage.len, std_out);
    fflush(std_out)
}

// Print value to stdout (with newline, auto flush)
public let [T ToString]print_line(value T) Void = {
    let s = value.to_string()
    fwrite(s.storage.data, s.storage.len, std_out);
    let newline = "\n"
    fwrite(newline.storage.data, newline.storage.len, std_out);
    fflush(std_out)
}


// Print value to stderr (no newline, auto flush)
public let [T ToString]error_print(value T) Void = {
    let s = value.to_string()
    fwrite(s.storage.data, s.storage.len, std_err);
    fflush(std_err)
}

// Print value to stderr (with newline, auto flush)
public let [T ToString]error_print_line(value T) Void = {
    let s = value.to_string()
    fwrite(s.storage.data, s.storage.len, std_err);
    let newline = "\n"
    fwrite(newline.storage.data, newline.storage.len, std_err);
    fflush(std_err)
}

// Read a line from stdin - Using new pattern matching
public let read_line() [String]Option = {
    let mut result = String.empty()
    
    while true then {
        let ch = fgetc(std_in)
        
        // EOF - Using comparison pattern
        if ch is < 0 then {
            if result.is_empty() then {
                return [String]Option.None()
            }
            break
        }
        
        // Newline - end of line
        if ch == 10 then {  // '\n' = 10
            break
        }
        
        // Skip carriage return (for Windows line endings)
        if ch == 13 then {  // '\r' = 13
            continue
        }
        
        // Add character to result
        result.push((UInt8)ch)
    }
    
    [String]Option.Some(result)
}
